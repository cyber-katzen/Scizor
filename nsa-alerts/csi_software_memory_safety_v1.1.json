{
  "markdown": " \nU/OO/219936 -22 | PP-23-0782  | APR 2023 Ver. 1.1 \nNational Security Agency  | Cybersecurity Information  Sheet  \nSoftware Memory Safety  \nExecutive s ummary  \nModern society relies heavily on software -based automation, implicitly trusting \ndevelopers to write software that operates in the expected way and cannot be \ncompromised for malicious purposes. While developers often perform rigorous testing  to \nprepare the logic in software for surprising conditions, exploit able software \nvulnerabilities are still frequently based on memory issues . Examples include \noverflowing a  memory buffer and leveraging issues with how software  allocates and de -\nallocates memory . Microsoft revealed at a conference in 2019 that from 2006  to 2018 \n70 percent  of their vulnerabilities were due to memory safe ty issues . [1] Google also \nfound a similar percentage of memory safety vulnerabilities over several years in \nChrome. [2] Malicious cyber actors can exploit these vulnerabilities for re mote code \nexecution or other adverse effects, which can often compromise a device and be the \nfirst step in large -scale network intrusions.   \nCommonly used languages , such as C and C++ , provide a lot of freedom and flexibility \nin memory management while relying heavily on the programmer to perform the needed \nchecks on memory references. Simple mistakes can lead to exploitable memory -based  \nvulnerabilities . Software analysis tools can detect many instances of memory \nmanagement issues  and operating environment o ptions can also provide some \nprotection , but i nherent protections offered by memory safe software languages can \nprevent or mitigate most memory management issues.  NSA recommends  using  a \nmemory safe language when possible . While the use of added protections  to non -\nmemory safe languages and the use of memory safe languages do not provide absolute \nprotection against exploitable memory issues, they do provide considerable protection.  \nTherefore, t he overarching software community across the private sector, academia , \nand the U.S. G overnment have begun initiatives to drive the culture of software \ndevelopment towards utilizing memory safe languages . [3] [4] [5] \n  \n\n \n \n \nU/OO/219936 -22 | PP-23-0782  | APR 2023 Ver. 1.1 2 \nNSA | Software Memory Safety  \nThe memory safety p roblem  \nHow a software program manages memory  is core to prev enting many vulnerabilities \nand ensuring a program is robust. Exploiting poor or careless memory management can \nallow a  malicious cyber actor  to perform nefarious acts , such as crashing the program at \nwill or changing  the instructions of the executing program to do whatever the actor \ndesires. Even un -exploitable issues with memory management can result in incorrect \nprogram results, degradation of the programs performance over time, or seemingly \nrandom program crashes.  \nMemory safety is a broad category of i ssues related to how a program manages \nmemory.  One common issue is called  a buffer overflow where data is accessed \noutside the bounds of an array. Other common issues relate to memory allocation. \nLanguages can allocate new memory locations as a program is executing and then \ndeallocate the memory, also called releasing or free ing the memory, later when the \nmemory is no longer needed. But if this is not done carefully  by the developer , new \nmemory may be allocated again and again as the program executes . Consequently, \nmemory is not always freed when it is no longer needed, result ing in a memory leak that \ncould cause the program to eventually run out of available memory. Due to logic errors, \nprograms can also attempt to use memory that has been freed, or even free memory \nthat has already been freed. Another issue can arise when lan guages allow the use of a \nvariable that has not been initialized, resulting in the variable using the value that was \npreviously set at that location in memory. Finally, another challenging issue is called a \nrace condition. This issue can occur when a progr ams results depend on the order of \noperation of two parts of the program accessing the same data. All of these memory \nissues are much too common occurrences.   \nBy exploiting these types of memory issues, malicious actors who are not bound by \nnormal expecta tions of software use may find that they can enter unusual inputs into \nthe program, causing memory to be accessed, written, allocated, or deallocated in \nunexpected ways. In some cases, a malicious actor can exploit these memory \nmanagement mistakes to acces s sensitive information, execute unauthorized code, or \ncause other negative impacts.  Since it may take a lot of experimenting with unusual \ninputs to find one that causes an unexpected response, actors may use a technique \ncalled fuzzing to either randomly  or intelligently craft multitudes of input values to the \nprogram until one is found that causes the program to crash. Advances in fuzzing tools \n\n \n \n \nU/OO/219936 -22 | PP-23-0782  | APR 2023 Ver. 1.1 3 \nNSA | Software Memory Safety  \nand techniques have made finding problematic inputs easier for malicious actors in \nrecent years. Once an actor discovers they can crash the program with a particular \ninput, they examine the code and work to determine what a specially crafted input could \ndo. In the worst case, such an input could allow the actor to take control of the system \non which the program is running.  \nMemory safe languages  \nUsing a memory safe language can help prevent programmers from introducing certain \ntypes of memory -related issues . Memory is managed automatically as part of the \ncomputer language ; it does not rely on the programmer adding co de to implement \nmemory protections. The language institutes automatic protections using a combination \nof compile time and runtime checks. These inherent language features protect the \nprogrammer from introducing memory management mistakes unintentionally.  Examples \nof memory safe language include Python, Java, C#, Go, Delphi/Object Pascal, Swift, \nRuby , Rust, and Ada.  \nEven with a memory safe language, memory management is not entirely memory safe. \nMost memory safe languages recognize that software sometimes needs to perform an \nunsafe memory management function to accomplish certain tasks . As a result, classes \nor functions are available that are recognized as non -memory safe and allow the \nprogrammer to perform a potentially unsafe memory management t ask. Some \nlanguages require anything memory unsafe to be explicitly annotated as such to make \nthe programmer and any reviewers of the program aware  that it is unsafe . Memory safe \nlanguages can also use libraries written in non -memory safe languages and thu s can \ncontain unsafe memory functionality. Although these ways of including memory unsafe \nmechanisms subvert the inherent memory safety, they help to localize where memory \nproblems could exist, allowing for extra scrutiny on those sections of code.  \nLanguag es vary in their degree of memory safety  instituted through  inherent protections \nand mitigations . Some languages provide only relatively minimal  memory safety  \nwhereas some languages are very strict and provide considerable protections by \ncontrolling how me mory is allocated, accessed , and managed.  For languages with an \nextreme level of inherent protection, considerable work may be needed to simply get the \nprogram to compile due to the checks and protections.   \n\n \n \n \nU/OO/219936 -22 | PP-23-0782  | APR 2023 Ver. 1.1 4 \nNSA | Software Memory Safety  \nMemory safety can be costly in performance and fl exibility. Most memory safe \nlanguages require some sort of  garbage collection to reclaim  memory  that has been \nallocated, but is no longer needed by the program . There is also considerable \nperformance overhead associated with checking the bounds on every ar ray access that \ncould potentially be outside of the array.  \nAlternatively, a similar performance hit can exist in a non -memory safe language due to \nthe checks  a programmer adds to the program to perform bounds checking and other \nmemory management protectio ns. Additional costs of using non -memory safe \nlanguages include hard -to-diagnose memory corruption and occasional program \ncrashes along with the potential for exploitation of memory access vulnerabilities  \nIt is n ot trivial to shift a mature software develo pment infrastructure from one computer \nlanguage to another. Skilled programmers need to be trained in a new language and \nthere is a n efficienc y hit when using a new language. P rogrammers must endure a \nlearning curve and work their way through any newbie mistakes. While another \napproach is to hire  programmers skilled in a memory safe language , they  too will have \ntheir own  learning curve for understanding the existing code base and the domain in \nwhich the software will function.  \nApplication security testing  \nSeveral mechanisms can be used to harden non -memory  safe languages to make them \nmore memory safe.  Analyzing the software using static and  dynamic appli cation security \ntesting (SAST and  DAST) can identify memory use issues in software.  \nStatic analysis examines the source code to find potential security issues. Using SAST \nallows all of the code to be examined, but it can generate a considerable number of \nfalse positives through identifying potential issues incorrectly.  However,  SAST can be \nused throughout the development of the software  allowing issues to be identified and \nfixed earl y in the software development process. Rigorous test s have shown that even \nthe best -performing SAST tools only identify a portion  of memory issues in even the \nsimp lest software programs and usually generate many false positives.  \nIn contrast to SAST, d ynamic analysis  examines the code while it is executing. DAST \nrequires a running application . This means most issues w ill not be identified until late  in \nthe development cycle , making the identified problem more expensive to fix and \n\n \n \n \nU/OO/219936 -22 | PP-23-0782  | APR 2023 Ver. 1.1 5 \nNSA | Software Memory Safety  \nregressively test. DAST can only identify issues with code that is on the execution path \nwhen the tool is run, so code coverage is also an issue. However, DAST has a much \nlower perc entage of false positives than SAST. Issues such as a memory leak can be \nidentified by DAST, but the underlying cause of the memory issue may be very difficult \nto identify in the software.  \nNeither SAST nor DAST can make non -memory safe code totally memory safe. Since \nall tools have their strengths and weaknesses, it is recommended that multiple SAST \nand DAST tools be run to increase the chances that memory or other issues are \nidentified. Working through the issues identified by the tools can take considerab le \nwork, but will result  in more robust and secure code.  Vulnerability correlation tools can \nintake the results from multiple tools and integrate them into a single report to simplify \nand help prioritize analysis.  \nAnti-exploitation features  \nThe compilation  and execution environment can be used to make it more difficult for \ncyber actors to exploit memory management issues. Most of these added features \nfocus on limiting where code can be executed in memory and making memory layout \nunpredictable. As a result, this reduces a malicious actors  opportunities to use the \nexploitation tradecraft of executing data as code  and overwriting a return address to \ndirect program flow to a nefarious location.  \nLeveraging option s, such as Control Flow Guard (CFG) , will place r estrictions on where \ncode can be executed. Similarly , Address Space Layout Randomization (ASLR) and \nData Execution Prevention (DEP) add unpredictability to where items are located in \nmemory and prevent data from being executed as code.  [6] [7] Bypassing ASLR and \nDEP is not insurmountable to a malicious act or, but it makes developing an exploit \nmuch more difficult and lowers the odds of an exploit  succeeding . Anti-exploitation \nfeatures can help mitigate vulnerabilities in both memory safe and non -memory safe \nlanguages.  \nThe path forward  \nMemory issues in softw are comprise a large portion of the exploitable vulnerabilities  in \nexistence . NSA advises organizations to consider making a  strategic shift from \nprogramming languages that provide little or no inherent memory protection, such as \n\n \n \n \nU/OO/219936 -22 | PP-23-0782  | APR 2023 Ver. 1.1 6 \nNSA | Software Memory Safety  \nC/C++  and assembly , to a m emory safe language whe n possible.  Some examples of \nmemory safe languages are Python, Java, C#, Go, Delphi/Object Pascal, Swift , Ruby, \nRust, and Ada . Memory safe languages provide differing degrees of memory usage \nprotections, so a vailable code hardening defenses , such as compiler options, tool \nanalysis, and operating system configurations , should be used for their  protection s as \nwell. By using memory safe languages  and available  code hardening defenses , many  \nmemory vulnerabilities can be prevented, mitiga ted, or made very difficult for cyber \nactors  to exploit.  \nWorks cited  \n[1] Microsoft (2019), \"Trends, challenges, and strategic shifts in the software vulnerability mitigation \nlandscape\". https://github.com/Microsoft/MSRC -Security -\nResearch/blob/master/presentations/2019_02_BlueHatIL/2 019_01%20 -%20BlueHatIL%20 -\n%20Trends%2C%20challenge%2C%20and%20shifts%20in%20software%20vulnerability%20miti\ngation.pdf   \n[2] Google (2021), \"An update on Memory Safety in Chrome\". \nhttps://security.googleblog.com/2021/09/an -update -on-memory -safety -in-chrome.html   \n[3] Georgia Institute of Technology (2022) , \"Recommendations from the Workshop on Open -sourc e \nSoftware Security Initiative\".  https://cpb -us-\nw2.wpmucdn.com/sites.gatech.edu/dist/a/2878/files/2022/10/OSSI -Final -Report.pdf   \n[4] The Linux Foundation (2022),  \"The Linux Foundation and Open Source Software Security  \nFoundation (OpenSSF) Gather Industry and Government Leaders for Open Sour ce Software \nSecurity Summit II\".  https://www.linuxfoundation.org/press/press -release/linux -foundation -\nopenssf -gather -industry -government -leaders -open -source -software -security -summit   \n[5] The Linux Foundation Open Source Security Foundation  (2022) , \"The Open Source Softw are \nSecurity Mobilization Plan\".  https://openssf.org/oss -security -mobilization -plan/   \n[6] National Security Agency ( 2019 ), Windows 10 for Enterprises Security Benefits of Timely \nAdoption . https://media.defense.gov/2019/Jul/16/2002158052/ -1/-1/0/CSI -WINDOWS -10-FOR -\nENTERPRISE -SECURITY -BENEFITS -OF-TIMELY -ADOP TION.PDF  \n[7] National Security Agency ( 2019 ), Leverage Modern Hardware Security Features.  \nhttps://media.defense.gov/20 19/Sep/09/2002180345/ -1/-\n1/0/Leverage%20Modern%20Hardware%20Security%20Features%20 -%20Copy.pdf   \n  \n\n \n \n \nU/OO/219936 -22 | PP-23-0782  | APR 2023 Ver. 1.1 7 \nNSA | Software Memory Safety  \nDisclaimer of endorsement  \nThe information and opinions contained in this document are provided \"as is\" and without any warranties or \nguarantees. Reference herei n to any specific commercial products, process, or service by trade name, trademark, \nmanufacturer, or otherwise, does not constitute or imply its endorsement, recommendation, or favoring by the United \nStates Government, and this guidance shall not be used for advertising or product endorsement purposes.  \n \nTrademarks  \nChrome  is a trademark of Google , Inc. in the U.S. and other counties.  \nGoogle is a registered trademark of  Google, Inc.  in the United States and/or other countries.  \nJava is a registered trademark of Sun Microsystems Inc.  in the United States and/or other countries.  \nLinux is a registered trademark of Linus Torvalds in the United States and/or other countries.  \nMicrosoft and Windows are registered trademark s of Microsoft Corporation in the United States and/or other \ncountries.  \nPython is a registered trademark of the Python Software Foundation  in the United States and/or other countries.  \nSwift is a registered trademark of Apple, Inc.  in the U.S. and/or other cou ntries.  \nRuby  is a registered trademark of OReilly Media Inc . in the United States and/or other countries.  \nRust is a registered trademark of Mozilla Foundation in the United States and/or other countries.  \nPurpose  \nThis document was developed  in furtherance of NSAs cybersecurity missions, including its responsibilities to identify \nand disseminate threats to National Security Systems, Department of Defense, and Defense Industrial Base \ninformation systems, and to develop and issue cybersecurity  specifications and mitigations. This information may be \nshared broadly to reach all appropriate stakeholders.  \nContact  \nCybersecurity Report Feedback: CybersecurityReports@nsa.gov  \nGeneral Cybersecurity Inquiries : Cybersecurity_Requests@n sa.gov   \nDefense Industrial Bas e Inquiries and Cybersecurity Services: DIB_Defense@cyber.nsa.gov  \nMedia Inquiries / Press Desk: 443 -634-0721, MediaRelations@nsa.gov   \n\n",
  "cves": [],
  "techniques": [],
  "advisory": "cybersecurity-alerts",
  "title": "csi_software_memory_safety_v1.1",
  "source": "nsa",
  "id": "a80abec75f153231a831eb4e9111758b03edbea044621e5332d06cce12099448"
}