{
  "markdown": "Network Device Integrity (NDI) \nMethodology  \nFebruary 23, 2016 \n  \n\n2 Table of Contents \n \nNetwork Device Integrity (NDI) Methodology ............................................................................................ 4 \nIntroduction ............................................................................................................................................... 4 \nUnauthorized Access ................................................................................................................................ 4 \nSoftware Modification .............................................................................................................................. 5  \nHardware Modification ............................................................................................................................. 6 \nPrevention ................................................................................................................................................. 7 \nRemediation .............................................................................................................................................. 8 \nNetwork Device Integrity (NDI) - Unauthorized Access Detection ........................................................... 11 \nLogin Access ........................................................................................................................................... 11 \nConfiguration Changes ........................................................................................................................... 12 \nInterface Changes .................................................................................................................................... 13  \nPhysical Access ....................................................................................................................................... 13 \nUnscheduled Reboots .............................................................................................................................. 13 \nSoftware Management ............................................................................................................................ 14 \nBlocked Attempts.................................................................................................................................... 15 \nDowngraded Encryption ......................................................................................................................... 15 \nNetwork Traffic Analysis ....................................................................................................................... 16 \nNetwork Device Integrity (NDI) - Software Modification Detection ......................................................... 17 \nFile Verification ...................................................................................................................................... 17 \nOnline Hash ........................................................................................................................................ 17 \nOffline Hash ........................................................................................................................................ 18 \nPublished Hash (Known Good) .......................................................................................................... 18 \nHash Comparison ................................................................................................................................ 19 \nSelf-Verification ................................................................................................................................. 22 \nHigher Confidence Levels .................................................................................................................. 22 \nMemory Verification .............................................................................................................................. 23 \nFirmware Verification ............................................................................................................................. 24 \nRootkit Detection .................................................................................................................................... 25 \nNetwork Device Integrity (NDI) - Hardware Modification Detection ....................................................... 26 \nUnique Identifiers ................................................................................................................................... 26 \nOperating Statistics ................................................................................................................................. 27 \n\n3 Network Traffic Analysis ....................................................................................................................... 27 \nNetwork Device Integrity (NDI) - Worksheets ........................................................................................... 28 \nSystem Information Worksheet .............................................................................................................. 30 \nUnauthorized Access Detection Worksheet ............................................................................................ 32 \nFile / Memory / Firmware Verification Worksheet ................................................................................ 34 \nReferences ...................................................................................................................................................  35 \n \n  \n\n4 Network Device Integrity (NDI) Methodology \nIntroduction  \nComputer networks are complicated systems of interconnected devices of different technologies, to \ninclude workstations, servers, network devices and peripherals. Network devices are the systems that \ntransport data between other systems on the network, which generally includes routers, switches, firewalls \nand various other types of technologies. Even though network devices generally do not store or process \ninformation, the compromise of these systems could allow an adversary or a malicious insider to gain \nunauthorized access to the information that is stored, processed or transmitted by other systems on the \nnetwork, violating confidentiality. That same information could also be modified, corrupted or destroyed, \nviolating integrity or impacting availability. Depending on the operational requirements for the network, \nany such violations could have a severe impact to the mission that the network supports. \nHow do I know if my network device has been compromised? \nIt is critical for network administrators to verify the integrity of all systems attached to a network to \nobtain a reasonable level of confidence that a compromise has not occurred, affirming that confidentiality, \nintegrity and availability of the information on the network has not been violate d. The Network Device \nIntegrity (NDI) methodology is a process to verify the integrity of systems on an operational network, \nspecifically network devices, such as routers, switches and firewalls. Any discrepancy discovered during \nthe verification process could be an indication of a compromise. \nUnlike other types of common systems, the operating system of a network device or an embedded system \nmay not provide the flexibility or interface to validate critical aspects of the system, such as the hardware, \noperating system files or the contents of memory. This methodology is designed to be system independent \nand can be adjusted as needed, depending on the type of system that is being verified. Some systems may \nnot support all of the necessary functionality and thus a higher level of confidence can only be obtained \nby using more intrusive methods. To adequately detect a compromise, it is first necessary to understand \nthe different methods an adversary can use to successfully compromise a network device. \nUnauthorized Access \nThe most common compromise of a network device is when an unauthorized individual gains user or \nprivileged level access through an administrative interface. This could be achieved via direct physical \naccess to the network device or via a remote network administration service such as Secure Shell (SSH), \nTelnet, Hyper-Text Transfer Protocol (HTTP) or Simple Network Management Protocol (SNMP). \nUnauthorized access can be achieved by stealing legitimate administrator credentials (username, \npassword, two-factor authentication token), obtaining credentials that are improperly protected by \nadministrators (e-mailing configurations, storing clear-text passwords in a document ), or compromising a \ncentralized authentication server (TACACS+, RADIUS, LDAP) and adding or modifying accesses. \nUnauthorized access can also be achieved when a network device is poorly configured and authentication \nmechanisms are insufficient or can be easily bypassed, such as weak credentials that can be guessed or \ncracked via brute-force methods, or when publicly known default credentials are left unchanged. It is also \n\n5 common for network administrators to overlook upgrading the software on network devices, allowing \nunauthorized access to also be achieved through the exploitation of software vulnerabilities in unpatched \nor outdated software.  \nIt should always be assumed that unauthorized access can be obtained with physical access since most \nnetwork devices have a mechanism to perform a password reset or similar function. A reboot of a network \ndevice is generally required for the password to be cleared or to reset the configuration to a default state. \nA terminal server can be used to remotely access the console port of network devices and should always \nbe treated the same as physical access. \nOnce unauthorized access to a network device is obtained, an adversary can view or modify configuration \nsettings, elevate privileges to gain additional accesses, perform software modifications, or utilize the \nsystem to bypass existing access restrictions to compromise other systems on the network where critical \ninformation resides. \nDetecting unauthorized access to a system can be difficult, especially when an adversary utilizes stolen \nadministrator credentials. An adversary may login to a network device from a compromised administrator \nworkstation using the credentials of the same administrator that generally uses that workstation to manage \nthe network devices. In this case, it is extremely difficult to distinguish between legitimate and \nunauthorized accesses, especially on the device itself. Unauthorized access is better detected by \nexamining and correlating syslog messages, Authentication, Authorization and Accounting (AAA) logs, \nSNMP trap logs, administrator workstation logs, and any other available log messages. Any abnormal \nactivities could be an indication of unauthorized access. \nSeveral types of compromises, including those described below, can only be achieved by powering off a \nnetwork device or rebooting it. When the proper logging and networking monitoring functions are \nenabled on the network, it should be reasonably simple to detect when a network device has been \nrebooted outside of normal network operations. All log messages should be stored on remote log servers \nto prevent an adversary from clearing the logs, which would require the adversary to also compromise the \nlog servers to hide any malicious actions performed. \nSoftware Modification \nA more complicated compromise of a network device is the modification or replacement of the software \nrunning on the network device. This could be a modification to the operating system files stored on the \ndevice, or a modification to the operating system code residing and executing in memory. Another similar \ntype of compromise is the modification or replacement of the software that boots the device and initially \nloads the operating system, such as the device's firmware, boot loader, or basic input/output system \n(BIOS), which is generally stored on a separate read-only memory (ROM) chip located on the device's \nmotherboard. Some devices may allow the boot software on the ROM to be accessed, modified or \nupgraded via the operating system after the device boots, while others may require a reboot into a separate \nmode where the ROM can be accessed. \nUnauthorized access is generally a requirement for an adversary to perform a software modification of a \nnetwork device. Once access is obtained, the adversary can overwrite the operating system files stored on \nthe device or residing in memory. Many network devices may require a reboot for a software \n\n6 modification to take effect when stored files are changed, while a modification of code in memory should \nbe immediately applied without a reboot. \nModifying the software of a network device is generally not a trivial task. It requires understanding the \nhardware and architecture of the particular network device, which generally differs from common desktop \ncomputers. This may require reverse engineering the existing software to determine how the software can \nbe modified in a way that is useful for the adversary. Aside from the difficulty, there are several publicly \nknown cases1 2 3 4 where an adversary has successfully modified the operating system files stored on \nnetwork devices for malicious purposes. \nFortunately, the detection of a software modification on a network device can be achieved by comparing \nthe software currently stored on the system or running in memory with a known good, assuming all of the \nnecessary information is accessible or can be acquired. Many enterprise network device vendors provide \nknown goods via their publicly available websites either via a software download or by publishing \ncryptographic hashes of the operating system files. \nTo perform the comparison, the software on the network device needs to be cryptographic hashed or \ndownloaded and compared with the known good. A software modification can be detected as long as the \nfunctionality to retrieve this information from the network device is available and a trusted known good \nexists. When a known good does not exist or is not available from the vendor, a large sample of the same \ninformation from different systems may be sufficient to provide a reasonable level of confidence, or it can \nbe used to establish an internal repository of known goods. Regardless, a known good provided by the \nvendor should always be the most trusted source. \nHardware Modification \nAnother more complicated compromise of a network device is the modification or replacement of the \nhardware. Additional hardware could be added to the device, such as a wireless radio, to grant an \nadversary out-of-band access for command and control, or an inline tap to exfiltrate sensitive information \nfrom an internal area of the network through a backdoor connection . Individual counterfeit components \ncould also be produced, or an entire device could be manufactured to masquerade as a legitimate device \nand sold strictly for monetary gain. Recycled parts could be introduced in counterfeit equipment that \ncould be less reliable. Even though the operational function of counterfeit devices may appear to be the \nsame as legitimate devices, they are generally less reliable and vendors may decline to provide assistance \nif a counterfeit system is discovered during a support call. \nA hardware modification, replacement or addition will always require the adversary to have physical \naccess to the network device. It is generally easier to perform hardware modifications through the supply \nchain before the device is delivered to the intended location. Otherwise additional hardware could be \nadded to the device after it has been installed and may or may not require the device to be powered off, \ndepending on the modification. \nHardware modifications can range from an individual integrated circuit (IC) on a peripheral to an  entire \ndevice. Because there are numerous avenues for an adversary to modify a piece of hardware, it can be \nextremely difficult to detect a hardware modification. This process is highly system dependent because \nevery type of system can be uniquely different. \n\n7 Prevention  \nIt is prudent to describe several basic mitigation concepts to prevent the different types of compromises \ndescribed above before they even happen. Designing enterprise networks or securing all of the network \ndevices5 and other systems on enterprise networks can be a significantly complicated task. The items in \nthe list provided below are a few high level concepts that should be followed to assist with preventing \ncompromises of network devices. \n Ensure physical access to network devices is properly restricted and some form of accountability \nexists to track who has physically accessed the systems. An adversary with physical access to a \nnetwork device, even for a limited amount of time, could result in any of the compromises \ndescribed above. Utilize a network access control (NAC) solution to prevent unauthorized \nsystems from connecting to the network. \n Follow industry best practices for securing, managing and restricting remote access to network \ndevices. Implement the concept of least privilege to ensure privileged level access requires \nadditional authentication and is only used when it is required to restrict an adversary from \nelevating privileges from a compromised user account. Ensure accountability exists for all \nindividuals that login to systems. Utilizing two-factor authentication can significantly decrease \nthe ability for an adversary to steal or obtain legitimate credentials from an administrator. Do not \nstore or transmit unprotected sensitive configuration information, including passwords and keys. \nUtilize encrypted protocols for remote administration and storage of sensitive information. \n Follow defense- in-depth when designing, building and re-configuring a network. Different areas \nof the network should be properly segregated and all administrative functions should occur on a \nseparate management network not directly accessible from the operational network. The \ncompromise of user workstations should not easily lead to the compromise of administrator \nworkstations. \n Implement sufficient logging and establish policies and procedures to review the logs to ensure an \nunauthorized action is promptly detected and investigated. It is significantly easier to prevent \nadditional compromises into the network when initial attempts are detected and handled. \n Verify the integrity of all software when upgrading or installing the software on a network device, \nand periodically verify the software running on the device to ensure it has not been tampered \nsince the last upgrade. The integrity of all software should be verified by performing a \ncryptographic hash check on the files prior to copying them and after they have been copied to \nthe network device to ensure an adversary has not influenced the software upgrade process. \n Purchase network devices through vendor approved distribution channels. Counterfeit or recycled \nequipment is generally sold for cheaper than approved resellers to entice buyers to purchase from \ntheir inventory. The higher cost and reasonable level of confidence achieved by purchasing a \nlegitimate network device from an approved vendor can easily outweigh the additional costs of \ndetecting and mitigating issues with acquiring a counterfeit piece of equipment. \n\n8 Remediation \nThere are numerous procedures documented for remediating a compromised workstation or a security \nincident6. In most cases, a workstation can be easily removed from the network, wiped clean, rebuilt and \nreplaced without significant impact. Unfortunately, this is generally not true for network devices. \nRemoving a core router or another critical network device that is not load-balanced or redundant could \nhave a significant impact on the availability of the network. Even removing a single switch from the edge \nof the network could disable network connectivity for a significant number of users. \nMy network device is compromised! What do I do? \nThere are several resources available that can provide additional guidance for remediating a compromised \nnetwork device or embedded system7 8. After detecting the existence of a successful compromise of a \nnetwork device using any of the methods previously described, several steps can be followed to remediate \nthe situation, but what should actually be done will depend on the operational requirements associated \nwith the network. In some situations, it may not be acceptable to disable a portion of the network even to \nremediate a compromised network device. \nContainment \nThe first step is to contain the compromise and ensure the adversary is unable to compromise other \nsystems on the network. It is useless to remediate a single network device if the adversary has already \nbeen able to compromise other systems on the network. Discovering what other systems an adversary \nmay have accessed may not be immediately available so it is also critical to perverse any forensic \nevidence, such as log messages, to investigate what other actions may have been performed by the \nadversary. Additional detection efforts may be required to determine if the adversary has accessed other \nnetwork devices, workstations or servers throughout the network. It may be necessary to initially change \nsome passwords and keys to contain the adversary if legitimate credentials were utilized. \nTo ensure containment of the adversary, it may be necessary to disconnect any external connections to \nother networks, including the Internet, partner networks, remote access or wireless connectivity. Even \nthough the path used by the adversary may be obvious, it may be possible for the adversary to regain \nconnectivity to the compromised system through another external connection, such as a wireless or \ncellular bridge. Investigating additional connections is necessary when a potential hardware compromise \nis detected or a wireless out-of-band connection exists. \nForensic Evidence \nAfter the adversary is reasonably contained, forensic evidence should be obtained from the compromised \nsystem and any other systems that may have been accessible to the adversary. This includes any log \nmessages or system status information that would be lost once the system is shut down. The following list \ncan be used as an example of some items that should be obtained from a compromised system, but this \nlist may not be complete. \n Current system clock for accurate log correlation. \n Current or previously logged in users. \n\n9  Network interface status and usage statistics. \n Established network connections. \n Neighboring devices. \n Routing tables and neighbors. \n Process listing.  \n Memory usage.  \n Status of authentication and time servers. \n Port security statistics. \n Access list statistics. \nThe compromised system can be disabled or shutdown and removed from the network after all forensic \nevidence has been obtained. If possible, it may be reasonable to leave the system powered on but \ncompletely disconnected from the network so additional forensic analysis can be performed on the \nsystem. This assumes there is not a hardware modification that would introduce adverse effects into the \nenvironment. \nBe extremely cautious with replacing a compromised system with another system with a similar \nconfiguration as the compromised system. This may be desired to ensure network availability is restored \nwithout introducing unexpected changes into the network, but the adversary may be able to compromise \nthe replacement system in the same manner if the original attack vector is not discovered and mitigated. \nDiscovery and Mitigation \nBefore restoring the network to an operational state, it is absolutely necessary to discover and mitigate the \nattack vector used by the adversary to compromise the network. If the vulnerability is not mitigated, it is \nlikely the adversary will successfully compromise the same system or other systems in the network \nutilizing the same attack method. This may be an involved process of reviewing log messages and the \nforensic evidence obtained above to discover the vulnerability exploited by the adversary. It is important \nto note that the vulnerability may not be a technical issue (such as phishing), though it may be mitigated \nthrough technical controls that have not yet been implemented (such as e-mail scanning and quarantine). \nIt may be necessary to request or hire the assistance of more technically capable expertise to determine \nthe cause of the compromise. Once the vulnerabilities are discovered, if more than one, they should be \nappropriately mitigated to ensure the adversary is unable to regain access to the network. It may also be \nnecessary to perform a thorough vulnerability assessment of all systems on the network along with a \nmitigation implementation phase to reduce the vulnerabilities to an acceptable level prior to restoring the \nnetwork to an operational state. \nChange Passwords and Ke ys \nIf a network device has been compromised, either through unauthorized access, a software modification \nor even a hardware modification, it is likely that the adversary was able to obtain sensitive configuration \ninformation to include passwords or keys. After the adversary has been contained and all known \ncompromised systems have been removed from the network, all credentials should be changed. \n\n10 This includes local account passwords, centralized account passwords, centralized authentication keys, \nrouting authentication keys, time synchronization keys, encryption and tunneling credentials (such as \nVirtual Private Networks), and any other passwords or shared keys that may be utilized by the network \ndevice. It may also be necessary to change administrator and user credentials on workstations and servers \nif the adversary was able to gain access to any of those systems as well. It may also be necessary to \nchange passwords and keys more than once during the entire remediation process to ensure the adversary \ndoes not have any operational credentials when the network is fully restored. \nWhen possible, it is preferred to utilize an out-of-band mechanism for changing passwords so the new \npasswords are not instantly captured by any lingering malware installed on systems. It is critical to follow \nbest practice guidance for changing passwords, so the adversary cannot guess or infer the new passwords \nbased on knowledge of the old passwords. \nRestoration \nOnce all of the associated vulnerabilities have been mitigated and all known compromised systems have \nbeen removed from the network, it may be time to restore the network to an operational state. This may \nrequire installing replacement hardware or reconfiguring systems. Prior to re-establishing any connections \nthat were disabled, it is crucial to ensure the proper logging and monitoring capabilities are implemented \non the network to ensure any new compromises are immediately detected, investigated and responded to \nin a timely manner.  \n  \n\n11 Network Device Integrity (NDI) - \nUnauthorized Access Detection \nUnauthorized access via stolen credentials may be a common method used by an adversary to \ncompromise a network device, but may be difficult to detect. There is no clear mechanism to distinguish \nunauthorized access from authorized access when legitimate credentials are used. Normal administrator \nbehaviors must be captured and correlated so that abnormal activities can be detected and investigated. \nMost of the information necessary to perform this investigation may not be stored on the network device \nitself, and must be obtained from centralized log servers. \nAdministrators usually follow the same patterns in how they perform their administrative duties. This \nmay include when they login, where they login from and how long sessions remain open. It is highly \ncommon to see the same administrative activities or behaviors repeated across the network. Any \ninconsistent activities or behaviors that seem out of the ordinary may be potential indicators of \nunauthorized access on a network device and should be investigated. \nUnfortunately, there is not a standard process for correlating all of this information, and it will depend on \nhow the network is configured and how systems are accessed. It is critical to understand normal \nadministrator behaviors before abnormal activities can be detected. Several areas that can be investigated \nare described below. \nLogin Access  \nA primary area to investigate concerning unauthorized access is a list of accounts that have logged into a \nnetwork device. If remote syslog logging or SNMP trap logging is properly enabled, this information may \nbe available on a remote log server. If a centralized authentication server is utilized by the network \ndevices and accounting is properly enabled, this information may also be better obtained from the \nAuthentication, Authorization and Accounting (AAA) servers. It is critical to log when the access \noccurred, the source address and how long the session lasted. \nMost employees, including administrators, have a consistent daily work schedule. This knowledge can be \nused to establish a timeframe when an administrator is expected to login to the network devices and how \nlong the sessions should normally last. Any deviation outside of the normal behavior can be an indication \nof unauthorized access where the administrator's account credentials have been compromised. \nMany administrators are also assigned a unique workstation, or a set of workstations, for performing \nadministrative tasks. The source address of any connections to the network devices should generally be \nthe same for each for administrator. This may depend on how the network is configured and what access \nrestrictions are implemented. The source address may not be useful if all administrators first login to a \ncentralized jump box to access the network devices. In this case, it may be necessary to obtain the access \nlogs from the jump box in addition to the access logs from the network devices or centralized servers . \nAny account that is utilized from a different source address could be an indication of unauthorized access. \n\n12 Configuration Changes  \nThe configuration of a network device generally does not change very often once the configuration is in a \nstable working state. A change may occur when there is a problem with the network or authorized \nmodifications need to be implemented. It is critical to monitor for any activities which involve modifying \nthe configuration or any actions which would be considered high risk activities. Even though many of \nthese actions can be legitimately used by administrators, they should be monitored to ensure they are \ninitiated with the proper authorization. Some examples of high risk activities are listed below. \n Modification of access restrictions. \n Modification of authentication or authorization mechanisms. \n Modification of logging procedures. \n Modification of the boot process. \n Creation of new VLANs, tunnels, virtual interfaces or connections. \n Creation of new accounts. \n Configuration changes through non-standard methods (such as SNMP or console access ). \n Outbound connections from a network device. \n Copying files to or from a network device. \n Clearing of log messages. \n Filling up the log buffer. \n Unscheduled reboots. \n Interface changes. \n Enabling debugging modes. \n Enabling shell access. \n Executing scripts. \n Starting new processes. \n Console port access. \n Connection or removal of external storage devices (such as USB). \nWhenever a change is made to the configuration of a network device, it is critical for each device to log \nwhat administrator account made the change, when the change was made, and possibly what the exact \nchange was. This information can be crucial for detecting unauthorized changes to the configuration. \nSophisticated adversaries may attempt to cover their tracks by clearing any log messages that were \ngenerated in connection with malicious activities. Without logs, it is difficult for network administrators \nto determine what may have happened after an event. If the logs on a network device or on the centralized \nlog server have been cleared, removed or deleted, this is an instant indication that unauthorized access \nmay have occurred. \nMany network devices have a buffer to store some of the logs locally, even when they are sent to a remote \nlog server. The adversary may attempt to overwrite the log buffer or generate additional log messages \nuntil the buffer fills up and rolls over, or clear the buffer by simply rebooting the device. Any of these \nactions could be an indication of unauthorized access. \n\n13 Interface Changes  \nA malicious insider or an adversary that obtains physical access may connect an unauthorized system to \nthe network to attempt to bypass security restrictions implemented on the existing workstations. Network \ndevices, and especially switches, have multiple interface ports where physical network connections can be \nestablished. Whenever a system is connected or disconnected from an interface port on a network device, \na notification is generally produced indicating that the status of the interface has changed to either up or \ndown. These notifications can be useful to detect the existence of unauthorized systems on the network. \nWhen possible, it is also critical to determine the media access control (MAC) address of any connected \nsystems to determine if a newly connected system is unauthorized, or if an authorized system has simply \nbeen moved to a different port. A complete inventory of current equipment can assist with discovering \nunauthorized systems connected to the network. A network access control (NAC) solution, like 802.1X or \neven something as basic as port-security, can assist with discovering and blocking unauthorized systems \nconnected to the network. \nPhysical Access \nThe logs on a network device should also be examined to determine if there were any attempts made to \nconnect via the console port, which is usually just a basic serial connection. Physical access to a network \ndevice is generally required to connect to the console port. A terminal server can also be used to remotely \naccess the console port of network devices. Most administrators do not utilize the console port when \nremote administration services are properly configured, and may only be used when the device cannot be \naccessed over the network. Any attempts to access the network device via the console port could be an \nindication of unauthorized access. \nMany network devices also have a mechanism to configure how the device boots, through the device's \nfirmware, boot loader, or basic input/output system (BIOS). There may be various settings that can be \nchanged to influence the boot process, such as bypassing security mechanisms, ignoring the stored \nconfiguration or allowing the password to be reset. These settings are usually configured the same for all \ndevices on the same network, and thus a device that has a different boot setting may be an indication of \nunauthorized access, or an attempt to physically access the device via the console port. \nUnscheduled Reboots \nMany network devices must be rebooted to upgrade the operating system or even when applying some \nconfiguration changes. These actions are usually scheduled by administrators to reduce the loss of \navailability of network connectivity. An unscheduled reboot of a network device can easily be an \nindication of unauthorized access or another potential problem. An unscheduled reboot is best discovered \nby reviewing the logs and system information or through network monitoring tools.  \nNetwork devices can be legitimately rebooted, due to specific administrator actions or upgrading the \noperating system. Whenever investigating a reboot of a network device, it is critical to check any logs or \nstatus messages to determine the cause for the reboot. A device that was powered on from a cold restart \ncould have been accessed physically where a password reset was performed. A device that crashed and \n\n14 was automatically restarted could have been due to an attempt to exploit a vulnerability or software flaw, \nsuch as a buffer overflow. A device could have been rebooted by an adversary to clear the logs or to boot \ninto a modified version of the operating system. \nMany network devices must be rebooted when upgrading the operating system. If the network device \nloads all of the operating code into memory during the boot process, any changes made to the operating \nsystem files stored on the network device will not be applied until the device is rebooted. Thus an \nadversary may have to force a device to reboot for any unauthorized software modifications to be applied.  \nIt is important to determine how much time has passed since the last time the device was rebooted, and \nthe reason for the last reboot. The longer a device has been up, the longer it has been since the stored files \nhave been loaded into memory. Large up times (tens of weeks, or even years) generally point to several \npoor administrator practices. The software on a device that has not been rebooted in a long time has also \nnot been legitimately upgraded in at least that same amount of time. \nRebooting a device periodically will ensure that the executable code running memory matches the stored \noperating system files, clearing out any potential memory-only implants. It is a good practice for network \nadministrators to always verify the stored operating system files prior to rebooting a network device to \nensure that the files are legitimate. It also confirms that the file storage mechanism is working. It is \npossible for the flash or hard drive storing the operating system files to fail or become disconnected, \npreventing the device from properly booting. It is critical for an administrator to discover such an issue \nprior to a reboot. \nSoftware Management \nMany network devices may only store one version of the operating system at a time, but others may be \ncapable of storing more than one version simultaneously. If multiple versions of the operating system \nexist, the device may have been recently upgraded or network administrators may have failed to remove \nolder versions after they were no longer needed. It could also be an indication of an attempted software \nmodification. It is critical to verify all operating system files stored on a device, regardless if they are in \nuse or not, to ensure a modified version of the operating system is not loaded on the next reboot. \nIt is also critical to verify what version of the operating system will load after the next reboot. If it is \ndifferent than the current running version, it is possible the device was legitimately upgraded but the \nadministrators were waiting for a scheduled time to reboot the network device. If the current running \nversion of the operating system is no longer stored on the network device, it may have been removed \nprior to an upgrade because there was not enough space to store two different versions of the operating \nsystem. Any changes to the operating system image files and differences between the running and boot \nversions of the operating system could be an indication of a potential software modification and the \nadversary was waiting for a more favorable time to reboot the network device to reduce the probability of \ndetection. \nAnother indicator to review when examining a network device is the operating system file timestamps. \nUnfortunately, the timestamps on a network device may not be accurate, especially if the clock is not \nproperly synchronized with a centralized time server, or if the server was not available when the clock \nwas set and operating system files were copied to the network device. Even though file timestamps may \n\n15 not be reliable, they could still be used when correlating information and looking for anomalies to \ndiscover any potential unauthorized changes to the files. \nBlocked Attempts \nIn addition to reviewing successful configuration changes, any actions that were blocked or denied by a \nnetwork device could be an indication of an adversary attempting to gain unauthorized access, or an \nadversary that has already gained unauthorized access and is attempting to perform additional maliciou s \nactivities. It is critical to investigate any actions that were blocked or denied, as this can lead to the \ndiscovery of a successful compromise or indicate the source of a potential adversary. The account utilized \nand the source address will be critical for detecting other attempts to gain unauthorized access. Some \nexamples of blocked activities are listed below. \n Blocked inbound connections. \n Blocked outbound connections. \n Failed authentication (login) attempts, and locked out accounts. \n Failed authorization (action or command) attempts due to insufficient access. \n Denied connections due to insufficient (weak) encryption parameters. \nDowngraded Encryption \nAdministrators are highly encouraged to utilize encrypted protocols for administrative tasks to ensure the \nconfidentiality of sensitive configuration information and administrative credentials when accessing \nsystems on the network. An adversary that is capable of collecting network traffic should not be able to \neasily retrieve this information by simply examining the traffic. Encryption is also utilized for Virtual \nPrivate Network (VPN) connections to provide confidentiality and protect communications between \ntrusted sites. \nAn adversary that desires to collect the contents of encrypted communications may attempt to influence \nthe connection negotiation process to force the protocol to utilize weaker protocols or keys that are more \neasily cracked. Most encrypted protocols begin with some form of unencrypted negotiation that can \npotentially be influenced by an adversary capable of modifying the traffic without violating the integrity \nof the client or server verification. \nFor example, an SSH server will immediately provide a connected client with the versions of the protocol \nthat the server is capable of accepting. The client will respond with the versions it is capable of using, and \nthe server will provide the encryption parameters that it can support. The client will choose from the \nsupported encryption parameters and continue establishing the encrypted connection. If both the client \nand server are capable of accepting both SSH version 1 and 2, an adversary could modify the initial \nhandshake to force both the client and server to negotiate using the weaker version 1 instead of the more \nsecure version 2, or modify the available encryption parameters so the client can only choose from \nweaker parameters that are easier for the adversary to crack. Both the client and server will mutually \nagree on the weaker encryption parameters unless they are configured to only utilize higher versions of \nthe protocol with strong encryption parameters. \n\n16 The parameters utilized by encrypted protocols should be logged and reviewed to ensure that only the \nstronger encryption parameters are accepted by both ends of the communication. Any client attempting to \nconnect that cannot support the stronger encryption parameters should be denied and the client software \nshould be upgraded. Any attempt to utilize weaker encryption parameters could be an indication that an \nadversary is attempting to downgrade the encryption to enable information gathering to violate \nconfidentiality, or an attempt to gain unauthorized access by bypassing existing authentication \nmechanisms. \nNetwork Traffic Analysis \nIf a network device is compromised, the adversary may disable all of the monitoring capabilities and \nprevent insight into any malicious activities performed. Similarly, access logs may not be available from \nthe network devices if logging has been not properly configured. Another useful method for detecting \nunauthorized access is to monitor network traffic. \nA significant amount of information can be obtained by examining network traffic, to include source and \ndestination addresses, the date and time of the activity, the amount of data transferred, and the duration of \nthe activity. The existence of any remote access connections to a network device, authorized or \nunauthorized, should be visible on the network even when the communications are encrypted. Several \ntypes of anomalous behaviors that can be discovered in network traffic are listed below. \n Connections to a network device from an unexpected source address. \n Outbound connections with a source address assigned to a network device. Most network devices \ndo not establish outbound connections to other systems unless initiated by an administrator \nlogged into the device. \n Malformed packets or non-administrative traffic to or from a network device. \n Encryption parameters during initial connection handshakes and negotiations. \n Inbound connections that unexpectedly terminate at the network device, and potentially coincide \nwith other outbound connections. Legitimate traffic may exist with this behavior if the network \ndevice is an endpoint for a Virtual Private Network (VPN), Generic Encapsulated Routing (GRE) \ntunnel, or provides proxy services. \nThe above behaviors are generally vendor independent and can be detected by examining network traffic \nregardless of the type of the system under investigation. \n  \n\n17 Network Device Integrity (NDI) - \nSoftware Modification Detection \nThe integrity of the software on a network device can be verified by determining whether or not any \ncritical files or operating system code has been modified and is different from the original file that was \nprovided by the vendor. This can be achieved by performing a ha sh-based verification of files stored on \nthe network device and verifying the executable code running in memory by comparing it to legitimate \noperating system files or a known good copy of what is expected to be in memory. \nIt is critical to verify the executable code running in memory and not just the stored files because many \nnetwork devices load the stored operating system files into memory when the device is first booted. The \nstored files are no longer necessary for the network device to continue operating after it boots. Since \nmany network device are left operating for long periods of time without a reboot, potentially years, an \nadversary could modify the executable code running memory and there would be no indication of \ntampering if only the stored files were verified. \nFile Verification9 \nTo verify an individual file, a cryptographic hash is computed based on the contents of a file and \ncompared with a known good value. Any discrepancy with the comparison is an indication that the file \nhas been modified, while an exact match provides a certain level of confidence that the file has not been \nmodified. The process for computing these hashes is more complicated for network devices than other \nsystems since there may not be a trusted method for computing the hashes or accessing the files, and thus \nmultiple hashes must be obtained to achieve a higher level of confidence. \nSome network devices may store the entire operating system in a single image file, while other network \ndevices may have hundreds or thousands of executable files similar to common desktop and server \noperating systems. To fully verify the integrity of the operating system of a network device, it will be \nnecessary to repeat this process for every file stored on the device that contains executable code. Even \nthough file verification generally cannot be performed on configuration or text based files since they can \nchange depending on how the system is configured, this process can be potentially used to detect \nconfiguration changes over time. \nOnline Hash \nThe online hash is computed by remotely logging into the network device and using the built-in \nfunctionality of the network device's operating system to compute the hash of the file. This piece of \ninformation is generally easy to acquire because it only requires remote network connectivity to the \ndevice and the proper access to login to the device and execute a series of commands. Any discrepancies \nbetween the online hash and a known good are an instant indication that the file has been modified. \nUnfortunately, the online hash cannot always be trusted. If malicious modifications have been made to the \noperating system files, the adversary could have modified the hash computation functions to provide \nbogus information, which could be the correct hash for the unmodified version of a file, ultimately hiding \nthe fact that the file has been modified. \n\n18 Depending on the system and the vendor, there may be multiple methods available to compute and obtain \nan online hash. Since an adversary may attempt to hide an unauthorized presence by modifying the hash \ncomputation functions, it is recommended to utilize all methods of computing an online hash when \nadditional methods exist. When available, different types of hashes should also be obtained (MD5, SHA1, \nSHA256, SHA512) to provide a higher level of confidence, since some common hash functions are \nknown to have potential collisions. \nOffline Hash \nInstead of only relying on the operating system of the network device to compute the hash, the entire file \nshould be copied from the device to a trusted system where the hash is computed. Copying files is \nsignificantly more complicated to perform over the network because it requires sufficient bandwidth, the \ncapability to copy files, the proper access to copy files, the network must be configured to permit \nconnections from the network device to the trusted system (a return route with no firewalls or access lists \nblocking the traffic), and the trusted system must be listening with the appropriate services to accept \nincoming files. The use of Network Address Translation (NAT) will also cause significant problems for \nreturn traffic. Regardless of the potential difficulty to acquire the file, the offline hash provides \nsignificantly greater confidence than the online hash because it is difficult for an adversary to influence. \nWhen properly obtained, the offline hash is considered more trustworthy than the online hash. Similar to \nthe problems with the online hash, an adversary could potentially modify the copy functions used by the \noperating system to provide the original unmodified file. A significant amount of sophistication is \nrequired to modify the operating system in this way, and may require an entire copy of the original file to \nalso be stored on the system in addition to the modified file. Files can also be corrupted, intercepted or \nmodified during transmission back to the trusted system, and can produce false positive results, \ndepending on the protocols used. The offline file can be obtained multiple times using different transfer \nmethods to increase the level of confidence, though this can be an extremely time consuming process. \nInstead of copying files over the network, an even more trusted method of acquiring the offline hash is to \nobtain the file via physical access to the device. Some network devices store files on removable media \nsuch as flash cards or optical discs. This may require shutting down the device, opening the case,  or \nrebooting the device in a limited access mode, which may not be feasible for operational networks. \nPublished Hash (Known Good) \nThe published hash is the known good hash that the online and offline hashes are compared to . This \ninformation generally must be obtained by the vendor of the network device or operating system. When \navailable, additional information about the file should also be obtained, such as the file name, file size, \noperating system version, release date, device requirements, and any other potentially relevant \ninformation. When available, multiple hashes should also be obtained (MD5, SHA1, SHA256, SHA512). \nSome vendors freely provide this information via their website, while others may require an account, and \nyet others may not have a method to provide this information to their customers. \nIf the published hash is not available from the vendor but a legitimate copy of the original file can be \nobtained via a process to download software from the vendor, the published hash can be manually \ncomputed on that copy of the file . A legitimate copy of the original file would also be necessary to \n\n19 perform a byte-for-byte comparison of the file to increase the level of confidence if comparing hashes is \nnot considered a sufficient method for verifying the integrity. \nRegardless of how it is obtained, the published hash must be a trusted piece of information. To properly \ndiscover a file modification, it is critical to compare the online and offline hashes with the published hash. \nThe online and offline hashes cannot simply be compared to each other. When a file has been modified \nfrom the original, it is expected that the online and offline hashes should match exactly, but they would \nnot match the trusted published hash, which is why the published hash is so critical to this process. \nIt is also possible for a single file to have multiple published hashes, and all of them may be valid for \nverification purposes. If the file has been legitimately updated by the vendor, it will have a different hash, \nand possibly a different file size. This is why additional information about the file should also be obtained \nfrom the vendor. \nHash Comparison \nAll three types of hashes should be compared for equality after th ey have been properly obtained. If all of \nthe hashes could not be obtained, or the hashes were not equal, the cause of the issue should be \ndetermined. The fact that a hash could not be obtained through expected means could be an indication of \na malicious software modification. Providing a reasonable explanation for the lack of information can \nensure the results are as complete as possible and will assist with the analysis of the data and reduce the \nnumber of false positives. Several common scenarios are described below. \nIf the online hash  could not be obtained, the network device itself may not support the functionality to \ncompute the hash of the file. The lack of an online hash is not a severe concern since the offline hash is \nmore trustworthy than the online hash, assuming the offline hash is successfully obtained. A missing \nonline hash can be easily detected by examining of the output of any attempts to obtain the online hash. It \nis possible this may be an indication of a malicious modification of the operating system, though not as \nlikely if the offline hash properly matches the published hash. Several potential reasons for missing an \nonline hash are summarized below. \n The necessary accesses or permissions were not obtained on the network device. \n The network device did not support an online hashing functionality. \n A software bug in the network device operating system report ed that the file did not exist. \n A malicious software modification prevented a file from being hashed online. \nIf the offline hash  could not be obtained, it is likely something prevented the file from being copied off of \nthe device. A firewall or router may have blocked the connection, or the trusted system may not have \nbeen properly configured to accept the incoming files. Again, it is possible this may also be an indication \nof a malicious modification of the operating system, and would be the result of a sophisticated adversary. \nSeveral potential reasons for missing an offline hash are summarized below. \n The necessary accesses or permissions were not obtained on the network device. \n A firewall or router blocked the connection from the network device to the trusted system. \n The network device was configured to prevent outbound connections. \n The credentials provided to copy the file were invalid on the trusted system. \n\n20  The network device did not support encrypted protocols. \n The copy process was not configured to attempt to utilize more than one protocol. \n The trusted system was not properly configured to accept files via the supported protocols. \n A return route did not exist between the network device and trusted system, due to Network \nAddress Translation (NAT), Port Address Translation (PAT), or other routing issues. \n A software bug in the network device operating system reported that the file did not exist. \n The file was inaccessible due to a corrupted or disconnected file system. \n The file was corrupted during the transfer. \n The file transfer was incomplete. \n The file was stored in an unexpected or inaccessible location on the trusted system. \n The file system on the trusted system was full. \n A malicious software modification prevented the file from being copied offline. \nIf both the online hash  and the offline hash  were not obtained, it is likely that the file did not exist or \ncould not be accessed. Many times this is caused by not having the correct privilege level for accessing \nthe file or running the necessary commands on the device. In other cases, the file may have simply been \ndeleted. Some network devices will load the entire operating system files into memory, and the stored file \ncan be deleted once the operating system loads. This may happen when the network administrators have \nreplaced or upgraded the operating system files on the device, but have not yet been rebooted the device \nto load the new files. The file system may also have been corrupted or disconnected, preventing the file \nfrom being accessed. Several potential reasons for missing both the online hash and offline hash are \nsummarized below. \n The necessary accesses or permissions were not obtained on the network device. \n The file did not exist, was deleted or could not be accessed. \n The file was inaccessible due to a corrupted or disconnected file system. \n A malicious software modification prevented the file from being copied offline. \nIf the published hash  is unavailable, a determination cannot be made about the integrity of the file \nbecause there is no known good value to compare to. Some vendors do not provide known good hashes so \nthe necessary information is not available. And of course it is possible that the vendor did not create the \nfile at all and thus a published hash does not exist. It may be necessary to contact the vendor directly to \nattempt to obtain a legitimate copy of the original file to manually compute the published hash. Several \npotential reasons for missing the correct published hash are summarized below. \n A known good hash was not published by the vendor. \n A legitimate copy of the file could not be obtained from the vendor. \n The file was renamed and a published hash did not exist with the corresponding name. \n The file was renamed and the wrong published hash was utilized for the corresponding name. \n A malicious software modification prevented the file from having a published hash. \nIf both the published hash and a copy of the original file cannot be obtained from the vendor, the best \ncourse of action is to compare the hashes across similar systems that have the exact same file. The more \nfiles with the same hash, the more likely the file has not been modified, especially when looking across \nmultiple networks. This can be problematic if all files were cloned from the same source, such as a local \n\n21 repository that contained a modified version of the file. The integrity of the original source of a file \nshould be taken into account when using this method. This process does not provide a high level of \nconfidence, but may be the only method available. \nIt is also possible that a file was renamed by a network administrator prior to it being copied to the \nnetwork device. It may be necessary to verify the file name with the operating system version to ensure \nthat the name of the file is correct. Otherwise the wrong published hash may be used during the \ncomparison. And as previously noted, a file could be associated with multiple valid published hashes, so \nit may be necessary to compare more than hash before a valid match is discovered. \nFile corruption can occur during the transfer of the file, though this is not very likely when using reliable \nor encrypted transfer protocols. Some systems may behave differently when a file system becomes \ncorrupt, and invalid data is returned when copying the file instead of presenting an error. This could result \nin differing online and offline hashes. In these cases, the entire offline contents of the file should be \ncompared with a known good copy of the file to determine where the differences occur. \nFiles may be transferred to or from some systems using a serial console connection and the XMODEM \nprotocol. XMODEM always transfers data in blocks of 128 bytes. Any remaining bytes in the last block \nare padded with the hexadecimal character 0x1A to indicate the end of the file. Some systems may \nincorrectly store the entire last block of the file with the padding. Both the online and offline hashes will \nnot match the published hash because of the padded bytes at the end. If this behavior is discovered, the \noffline hash should be re-computed by removing all of the padded bytes at the end. If the file size was \nobtained from the vendor, it could be used ensure the file is truncated to the correct size. \nA file modification does not necessarily indicate that the file has been modified maliciously. The \nexistence of padding or corruption will result in properly detecting a file modification, but does not \nindicate that the system has been compromised. It these cases, it is absolutely necessary to obtain a known \ngood and trusted copy of the original file from the vendor. A byte-for-byte comparison should be \nperformed to determine how the files differ. Additionally, the modified file can be reverse engineered to \ninvestigate how the differences could cause the functionality of the operating system to behav e \ndifferently. It may also be necessary to perform the verification process described above multiple times to \nobtain a different data set to determine whether or not there was an error that occurred during the initial \nattempt. A file modification should be considered a malicious modification only after all other reasonable \nexplanations have been ruled out, or the file attributes are consistent with a previously known bad file \nmodification. \nThe following table provides a summary of some of the scenarios described above that could be \nencountered while performing software modification detection. The passing results include a relative \nlevel of confidence associated with the result. \n\n22 Hash Comparison Logic  Result  Possible Reason (s) \nonline == offline == published  PASS (High)  File has not been modified  \noffline == published; missing online  PASS (Medium)  Online hash not supported by device  \nInvalid accesses or permissions  \nPotential m alicious file modification  \nonline == published; missing offline  PASS (Low)  Network restrictions (firewall, ACLs)  \nConfiguration ( no outbound connections)  \nInvalid accesses or permissions  \nTrusted system incorrectly configured  \nPotential m alicious file modification  \nonline == offline; missing published  INCOMPLETE  Vendor did not provide hash  or file  \nFile was renamed  \nFile was not created by vendor  \nPotential m alicious file creation  \n(online == offline) != published  FAIL  File has been modified  \n(online == published) != offline  \nonline != published; missing offline  \noffline != published; missing online  FAIL  File or file system  corrupted  \nFile has been modified (malicious)  \n(offline == published) != online  FAIL  File has been modified (malicious)  \nmissing online and offline  INCOMPLETE  File does not exist  \nFile cannot be accessed , wrong permissions  \nFile system corrupt or disconnected  \n \nSelf-Verification \nSome network devices may include a system dependent or proprietary feature for internally verifying the \nintegrity of operating system files. This may be a pre-computed hash, checksum or cryptographic \nsignature that is stored in the file itself, or in some other location, that is treated as a known good. The \nnetwork device may internally verify a file before using it by re-calculating the hash or checksum, or by \ncryptographically verifying the signature. Since these verification mechanisms store the known good \nalong with the file, it may be easy for an adversary to replace the hash or checksum to match what is \ninternally computed. A cryptographic signature would be significantly harder for an adversary to \nsuccessfully modify without having the original private key, but it may be possible to replace the public \nkey used for verification if it is also stored on the network device. \nIf the vendor provides an internal feature to verify files, it should be used in addition to the file \nverification process described above to provide an overall higher level of confidence. Even though it may \nnot provide a high level of confidence by itself, it can be used to quickly detect file modifications or \nprevent the execution of modified files. Some network devices may not have this verification feature \nenabled by default, so it may be necessary for administrators to enable it. \nHigher Confidence Levels \nIn some cases, it may be necessary to provide even more confidence that a file has not been modified. A \nhigher level of confidence can be obtained by attempting to verify a file using all methods available. This \n\n23 includes obtaining all possible online hashes, obtaining an offline copy of the file using all protocols \navailable, and utilizing all available self-verification features. This can be time consuming, but the more \nmethods that provide a positive result, the more likely the file is legitimate and has not been modified.  \nIf additional confidence is required, multiple cryptographic hash functions could be used rather than \nrelying only on one, such as following the above process utilizing two or more hashes. Obviously this \nmethod requires the vendor to provide the published hashes from multiple cryptographic hash algorithms. \nIf the vendor does not provide these additional hashes, it may be necessary to obtain a trusted copy of the \noriginal file and manually compute the published hashes. \nAnother method to further increase the level of confidence is to compare the entire offline file byte-for-\nbyte with a trusted copy of the file. This provides significantly greater confidence than hashes since some \nhashes may be subject to collision attacks. I t may be more difficult to obtain an original copy of file from \nthe vendor, especially without a maintenance contract. This also requires an offline copy of the file from \nthe network device, but fortunately this is already obtained for computing the offline hash. \nMemory Verification \nSimilar to file verification, a cryptographic hash can be computed on the contents of memory and \ncompared with a known good value. The contents of memory are always changing in every system, so it \nis useless to compute the hash on the entire contents of memory. The operating system code that resides \nin memory theoretically should remain static so the cryptographic hash should only be computed on those \nareas in memory where executable code resides. Determining the location of executable code in memory \ncan be an extremely difficult task for some systems. \nUnfortunately, performing a simple hash comparison may not be sufficient for verifying the memory of \nsome systems. The operating system can implement address space layout randomization (ASLR)10 to \nprotect against buffer overflow attacks by randomly arranging the location in memory where code resides \nwhen the system first boots. It will be useless to compute the hash on these portions of memory if they are \ndifferent every time the system is booted. For systems that implement ASLR, it will be necessary to \nrearrange the expected contents of memory to match the layout of the running system before a \ncomparison can be made. Rather than using cryptographic hashes, it is likely more effective to compare \nthe actual bytes in memory and note any differences. \nExecutable space protection11 is another security mechanism where an operating system marks certain \nareas of memory as non-executable. Systems that do not implement such protections could allow code to \nbe executed in other areas in memory which normally would not contain executable code and thus would \nnot be verified through this process. Fortunately, it is highly likely that the areas of memory where \nexecutable code is expected to reside would need to be modified in order for the system to also execute \nany code residing in other areas of memory. For this reason, it is assumed that memory verification \nshould only need to be performed on the areas of memory where executable code is expected to reside, as \nlong as this process is complete and all areas of executable memory are verified. \nNetwork device vendors may also implement other methods for attempting to prevent executable code \nfrom being modified in memory or from executing code in other areas of memory. These methods will \n\n24 significantly complicate the processes used for verifying the contents of memory, and will be system \ndependent cases that will need to be handled separately. \nRegardless, in order to perform memory verification on a network device, there must be an administrative \nfunction that allows the contents of memory to be hashed or copied offline. If such a function does not \nexist for a specific device, it is likely that memory verification cannot be performed on that device. In \nthose cases, it is recommended to perform file verification, and if all hash comparisons are correct, reboot \nthe device to ensure the legitimate files are executed during the boot process. \nBut even if an administrative function does exist for hashing and copying the contents of memory, it is \nhighly unlikely that vendors will provide a known good cryptographic hash for executable code residing \nin memory. It will be necessary to establish a set of known good hashes of memory for specific versions \nof the operating system and each model. Similar to file verification, systems running the same version of \nthe operating system can be compared with each other. This can be a tedious process but can be used to \nquickly determine whether or not executable code has been modified in memory. Unfortunately, this \nprocess will not be sufficient for systems utilizing ASLR or other vendor proprietary methods. \nSince all executable code in memory should be derived from one or more files stored on the device, it \ntheoretically should be possible to generate the known good contents of memory from known good copies \nof the operating system files. This would be a significantly more tedious process for even a single version \nof the operating system, and requires knowledge of how the operating system files are copied into \nmemory for execution during the boot process. \nFirmware Verification  \nEven if all of the operating system files stored on a network device were properly verified and the \ncontents of memory were assumed to be correct since legitimate files were used when the device booted, \nit is still possible that a software modification exists in the firmware, boot loader, or basic input/output \nsystem (BIOS) that is executed when the device boots. This is software that is generally stored on a read-\nonly memory (ROM) chip located on the device's motherboard and is used to load the operating system \nfiles when the network device is first turned on or rebooted. For some devices, the firmware may be the \nsame thing as the operating system. The term firmware  will be used to refer to the software used to boot \nthe device and load the operating system files, and not the actual operating system files. \nA sophisticated modification of the firmware could cause legitimate operating system files to be modified \nas they are loaded into memory, resulting in a memory-only operating system software modification that \nwould not be detected by verifying the stored files, even if the device was rebooted with files known to be \nlegitimate. Fortunately, it is assumed that a malicious modification of the firmware would also result in a \nmodification to the executable code in memory. So for those systems that do support an administrative \ninterface to access the contents of memory, a firmware modification could be detected by performing \nmemory verification in addition to file modification, even though it may not be obvious that a firmware \nmodification may have been the source of a detected memory modification. \nSome systems may allow the ROM chip containing the firmware to be accessed while the operating \nsystem is running. Other systems may only allow the firmware to be accessed from a minimal interface \nthat is only accessible with physical access and after rebooting the system into a non-operational mode. \n\n25 Other systems may only provide write access to upgrade the firmware and require the ROM chip to be \nphysically removed from the device and accessed via a specialized chip reader to read the contents. \nRegardless of the method used to acquire the firmware, a cryptographic hash can be computed on the \nfirmware and compared to a known good, similar to file verification. It will be highly system dependent \nwhether or not a specific network device supports verification of the firmware in this manner. \nUnfortunately, the only option to verify the integrity of the firmware on some systems may be to simply \noverwrite it with a known good copy provided by the vendor. \nRootkit Detection  \nOne final area to investigate when verifying the integrity of a network device is to attempt to obtain the \nsame information using multiple methods. Many rootkits attempt to hide their existence from users and \nadministrators by hooking various operating system calls and modifying the output before it is provided \nto the caller. If the same information can be retrieved through multiple methods, it is possible that the \nadversary may not have hooked all of them. \nAs an example, an adversary could insert a malicious section into the configuration and then hide it by \nhooking the call that retrieves the configuration. When the configuration is displayed to an administrator, \nthe hook could remove the malicious section, hiding it from view. But if the administrator is able to \nretrieve the configuration using a different call that the adversary was not aware of or did not hook, the \nmalicious section could easily be seen by comparing it with the output from the other call. \nAt a minimum, the configuration of a network device should be obtained through multiple methods, if \nsupported by the network device. If also supported, other information should also be obtained in the same \nmanner, such as established network connections, local accounts, routing tables and any other information \nthat would be beneficial for an adversary to modify to prevent detection. \n  \n\n26 Network Device Integrity (NDI) - \nHardware Modification Detection \nIt can be extremely difficult to verify the integrity of any piece of hardware, even when physical access is \navailable. Some components can be detected as counterfeit by performing an X-ray and discovering \nirregularities by comparing the result with other similar equipment12. Some other studies have shown that \na malicious hardware modification can be detected by physically testing the integrated circuits (IC) and \nidentifying unknown functionality13. Wireless hardware modifications can be detected by analyzing radio \nfrequency (RF) signals that are emanating unexpectedly from a device. Unfortunately, all of these \nmethods require direct physical examination of a device and cannot be quickly repeated for a large \nnumber of devices in a short amount of time. \nPhysically examining every network device is probably not feasible for most networks due to physically \nseparate locations or the vast size of the network. Regardless, there are several actions that can be \nperformed on some systems when only remote access is available. Even though these steps may not \nprovide a high level of confidence, they may still provide a basic indication of a potential hardware issue. \nUnique Identifiers  \nMost network devices are hardcoded with a unique serial number. Even individual pieces of equipment \nthat can be added or removed may also have their own unique serial numbers, such as pluggable add-on \ncards, interfaces or blades. Serial numbers often follow a very specific format according to each vendor, \nand the serial numbers assigned to a device can be verified to conform to this specification. Some vendors \nmay also provide a service that allows customers to validate serial numbers as legitimate pieces of \nequipment and verify where they were shipped and who they were sold to. \nIt is assumed that an adversary producing counterfeit equipment will already know the expected serial \nnumber format. To conform to the expected format, the adversary may simply duplicate or clone known \nlegitimate serial numbers. A duplicate serial number can be detected by gathering serial numbers from \nunique devices and looking for more than one instance of the same serial number. Since the serial number \nmay be commonly used to identify unique devices based on the physical hardware, it will be necessary to \nutilize a different unique attribute to identify devices independent of the hardware. The configuration of \neach system should be unique, because each system should at least have a different IP address assigned to \nit, and thus a cryptographic hash of the configuration should be sufficient to uniquely identify devices. \nThis assumes no two devices have identical configurations, the configurations of the network devices do \nnot change while data is obtained from all the devices on the network, and the same cryptographic hash is \nused for systems of the same type. This unique identifier can be correlated with serial numbers to detect \npotentially duplicate serial numbers. \nAnother unique piece of information that should be assigned to a network interface card attached to a \nnetwork device is the media access control (MAC) address. The MAC address should be unique for each \nphysical interface. The MAC addresses on all network devices can be obtained and correlated similar to \nserial numbers. For some devices, it may only be necessary to obtain the chassis MAC address if \nsubsequent addresses on the same piece of equipment are incremental. \n\n27 Operating Statistics  \nMany network devices also have a mechanism to monitor specific attributes about the operating status of \nthe hardware itself. This includes voltages, temperatures and fan speeds. Generally these values should be \nwithin a normal expected range, as specified by the vendor. These ranges will be vendor and system \nspecific, and it depends on the vendor whether or not this information is available. Any deviation of these \nvalues may be a potential indication that the hardware is counterfeit. Independent of detecting hardware \nmodifications, this information can also detect potential hardware failures before they occur. \nAttributes like voltages and temperatures can be obtained by physically examining a device with external \ngauges, but some of this information may be available when only remote access is available. A network \ndevice must be built with internal sensors and be capable of monitoring itself and include a mechanism to \nreliably report this type of information to network administrators. When this information is available, \nthese attributes can be compared with other legitimate systems, which may be inconsistent in counterfeit \nequipment. Unfortunately, these attributes will likely provide a lower level of confidence than physically \nexamining a system. \nNetwork Traffic Analysis \nAnother method to detect counterfeit equipment is to passively monitor network traffic that is processed \nby a device and calculating the time elapsed for the device to process a packet14. When a legitimate piece \nof hardware is installed, an individual packet of the same size should theoretically take the same amount \nof time for a network device to process. Any deviations from normal expected behavior could be an \nindication of a potential hardware modification. \nSimilar to unauthorized access detection, a hardware modification may also be detectable by passively \nmonitoring the contents of network traffic or examining the source and destination addresses. The \nintroduction of unexpected network connections that originate from the network device itself could be an \nindication of a hardware modification that exfiltrates sensitive information to an external destination. If \nthe software on a network device is exhibiting this type of behavior and is verified to be legitimate, the \nsource of the unexpected network connections could be an additional piece of hardware added to the \nnetwork device. \nFortunately, analyzing network traffic is generally not system specific, so the detection of unexpected \nnetwork connections can be performed for any type of system, as long as the passive sensors monitoring \nthe traffic are installed in appropriate locations on the network around the suspect systems. \n  \n\n28 Network Device Integrity (NDI) - \nWorksheets \nThe following pages contain several template worksheets that can be used for performing Network \nDevice Integrity (NDI). These worksheets can assist with ensuring all of the necessary information is \nobtained from each device and the most critical areas are reviewed during the analysis of that information. \nAfter these worksheets have been filled in with the relevant information, the methodology provided above \ncan be performed with this information to verify the integrity of the network device, along with any \nvendor specific cases. \nThese worksheets can be printed double sided and the corresponding information key will be printed on \nthe back side of each worksheet for reference. \n  \n\n29 Network Device Integrity (NDI) - System Information  \nDate / Time   \nHost  Name  \nModel   \nDevice  Serial Number   \nAdd'l Serial Numbers   \n \nUnique Attribute  \nHash of Stored Config uration   \nIP Addresses  MAC Addresses  \n \n \n \n  \nUptime   \nFirmware Version(s)  \nFirmware / Boot loader / BIOS  \nBoot Settings   \nLast Reboot Reason   \nSelf-Verification  \nEnabled ?  \n Exists ? \nRunning  OS Version   \n \n  \n \nBoot OS Version (s)  \n \n  \nOther OS Version(s)  \nExists but not used   \n \n \nOperating Statistics  \nVoltages, Temperatures,  Fan Speeds   \n \n \nRootkit Detection  \nOutput Comparison   \n \n \nObservations   \n \n \n \n \n \n \n \n  \n\n30 System Information Worksheet \nThis worksheet contains a table of information that should be obtained from each unique network device \nthat is examined. \n Date / Time  - when the provided information was obtained (include time zone) \n Host Name  - name assigned to the network device (may not necessarily be unique) \n Model  - vendor assigned hardware model \n Device Serial Number  - serial number assigned to the device (or chassis) \n Add'l Serial Numbers  - any other relevant serial numbers assigned to peripheral equipment \n Unique Attribute  - a piece of information that can uniquely identify a network device \nindependent of the hardware, such as a cryptographic hash of the configuration \n IP Addresses  - relevant IPv4 and IPv6  addresses assigned to the network device \n MAC Addresses  - relevant MAC addresses assigned to the network interfaces \n Uptime  - how long the device has been up \n Firmware Version(s)  - firmware, boot loader or BIOS used to boot the device; if more than one \nversion exists, note which version is used \n Boot Settings  - firmware, boot loader or BIOS settings that determine how the device boots \n Last Reboot Reason  - why the device was last rebooted \n Self-Verification  - whether or not self-verification is enabled for executable files \n Running OS Version  - current running version of the operating system \n Boot OS Version(s)  - versions of the operating system that may attempt to be loaded after the \nnext reboot of the device \n Exists?  - it should be noted if the running OS version or any of the configured boot OS versions \ndo not exist on the file system \n Other OS Version(s)  - any other executable files stored on the network device that are currently \nnot in use and will still not be used after a reboot \n Operating Statistics  - voltages, temperatures, fan speeds and similar relevant information \n Rootkit Detection  - any relevant information concerning the comparison of similar outputs \nobtained via different methods \n Observations  - any other relevant observations about the network device \n  \n\n31 Network Device Integrity (NDI) - Unauthorized Access Detectio n \nDevice Identifier  \nHost  Name / Serial  Num  / IP Addr  \nLogin Access  \nDate / Time  Account  Source Address  Duration  \n \n \n \n \n \n    \nConfiguration Changes  \nDate / Time  Account  Source Address  Change  Detail  \n \n \n \n \n \n    \nBlocked Attempts  \nDate / Time  Account  Source Address  Attempted Action  \n \n \n \n \n \n    \nInterface Changes  \nDate / Time  Interface  State  \n \n \n \n \n \n   \nOther Events  \nDate / Time  Event  \n \n \n \n \n \n \n \n  \n  \n\n32 Unauthorized Access Detection Worksheet \nThis worksheet contains a table of information that should be obtained for each event that occurred \nconcerning a network device that should be investigated. Obviously, there are probably more events than \ncan fit on this worksheet, and some events may contain relevant information not requested by this \nworksheet. Regardless, this worksheet can still be used as a reference to determine what types of events \nshould be reviewed first. \n Device Identifier  - unique host name, serial number or IP address for the network device \n Date / Time  - timestamp when the event occurred \n Account  - user account associated with the corresponding action \n Source Address  - if known, the source address of the event \n Duration  - the length of time the administrative connection was active \n Change Detail  - what information was changed in the configuration \n Attempted Action  - what action was attempted that was blocked or denied \n Interface  - the interface name or identifier that was related to the event \n State  - the new status of the interface according to the event (up, down, etc) \n Event  - detailed information about the event that occurred \n \n  \n\n33 Network Device Integrity (NDI) - File / Memory / Firmware  Verification  \nDevice Identifier  \nHost  Name / Serial  Num  / IP Addr  \nFile Name   \nFile Path   \nFile Version   \nFile Size   \nFile Timestamp   \nFile Permissions   \nHash Type   \nOnline Hash (es) \nand Source  \n \n \n \nOffline Hash (es) \nand Source  \n \n \n \nPublished Hash (es) \nKnown Good   \n \n \n \nPublished File Name   \nPublished File Path   \nPublished File Version   \nPublished File Size   \nPublished Release Date   \nHash Comparison  \nPass / Fail / Incomplete   File Size Comparison  \nPass / Fail / Incomplete   \nSelf-Verification  \nChecksum or Other Hash(es)  \n and Verification Result   \n \n \n \nObservations   \n \n \n \n \n \n \n \n \n \n \n \n  \n\n34 File / Memory / Firmware Verification  Worksheet \nThis worksheet contains a table of information that should be obtained from each file on a network device \nthat should be verified. This should include operating system files and other executables, and any other \nfiles that do not normally change and could potentially be used by an adversary to perform malicious \nactivities. Additional copies of the worksheet can be used for different files, or for the same file but using \na different type of cryptographic hash. This worksheet can also apply to the contents of memory and the \nfirmware in addition to stored files, even though all of the fields may not apply in each situation. \n Device Identifier  - unique host name, serial number or IP address for the network device \n File Name  - name of the file \n File Path  - path of the file in reference to where it was stored on the network device \n File Version  - vendor defined version of the file, if applicable \n File Size  - the number of bytes contained in the file \n File Timestamp  - the date and time the file was last written on the network device \n File Permissions  - the permissions assigned to the file \n Hash Type  - type of cryptographic hash utilized in the fields below \n Online Hash(es)  - any online hashes obtained for the above file, including the source such as the \ncommand utilized to obtain the hash \n Offline Hash(es)  - any offline hashes associated with the above file, including the source such as \nthe protocol utilized to obtain the offline file \n Published Hash(es)  - any published hashes associated with the above file \n Published File Name  - name of the file associated with the above published file \n Published File Path  - path of the file associated with the above published file \n Published File Version  - operating system version associated with the above published file \n Published File Size  - number of bytes contained in the above published file \n Published Release Date  - date the above published file was released by the vendor \n Hash Comparison  - result of comparing the online, offline and published hashes \n File Size Comparison  - result of comparing the file size with the published file size \n Self-Verification  - results of any vendor specific self-verification features \n Observations  - any other relevant observations about the file  \n  \n\n35 References \n \n1 Cisco Event Response: SYNful Knock Malware [October 9, 2015] \nhttp://www.cisco.com/c/en/us/about/security-center/event-response/synful-knock html  \n[Accessed February 23, 2016] \n \n2 Evolution of attacks on Cisco IOS devices [October 8, 2015] \nhttp://blogs.cisco.com/security/evolution- of-attacks- on-cisco-ios-devices  \n[Accessed February 23, 2016] \n \n3 Nasty Cisco Attack [August 19, 2015] \nhttps://www.schneier.com/blogs/archives/2015/08/nasty cisco att.html  \n[Accessed February 23, 2016] \n \n4 Cisco network kit warning: Watch out for malware in the firmware [August 13, 2015] \nhttp://www.theregister.co.uk/2015/08/13/cisco warning malware in firmware/  \n[Accessed February 23, 2016] \n \n5 Cisco Guide to Harden Cisco IOS Devices [January 6, 2016] \nhttp://www.cisco.com/c/en/us/support/docs/ip/access-lists/13608-21 html  \n[Accessed February 23, 2016] \n \n6 Computer Security Incident Handling Guide [August 2012] \nhttp://nvlpubs.nist.gov/nistpubs/SpecialPublicatiosn/NIST.SP.800-61r2.pdf  \n[Accessed February 23, 2016] \n \n7 Targeted Cyber Intrusion Detection and Mitigation Strategies (Update B) | ISC-CERT [February 6, 2013] \nhttps://ics-cert.us-cert.gov/tips/ICS-TIP- 12-146- 01B \n[Accessed February 23, 2016] \n \n8 A Hack Attack [No Date] \nhttp://www.cisco.com/cisco/web/solutions/small business/resource center/articles/secure my business/ha\nck attack/index.html  \n[Accessed February 23, 2016] \n \n9 File verification - Wikipedia, the free encyclopedia [February 15, 2016] \nhttps://en.wikipedia.org/wiki/File verification  \n[Accessed February 23, 2016] \n \n10 Address space layout randomization - Wikipedia, the free encyclopedia [February 20, 2016] \nhttps://en.wikipedia.org/wiki/Address space layout randomization  \n[Accessed February 23, 2016] \n \n11 Executable space protectio n - Wikipedia, the free encyclopedia [February 3, 2016] \nhttps://en.wikipedia.org/wiki/Executable space protection  \n[Accessed February 23, 2016] \n \n12 The Hidden Dangers of Chop-Shop Electronics - IEEE Spectrum [September 20, 2013] \nhttp://spectrum.ieee.org/semiconductors/processors/the-hidden-dangers- of-chopshop-electronics  \n[Accessed February 23, 2016] \n \n \n\n36  \n13 Addressing the Challenges of Hardware Assurance in Reconfigurable Systems [2 013] \nhttp://ersaconf.org/ersa13/papers/Robinson-Hardware-Assurance.pdf  \n[Accessed February 23, 2016] \n \n14 A Network-based Approach to Counterfeit Detection [November 2013] \nhttp://www2.ece.gatech.edu/cap/papers/HST13%20Paper%20186%20A%20Network-\nbased%20Approach%20to%20Counterfeit%20Detection.pdf  \n[Accessed February 23, 2016] \n \n\n",
  "cves": [],
  "techniques": [],
  "advisory": "cybersecurity-alerts",
  "title": "network device integrity ndi methodology",
  "source": "nsa",
  "id": "0078b5a74b811023844ab85e524e103118b431abe12b30d05f9d247486f78ec2"
}