{
  "markdown": "  \n \n                                                    \n             \n \nTo report suspicious or criminal activity related to information found in this Joint Cybersecurity Advisory, contact \nyour local FBI f ield office  or CISAs 24/7 Operations Center at Report@cisa.gov  or (888) 282 -0870. When \navailable, please include the following information regarding the incident: date, time, a nd location of the incident; \ntype of activity; number of people affected; type of equipment used for the activity; the name of the submitting \ncompany or organization; and a designated point of contact.  \nThis document is marked TLP: CLEAR . Recipients may shar e this information without restriction. Information is \nsubject to standard copyright rules. For more information on the Traffic Light Protocol, see cisa.gov/tlp/ . \n \nTLP: CLEAR    Product ID : AA23 -129A  \n May 9, 2023  TLP: CLEAR  \n Co-Authored by:  \n \n \n \nHunt ing Russian Intelligence  Snake Malware  \nSUMMARY  \nThe Snake implant is considered the most sophisticated cyber  espionage tool designed and used by \nCenter 16 of Russias Federal Security Service (FSB) for long -term intelligence collection on sensitive \ntargets. To conduct operations using this tool, th e FSB create d a covert peer -to-peer (P2P) network of \nnumerous Snake -infected computers worldwide . Many systems in this P2P network serve as relay \nnodes which route disguised operational traffic to and from Snake implants on the FSB s ultimate \ntargets. Snakes custom communications protocols employ encryption and fragmentation for \nconfidentiality  and are designed to ham per detection and collection efforts.  \nWe have identified Snake infrastructure in over 50 countries across North America, South America, \nEurope, Africa, Asia, and Australia , to include the United States and Russia itself . Although  Snake \nuses infrastructure across all industries, its targeting is purposeful and tactical in nature. Globally, the \nFSB has  used Snake to  collect sensitive intelligence from high -priority targets, such as  government \nnetworks, research facilities, and journ alists. As one example, FSB actors used Snake to access and \nexfiltrate sensitive international relations documents, as well as other diplomatic communications, \nfrom a victim in a North Atlantic Trea ty Organization (NATO) country . Withi n the United States, the \nFSB has victimized industries including  education, small business es, and media  organizations , as \nwell as critical infrastructure sectors including  government facilities , financ ial services , critical \nmanufacturing, a nd communications . \nThis Cybersecurity  Advisory  (CSA)  provides background on Snakes attribution to the FSB and  \ndetailed technical descriptions of the implant s host architecture and network communications. This \nCSA also address es a recent Snake variant that has not yet been widely disclosed.  The technical \ninformation and mitigation recommendations in this CSA are provided  to assist network defenders  in \ndetecting Snake and associated activity.  For more information on FSB and Russian state-sponsored \ncyber activity, please see the joint advisory  Russian  State -Sponsored and Criminal Cyber Threats to \nCritical Infrastructure  and CISAs Russia Cyber Threat Overview and Adviso ries webpage.   \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 2 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    TABLE OF CONTENTS  \nSummary  ................................ ................................ ................................ ................................ .........  1 \nIntroduction  ................................ ................................ ................................ ................................ ..... 4 \nWhat is Snake?  ................................ ................................ ................................ ............................  4 \nBackground  ................................ ................................ ................................ ................................ ... 4 \nAttribution  ................................ ................................ ................................ ................................ ..... 5 \nVictimization  ................................ ................................ ................................ ................................ . 5 \nOther Tools and TTPs Employed with Snake  ................................ ................................ ...........  6 \nSnake Architecture  ................................ ................................ ................................ ......................  6 \nCapitalizing on Mistakes  ................................ ................................ ................................ .............  7 \nSnake Host -Based Technical Details  ................................ ................................ .......................  8 \nInstaller  ................................ ................................ ................................ ................................ ..........  8 \nOn-Disk Components  ................................ ................................ ................................ ...................  8 \nThe Queue  ................................ ................................ ................................ ................................ ... 11 \nSnake Network Comm unications  ................................ ................................ ...........................  17 \nNetwork Obfuscation  ................................ ................................ ................................ .................  17 \nSnakes Network Authentication Technique (ustart)  ................................ ........................  17 \nSnake UDP  ................................ ................................ ................................ ................................ .. 19 \nSnake HTTP  ................................ ................................ ................................ ................................ . 20 \nSnake TCP  ................................ ................................ ................................ ................................ ... 21 \nSnake enc Layer  ................................ ................................ ................................ ......................  23 \nSnake Application Layer  ................................ ................................ ................................ ...........  24 \nCommand 0x15 -byte Header  ................................ ................................ ................................ ... 24 \nCommand Encryption  ................................ ................................ ................................ ................  24 \nCommand Decoding  ................................ ................................ ................................ ..................  25 \nHigh Commands  ................................ ................................ ................................ .........................  26 \nQueue Commands  ................................ ................................ ................................ .....................  27 \nForward Commands  ................................ ................................ ................................ ..................  28 \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 3 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Snake Implant Operation  ................................ ................................ ................................ ..........  31 \nActive Operations  ................................ ................................ ................................ .......................  31 \nPassive Operations  ................................ ................................ ................................ ....................  31 \nMitigation s ................................ ................................ ................................ ................................ .... 35 \nNetwork -Based Detection  ................................ ................................ ................................ .........  35 \nHost -Based Detection  ................................ ................................ ................................ ................  37 \nMemory Analysis  ................................ ................................ ................................ ........................  40 \nPrevention  ................................ ................................ ................................ ................................ ..... 42 \nChange Credentials  and Apply Updates  ................................ ................................ .................  42 \nExecute Organizational Incident Response Plan  ................................ ................................ .. 42 \nAppendix  ................................ ................................ ................................ ................................ ........  43 \nPartnership  ................................ ................................ ................................ ................................ .. 43 \nDisclaimer  ................................ ................................ ................................ ................................ ... 43 \nMITRE AT T&CK  Techniques  ................................ ................................ ................................ ... 43 \nVolatility Plugin  ................................ ................................ ................................ ...........................  47 \n \n  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 4 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    INTRODUCTION  \nWhat is Snake?  \nWe consider Snake to be the most sophisticated cyber espionage tool in the FSBs arsenal. The \nsophistication of Snake stems from three principal areas. First, Snake employs means to achieve  a \nrare level of stealth in its host components and network communi cations. Second, Snakes internal \ntechnical architecture allows for easy incorporation of new or replacement components . This design \nalso facilitates the development and interoperability of Snake instances running on different host \noperating systems. We ha ve observed interoperable Snake implants for Windows, MacOS, and Linux \noperating systems. Lastly, Snake demonstrates careful software engineering design and \nimplementation, with the implant  contain ing surprisingly few bugs given its complexity.  \nFollowing  open source reporting by  cybersecurity and threat intelligence companies on Snake tactics, \ntechniques, and procedures (TTPs), the FSB implemented new techniques  to evade detection . The \nmodifications to the implant  enhanced challenges in identifying  and coll ecting Snake and related  \nartifacts , directly hamper ing detection from both host - and network -based defensive tools.  \nThe effectiveness of this type of cyber  espionage implant depends entirely on its long -term stealth, \nsince the objective of an extended espi onage operation involves remaining on the target for months \nor years  to provid e consistent access to important intelligence. The uniquely sophisticated aspects of \nSnake represent significant effort by the FSB over many years to enable this type of covert a ccess . \nBackground  \nThe FSB began developing Snake as Uroburos in late 2003. Development o f the initial versions of \nthe implant appeared to be completed around early 2004, with cyber operations first conducted using \nthe implant shortly thereafter. The name Uroburos is appropriate, as the FSB cycled it through nearly  \nconstant  stages of upgrade and redevelopment , even after public disclosures, instead of  abandon ing \nit. The name appears throughout early versions of the code, and the FSB developers also left other \nunique strings , including Ur0bUr()sGoTyOu# , which have publicly come back to haunt them . \nUnique features in early versions of Uroburos included a low \nresolution image of a portion of a historical illustration of an \nuroboros by the German phi losopher and theologian Jakob \nBhme. One approach to a tertiary backdoor used this image  \nas the key. The same image had also been embedded in other \nSnake -related components . The image, blown up to a higher \nresolution, is shown at right . \nIn addition, early FSB developers of the Snake implant left \nportions of unique code throughout the implant which reveal \ninside jokes, personal interests, and taunts directed at security \nresearchers. For instance, t he Ur0bUr()sGoTyOu#  string \nreferenced above was replaced with gLASs D1cK  in 2014 \nfollowing some  of the public  cybersecurity reporting . \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 5 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Attribution  \nWe attribute Snake operations to a known unit within Center 16 of the FSB.1 This unit more broadly \noperates the numerous elements of the Turla2 toolset , and has subunits spread throughout Russia in \na reflection of historical KGB signals intelligence operations in the Soviet Union. Snake has been a \ncore component of this units operations for almost as long as Center 16  has been part of the FSB.3 \nThe exte nsive influence of Snake across the Turla toolset demonstrates its impact on practically \nevery aspect of the units modern era of cyber operations.  \nDaily operations using Snake have been  carried out from an FSB facility in Ryazan , Russia, with an \nincrease in Snake activity during FSB working hours in Ryazan, approximately 7:00 AM to 8:00 PM, \nMoscow Standard Time (GMT+3). The main  developers were Ryazan -based FSB officers known by \nmonikers included in the code of some versions of Snake.  In addition to develo ping Snake, Ryazan -\nbased FSB officers used it to conduct worldwide operations; these operations were different from \nothers  launched from Moscow or other FSB sites based on infrastructure  and techniques . \nWhile the development and re -tooling of Snake has historically been done by Ryazan -based FSB \nofficers, S nake operations were al so launched from an FSB Center 16 -occupied building in Moscow. \nOur investigati ons have identified examples of FSB operators using Snake to its full potential, as well \nas FSB opera tors who appeared to be unfamiliar with Snake s more advanced capabilities.  These \nobservations  serve to  illustrate the difficulty in using  such an advanced toolset across the various  \ngeographically  dispersed teams  comprising this unit within FSB Center 16 . \nWe have been collectively investigating Snake and Snake -related tools for almost 20 years , as well \nas other  operations by this unit since the 1990s . During that time, t he FSB ha s used Snake in many \ndifferent operations, and they have demonstrated the value place d in this tool by making numerous \nadjustments and revisions to keep it viable after repeated public disclosures and other mitigation s. \nSnake s code  and multiple Snake -related tools  have been either a starting point or a key influence \nfactor for a diverse range of other highly prolific implants  and operational tools  in the Turla family . \nMost notably, this has included Carbon (aka Cobra) derived from Snake s code  base and the \nsimilarly Snake -adjacent implant  Chinch (currently known in open sources as ComRAT ). \nVictimization  \nWe have identified Snake infrastructure in over 50 countries across North America, South America, \nEurope, Africa, Asia, and Australia , to include the United States and Russia itself . Although  Snake \nleverages infrastructure across all industries, its targeting is purposeful and tactical in nature. For \ninstance, i f an infected system did not respond to Snake communications, the FSB actors would \nstrategically re -infect it within days. Globally, the FSB has used Snake to collect sensitive intelligence \nfrom high priority targets, such as government networks, research facilities, and journalists. As one \nexample, FSB actors used Snake to access and exfiltrate sensitive international relations documents , \n                                                \n1 This unit is distinct from a sister unit in FSB Center 16 which the FBI publicly attributes  to Dragonfly  operations.  \n2 Turla  is one of many open source terms used to describe the family of implants used by this FSB Center 16 unit. Snake  \nand the broader Turla  family have also previously been referenced in  private sector reporting using the names Krypton, \nVenomous Bear, Penquin, Agent .BTZ, ComRAT, Waterbug, Tavdig , Wipbot, Epic Turla, Mosquito, Carbon , and others.  \n3 The 3rd Chief Directorate of FAPSI was transferred to the FSB as Center 16 when FAPSI was dissolved in 2003.  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 6 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    as well as other diplomatic co mmunications, from a victim in a NATO country.  Within the United \nStates, the FSB has victimized industries including education, small businesses, and media \norganizations, as well as critical infrastructure sectors including government facilities, financial  \nservices, critical manufacturing, and communications . \nOther Tools and TTPs Emp loyed with Snake  \nThe FSB typically deploys Snake to external -facing infrastructure nodes on a network, and from there \nuses other tools and TTPs on the internal network to conduc t additional exploitation operations.  Upon \ngaining and cementing ingress into a target network, the FSB typically enumerates t he network and  \nworks to obtain administrator credentials and access domain controllers.  A wide array of mechanisms \nhas been employ ed to gather user and administrator credentials in order to expand laterally across \nthe network, to include keyloggers, network sniffers, and open source tools .4 \nTypically, after FSB operators map  out a network and obtain administrator credentials for vari ous \ndomains in the network, regular collection operations begin. In most instances with Snake, further \nheavyweight implants are not deployed, and they rely on credentials and lightweight remote -access \ntools internally  within a network . FSB operators someti mes deploy a small remote reverse shell along \nwith Snake to enable interactive operations . This triggerable reverse shell, which the FSB has used \nfor around 20 years,  can be used as a backup access vector , or to maintain a minimal  presence in a \nnetwork and avoid detection while moving laterally.5 \nSnake Architecture  \nSnakes  architectural design reflects professional software engineering practices. Critical pathways \nwithin the implant are made  of stacks of loosely coupled components that implement well -designed \ninterfaces. In addition to facilitating software development and debugging, this construction allows \nSnake to use multiple different components for the same purpose, choosing the specifi c component \nbased on environmental considerations. For example, Snakes custom network communications \nprotocols function as a stack. All implementations use an encryption layer and a transport layer, such \nas Snakes custom HTTP or raw TCP socket protocol. Each layer of the Snake network protocol stack \nsolely implements a specified interface for operability with the two adjacent layers. The encryption \nlayer and underlying transport layer thus function independently, so any custom Snake network \nprotocol can e mploy an encryption overlay without any change to the encryption layer code.6 \nThis modularity allows Snake operators to choose the most logical network transport for the given \nenvironment without affecting Snakes other functionality. When using  a compromi sed HTTP server \nas part of the Snake P2P network, the operators can ensure that all traffic to this machine follows the \nSnake custom HTTP protocol and thereby blends effectively with legitimate traffic. In the context of a \ncompromised machine that legitima tely allows secure shell (SSH) connections, Snake can utilize its \ncustom raw TCP socket protocol instead of its custom HTTP protocol. All other layers of the Snake \nprotocol stack, from the immediately adjacent transport encryption layer to the distant comm and \nprocessing layer, can and do remain entirely agnostic to the transport layer as long as it implements \n                                                \n4 MITRE ATT&CK IDs: [ T0840 ], [T1003 ], [T1040 ], [T1046 ], [T1056.001 ], [T1078 ], [T1083 ], [T1135 ], [T1482 ] \n5 MITRE ATT&CK IDs: [ T1190 ], [T1570 ], [T1587.001 ], [T1608 ] \n6 MITRE ATT&CK IDs: [T1095 ], [T1547.006 ], [T1587.001 ] \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 7 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    its interface correctly. This architecture also allows the Snake developers to easily substitute a new \ncommunications protocol when they believe one has been compromised, without necessitating any \ndownstream changes in the code  base. Lastly, this design facilitates the development of fully \ninteroperable Snake implants running on different host operating systems.  \nSnakes technical sophistication extends from the software architecture into the lower -level software \nimplementation. Original versions of Snake were developed as early as 2003, before many of the \nmodern programming languages and frameworks that facilitate this type of modular development \nwere av ailable. Snake is written entirely in C, which provides significant advantages in low -level \ncontrol and efficiency, but which does not prov ide direct support for objects or  interfaces at the \nlanguage level and provides no assistance with memory management.  The developers of Snake \nsuccessfully implemented the implants complex design in C with very few bugs, including careful \navoidance of the common pitfalls associated with null -terminated strings and the mixing of signed and \nunsigned integers. Additionally,  the developers demonstrate an understanding of computer science \nprinciples throughout the implants implementation. This includes selecting and correctly coding \nasymptotically optimal algorithms, designing and utilizing efficient custom encoding methodolo gies \nthat closely resemble common encoding schemes, and handling the numerous possible errors \nassociated with systems -level programming in a secure manner.  \nCapitalizing on Mistakes  \nAlthough the Snake implant as a whole is a highly sophisticated espionage t ool, it does not escape \nhuman error. A tool like Snake requires more familiarity and expertise to use correctly, and in several \ninstances Snake operators neglected to use it as designed. Various mistakes in its development and \noperation provided us with a foothold into the inner workings of Snake and were key factors in the \ndevelopment of capabilities that have allowed for tracking Snake an d the manipulation of its data.  \nThe FSB use d the OpenSSL library to handle its Diffie -Hellman key exchange. The Diffie -Hellman \nkey-set created by Snake during the key exchange is too short to be secure. The FSB provide d the \nfunction DH_generate_parameters with a prime length of only 128 bits, which is inadequate for \nasymmetric key systems.  Also, i n some instances of what a ppeared to be rushed deployments of \nSnake, the operators neglected to strip the Snake binary. This led to the discovery of numerous \nfunction names, cleartext strings, and developer comments as seen in the following figure . \n  \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 8 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    SNAKE HOST -BASED TEC HNICAL DETAILS  \nThe FSB has quickly adapt ed Snake when its capabilities have  been public ly disclosed by private \nindustry. Snake therefore exists in several variants , as it has evolved over almost 20 years. This CSA \nfocus es on one of the more recent variants of Sna ke that up until now has not been widely disclosed. \nOlder variants of Snake will be discussed briefly where applicable, but not discussed in depth, as \nmany details of earlier Snake variants already exist in the public domain.  \nInstaller  \nThe Snake installer has gone by various names throughout Snakes existence (e.g., jpinst.exe). This \nadvisory will describe the version of the installer which regularly used the name jpsetup.exe. This \nexecutable is packed using a customized obfuscation methodology.  The dev elopers appear to have \nadded the unpacking functionality from an open source project for viewing JPEG files.  This technique \nserves to obfuscate the unpacking code within an otherwise legitimate code base .7 The unpacking \ncode extracts an executable, herein referred to as the Png Exe, and it extracts an AES encrypted \nblob from the Png Exes resources, which herein will be referred to as the Png Resource.8 \nThe jpsetup.exe installer requires two arguments to be passed via the command line for execution. \nThe first argument is a wide character string hashed with SHA -256 twice, and the resulting value of \nthese computations becomes the AES key that decrypts the Png Resource. The AES initialization \nvector (IV) consists of the first 16 bytes of the second argument  to jpsetup.exe after prepending the \nargument with a wide character 1 string. Once decrypted, the Png Resource becomes an \nexecutable that will be referred to  herein  as Stage 2.9 \nWhen unpacked, many components are extracted from Stage 2 s resources. Sev eral of the resources \nare executables with additional resources of their own. Stage 2 creates structures from its resources, \nwhich ultimately become the host artifacts of Snake.  \nOn-Disk Components  \nAs Windows has been the most prevalent operating system targeted by Snake, this document will \nonly discuss the  Windows -based artifacts; however , Snake can be cross -compiled and is capable of \nrunning on other operating systems.  \nOn-Disk Obfuscation  \nSnakes host architecture and network communications allow an unu sual level of stealth. Snake \nmakes inventive use of its kernel module in both of these contexts. All known Windows versions of \nSnake have used a concealed storage mechanism to hide host componentry. In addition to using the \nkernel module to remove the rele vant components from any listing returned by the operating system, \nSnake utilizes the kernel module to mediate any requests between Snakes user mode components \nand the concealed storage mechanism, which itself is encrypted with a unique per -implant key. T his \n                                                \n7 The Snake developers have long used custom packers for the implant. This packer had several options for disguising the \ninstaller on a host. The first was as a JPEG viewer; later options included disguising the installer as Notepad++ or 7zip.  \n8 MITRE ATT&C K IDs: [ T1027.002 ], [T1140 ], [T1546.016 ], [T1588 ], [T1610 ] \n9 MITRE ATT&CK IDs: [ T1573.001 ], [T1573.002 ] \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 9 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    unique keying creates detection difficulties even for tools that are independent of the compromised \noperating system, since simple signatures targeting Snake host components would be ineffective.10 \nPersistence Mechanism  \nThe Snake version primarily discu ssed in this advisory registers a service to maintain persistence on \na system. Typically , this service is named WerFaultSvc, which we assess was used to blend in with \nthe legitimate Windows service WerSvc. On boot , this service will execute Snakes WerFa ult.exe, \nwhich Snake developers chose to hide among the numerous valid Windows WerFault.exe files in \nthe %windows% \\WinSxS \\ directory. Executi ng WerFault.exe will start the process of decrypting \nSnakes components and loading them into memory.11 \n \n                                                \n10 MITRE ATT&CK IDs: [ T1014 ], [T1027 ], [T1547.006 ], [T1610 ]  \n11 MITRE ATT&CK IDs: [ T1027 ], [T1036 ], [T1140 ], [T1564 ], [T1569.002 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 10 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Encrypte d Registry Key Data  \nUpon execution, Snakes WerFault.exe will attempt to decrypt an encrypted blob within the Windows \nregistry that is typically found at HKLM: \\SOFTWARE \\Classes \\.wav\\OpenWithProgIds. The encrypted \ndata includes the AES key, IV, and path tha t is used to find and decrypt the file containing Snakes \nkernel driver and kernel driver loader. The registry objects structure can be seen on the right side of \nthe following figure . Snake u ses Microsoft Windows Cryptography API: Next Generation (CNG) ke y \nstore to store the AES key needed to decrypt the registry object.12 \n \nKernel Driver and Custom Loader  \nSnakes installer drops the kernel driver and a custom DLL which is used to load the driver into a \nsingle AES encrypted file on disk. Typically, this fil e is named comadmin.dat and is stored in the \n%windows% \\system32 \\Com directory. The structure of this file can be seen on the left side of the \nfigure above . The key, IV, and path to comadmin.dat are stored in the encrypted registry blob.13 \n                                                \n12 MITRE ATT&CK IDs: [ T1106 ], [T1112 ], [T1547.006 ] \n13 MITRE ATT&CK IDs: [ T1027 ], [T1547.006 ], [T1569.002 ], [T1574.002 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 11 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    The Queue File  \nThe last host -based artifact to discuss is the Queue File. Typically, this file has been found within the \n%windows% \\Registration directory with the format of <RANDOM_GUID>.<RANDOM_GUID>.crmlog, \nand is decr ypted by Snakes kernel driver.  Due to the complexi ty and importance of the Queue File, \nits details are discussed at length in the following subsection.14 \nThe Queue  \nThe Queue is a Snake structure that contains various pieces of information, including key material, \ncommunication channels, modes of operation,  the princip al user mode component, etc., that Snake \nrequires for successful operation. It should be noted that this is a name used by the developers and is \nnot equivalent to a queue in the normal context of computer science. The Queue data is saved on \ndisk in the Queue File, which is a flat file with a substructure that includes a 0x2c -byte file header \nfollowed by data blocks. Each data block corresponds to exactly one Queue Item, which could be, for \nexample, a simple configuration parameter, a Snake com mand, or an entire embedded executable. \nEach Queue Item is associated with a specific Queue Container.  \nQueue Containers and Items  \nEach Container is identified by its Type and Instance values. Each Container Type holds the same \ntype of information used by t he Snake implant for a specific purpose. The following t able shows  the \nvarious Container Types and their functions. A Queue can have  multiple Containers of the same \nType, but each of these Containers  will have different Instance values.  \n \n                                                \n14 MITRE ATT&CK IDs: [ T1027 ], [T1112 ], [T1564 ], [T1610 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 12 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    The data in each Container in the Queue is separated into Queue Items with the 0x40 -byte metadata \nstructure shown  in the following table . The data content of the  Queue Item immediately follows this \nstructure. The Queue Items in each Container are distinguished by their corresponding Item Number \nas well as their Item Type identifier. The Item Number is assigned by the Snake implant itself, while \nSnake operators generally refer to the Item Type value when trying to reference a specific item.  \n \nQueue File Encryption  \nIn prev ious versions of Snake, the Queue File existed within an encrypted covert store. The data \nbelonging to the Queue Items themselves were also CAST -128 encrypted. In more recent versions, \nthe covert store was removed , and the Queue File exists by itself on di sk. The Queue Items inside the \nQueue File are still encrypted with CAST -128, and in addition, the full Queue File is also CAST -128 \nencrypted. The CAST keys used to encrypt the Queue Items within a Container Instance can be \nfound in that Instance's correspo nding 0x2 Container as Item Type 0x229 ( see below ). The key and \nIV used to encrypt the Queue File can be found by decoding strings within Snake s kernel driver.  \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 13 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Container Descriptions  \n0xb Container  \nThe 0xb Container lists the available modes of operation for a given Snake implant . When using a \ncertain mode , Snake u ses a specific set of Containers and communication channels. Each infection \ncan use up to four different modes. Each mode in the 0xb Conta iner will have a Container Instance \nvalue that all Containers associated with this mode will use, except for the 0x3 Container.15 \n \n0x0 Container  \nThe 0x0 Container handles incoming commands/data for the host of the Snake infection. Commands \nwill be queued in this Container until the implant is ready to execute them.  \n                                                \n15MITRE ATT&CK IDs: [T1104 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 14 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    0x1 Container  \nThe 0x1 Container handles outbound commands/data for the host of the S nake infection. The data \nwill be queued within the 0x1 Container until the implant is ready to exfiltrate them.  \n0x2 Container  \nThe 0x2 Container holds the configuration information for the mode to which it corresponds. Various \npieces of information vital to  Snakes successful operation are stored within these Containers. This \nsubsection will discuss a subset of the parameters that can be found within the 0x2 Container.  \n \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 15 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Pivotal key information can be found within the 0x2 Containers. This includes the inboun d and \noutbound RSA keys (Items 0x228 and 0x227 , respectively), the CAST key (Item 0x229) used to \nencrypt the individual items within the Queue Container, pre -shared keys used for the top layer of \nencryption in Snakes network communication protocol, and a quasi -unique value for the implant, \ncalled the ustart value, needed for Snake network connectivity.  \nSnake is constantly passing data between its kernel and user mode components. The methodology \n(generally, named pipes) used to make these communications i s listed in Items 0x65 -0x6f of the 0x2 \nContainer. Items 0x70 -0x7a list the parameters necessary to establish these communications.16 \nItems 0xc9 -0xd3 contain details of up to ten  other Snake infections, referred to as communication  \nchannels, which  the impl ant can communicate with during Passive Operations. The parameters \nneeded to establish Snake sessions with the other hosts can be found in Items 0xd4 -0xde.  \nMany additional data points , such as the process name where Snake injected itself or the modules \nSnake has loaded from its 0x3 Container , can be found within 0x2 Containers.  \n0x3 Container  \nThe 0x3 Container houses embedded files and modules for Snake. A single 0x3 Container will be \naccessible to all Containers in the Queue. The 0x3 Container has its own d edicated 0x2 Container \nthat only includes a single Queue Item of Item Type 0x229 (a CAST -128 key). This key will be used to \nencrypt  and decrypt all of the embedded files and modules within the 0x3 Container.  \n \n                                                \n16 MITRE ATT&CK IDs: [ T1559 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 16 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    The Item Types  assigned to the embedded files and modules within the 0x3 Container are consistent \nacross all of the Snake infections within Snakes P2P network. For example, the 0x01 Item Type is \nthe Zlib library, and therefore any time an Item Type of 0x01 is seen with in the 0x3 Container of a \nSnake infection, that file is always the Zlib library. The implants 0x2 Container will keep track of \nlibraries that it has loaded. If the DLL is a file on disk, the full path to the DLL is saved in the 0x2 \nContainer. If the libra ry was loaded from a 0x3 Container, the loaded module will be displayed in the \nimplants 0x2 Container in the format &<Item Type (within 3 container) of loaded module>.17 \n0x4 Container  \nThe 0x4 Container logs command activity. Each Queue Item within the Container is a log of a single \nexecuted or attempted  command. Each mode will have its own corresponding 0x4 Container.  \n0x5 Container  \nThe 0x5 Container holds Snake network logs, noting any IP address that has connected to this \nimplant. Some versions of Sn ake no longer make use of this C ontainer.  \n0x6 Container  \nThe 0x6 Container saves commands that are set to execute at specific times. A Queue Item is \ncreated for each scheduled command.  \n0x7 Co ntainer  \nThe 0x7 Container logs the IP addresses of any other Snake i mplants  that have connected to this \nimplant during Passive Operations. The commands 0x79 (Read Agents Track) and 0x7a (Clear \nAgents Track) are used to interact with this C ontainer. Note th at the command 0x7a had been \ndeprecated in some versions of Snake and returns the error function unsupported if called.  \n  \n                                                \n17 MITRE ATT&CK IDs: [ T1055.001 ] \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 17 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    SNAKE NETWORK COMMUN ICATIONS  \nSnake s network communications are encrypted, fragmented, and sent using custom methodologies \nthat ride  over common network protocols , including both raw TCP and UDP sockets and higher -level \nprotocols like HTTP , SMTP , and DNS . Snake s protocols for HTTP and TCP are the most commonly \nseen, but functionality exists  for UDP , ICMP, and raw IP traffic . Snake s network communications are \ncomprised of sessions, which are distinct from the sessions associated with the legitimate protocol it \nis riding on top of  (e.g., TCP sessions ). The  Snake session is then comprised of distinct commands. \nBoth Snakes custom tra nsport encryption layer  (enc) and Snakes Application Layer have their own \nencryption mechanisms, where  the enc layer operat es on an individual P2P session and the Snake \nApplication Layer provid es end-to-end encryption between the controller (i.e., point  of origin) and the \ncommands ultimate destination. The following  figure  details Snake s communication protocol stack .18 \n \nNetwork Obfuscation  \nSnakes use of its kernel module also facilitates stealthy network communications. To participate fully \nin Snake s P2P network, implanted machines which are not the ultimate target must act as servers for \nother Snake nodes. Snakes kernel module, along with a thoughtfully designed mechanism for \ndistinguishing Snake traffic from legitimate client traffic, allows the im plant to function as a server in \nthe Snake P2P network without opening any new ports, greatly complicating detection efforts. \nAdditionally, Snakes custom network communication protocols are designed to blend with traffic that \nthe compromised server normal ly would receive. This allows Snake operators to u se legitimate \nservers as infrastructure, which reduces the effec tiveness of simple IP address or domain blocking \nwithout needing to open new ports or send unusual looking traffic to this infrastructure.19 \nSnakes Network Authentication Technique ( ustart ) \nSnake uses its custom HTTP and raw socket TCP based protocols for large data communications.  \nWith these protocols and others,  Snake employs a specific authentication mechanism to distinguish \nSnake traffi c from legitimate traffic destined for application software on the compromised server. This \n                                                \n18 MITRE ATT&CK IDs: [ T1001.003 ], [T1071 ], [T107 1.003 ], [T1090.003 ], [T1095 ], [T1132 ], [T1572 ], [T1573 ] \n19 MITRE ATT&CK IDs: [ T1001.003 ], [T1071 ], [T1132.002 ], [T1547.006 ], [T1584 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 18 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    technique enables one of the uniquely sophisticated aspects of Snake, which is its ability to function \neffectively as server software without opening any further po rts on the compromised system. The \nrelevant per -implant authentication value is referred to as the ustart and is stored in the implants \nQueue File. There are multiple forms of the ustart value, including ustart, ustart2, and ustartl.20 \nRather than open a listening socket on a specified TCP port, the Snake kernel module intercept s the \nfirst client -to-server packet following the 3 -way handshake in every TCP session. The kernel module \nthen determines whether or not the contents of that packet are in fa ct valid for the ustart value of that \ntarget Snake implant. If so, the Snake kernel module forwards that packet and any future packets in \nthe same TCP session to Snakes own processing functionality, and the (presumably legitimate) \napplication listening on  that port remains unaware of this TCP session. If not, the Snake kernel \nmodule  allows the packet and the rest of the TCP session as it occurs to reach the legitimate \nlistening application, for example web server software. See the following  for an illustra tion.21 \n \nAll of the ustart versions perform authentication by sending a random nonce along with data that \ncomprises a mathematical operation on the combination of the nonce and the ustart value itself. The \n                                                \n20 MITRE ATT&CK IDs: [ T1132.002 ], [T1572 ] \n21 MITRE ATT&CK IDs: [ T1071.001 ], [T1547.006 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 19 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    receiving machine then extracts the nonce  and performs the same computations  to authenticate the \nsending machine. The ustart2 and ustartl versions  use the Fowler -Noll-Vo (FNV) hash algorithm to \ngenerate the overall authentication value from the nonce and the ustart. This mechanism is slightly \ndifferent in  the custom Snake HTTP protocol versus the custom Snake TCP protocol.  \nUsing the ustart methodology, a node in the Snake P2P network can function as a server without \nopening any otherwise closed ports and without interfering in the compromised servers legi timate \nfunctionality. Snake will only communicate over TCP ports on which another application is actively \nlistening. This technique makes detecting Snake compromises through network traffic monitoring far \nmore difficult. Inbound traffic to an unexpected TC P port can be detected or blocked using standard \nfirewall or network intrusion detection functionality. Replacing a legitimate service application with a \nmodified executable can lead to detection at either the host or network level. Snakes technique \nbypas ses both of these mitigations. When combined with the fact that Snake traffic looks similar to \nexpected traffic, especially in the case of Snakes HTTP based protocols, this renders detecting \nSnake communications difficult absent detailed knowledge of Snak es custom protocols.  \nSnake UDP  \nOutbound Communications via DNS Query  \nSnake uses a specialized communications protocol to encode information in seemingly standard DNS \nqueries run via the Windows or POSIX API function gethostbyname, depending on the version.22 \nSnake outbound DNS requests consist of character strings that are constructed to resemble standard \ndomain names. The actual information being transmitted from the implant is contained in the part of \nthe character string prior to the first . character. Fo r illustration  purposes , this subsection will outline \nhow an arbitrary string of bytes is manipulated and then encoded to form an outbound Snake DNS \nrequest carrying data provided by the implant.  \nSnake outbound DNS requests originally take the form of byte  arrays stored on the stack as the \nimplant progresses through the communications function. The byte array has the following structure . \n \nOnly the low -order seven bits of the flags byte are used, and they have the following significance . \n                                                \n22 MITRE ATT&CK IDs: [ T1001.003 ], [T1071.004 ], [T113 2.00 2] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 20 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR     \nAfter calculating  and obfuscating the byte array values shown above, Snake encodes these byte \nvalues as de -facto base32 text, using the ten digits 0 -9 and the 26 lowercase ASCII letters a -z, with v, \nw, x, y, and z all corresponding to the same value, as only 32 distinct ch aracters are needed. Snake \nthen inserts - characters at specified locations and sends the DNS request using the gethostbyname \nfunction. The resulting encoded string mimics a legitimate DNS request; because characters after the \nfirst . are not part of t he implants communications, any arbitrary suffix (e.g. , .com) can be used.23 \nInbound Communications via DNS Query Response  \nAfter sending the encoded DNS request, Snake parses the retu rned information. In a normal DNS \nrequest, the returned hostent structu re contain s a list of IPv4 addresses as 32 -bit unsigned integers if \nthe domain resolves to one or more IPv4 addresses. In the Snake DNS protocol, these 32 -bit integers \nrepresent the covert channel data. The Snake implant sorts the 32 -bit integers by the hi ghest order \nnibble and then interprets the remaining 28 bits of each integer as the actual encoded data.  \nThe Snake DNS protocol thus  provides a well -concealed, low -bandwidth communications channel.  \nFor larger bandwidth communications, Snake uses its custo m HTTP and TCP protocols.  \nSnake HTTP  \nThe most common custom protocol that Snake uses is its http protocol, which rides on top of \nstandard HTTP. It generally looks like normal HTTP comm unications, including a lot of b ase64 -\nlooking strings, thus blending well with normal network traffic. There have been multiple iterations of \nSnakes http protocol, though the differences are only in the encoding; once that is peeled away, the \nunderlying Snake http protocol is the same. For the purposes of this document, Sn akes former \nversion of HTTP will be referred to as http and its more recent version as http2.24 \nSnake c ommunications using  http2 are contained within seemingly legitimate Application Layer HTTP \ncommunications. In the client -to-server direction, the imp lant data is contained within an HTTP header \nfield of a GET request, unless the data is over a certain size  (usually 256 bytes, but configurable). \nObserved field keys have  include d: Auth -Data, Cache -Auth, Cookie, and Cockie (note misspelling) . \nThis list is  not exhaustive ; any standard HTTP header field c an be used. The communication itself is \ncontained in the legitimate HTTP header fields value, meaning the content following the : character \nand any whitespace immediately thereafter. In HTTP GET requests,  the implant generally uses the \ndefault path /, but this is not required and is configurable.25 \n                                                \n23 MITRE ATT&CK IDs: [ T1001.003 ], [T1071.004 ], [T113 2.00 2] \n24 MITRE ATT&CK IDs:  [T1001.003 ], [T1071.001 ], [T1572 ] \n25 MITRE ATT&CK IDs: [ T1001.003 ], [T1071.001 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 21 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Larger client -to-server Snake http2 requests are contained in the body of an HTTP POST request, \nand server -to-client communications are contained in the body o f the HTTP response.  \nAll client -to-server Snake http and http2 requests begin with the ustart auth entication. The specifics \nvary with each ustart version, but in each case the random nonce and the computed function of the \nnonce and ustart value are encoded  in a manner which closely resembles the rest of the Snake \ncommunication. Since Snake http and http2 implant sessions can span multiple TCP sessions, the \nustart authentication mechanism is included in every client -to-server communication.  \nBase 62 Encoding  \nSnake s http2 protocol u ses a custom base62 encoding scheme that has the following differences \nfrom base64 . Base62 uses 62 semantically significant characters instead of 64 . The ratio of encoded -\nto-decoded characters in base6 2 is less dense (11:8) than the ratio base6 4 can achieve  (12:9) . Also, \nbase62 uses extraneous characters in certain instances that have no semantic significance.26 \nThe base62 characters of semantic significance are the 62 strict alphanumeric characters: [0 -9A-Za-\nz]. The extraneous charact ers that can be present in a base62 stri ngbut whic h have no semantic \nsignificance are: /, ;, =, and _ (underscore ). When present, these characters are removed prior \nto performing the decoding process. A valid base62 string can have up to 11 of these extraneous \ncharacters. A regular expression for base62 is included  in the Mitiga tions section of th is CSA. \nhttp and http 2 Metadata Structure  \nAfter the base62 decoding is completed, if necessary, the remaining data begins with an 8 -byte \nmetadata structure that provides rudimentary sessionization on top of the stateless HTTP. Snake s \nhttp and http2 client -to-server communicat ions have  three de -facto parts, which are concatenated into \na single HTTP header valu e. These parts are: 1) an announce or  authentication string, 2) a custom \nmetadata structure, and 3) payload data. The metadata structure consists of the following:  \nstruct http_meta { \n  uint32_t session_number;  \n  uint16_t communication_number;  \nuint8_t flags;  \nuint8_t checksum;  \n}; \n \nSnake uses t he session_number and communication_number fields to provide its own custom \nsessionization on top of the stateless Application Layer HTTP protocol. The checksum byte serves to \nvalidate the integrity of the structure and must equal the sum of the first seve n bytes modulo 256.  \nSnake TCP  \nSnake  has the ability to communicate through POSIX -style TCP sockets. The implant s custom TCP \nprotocol, which herein will be called tcp, uses the reliability features of the underlying TCP protocol.  \nThus, in the implants custom tcp protocol, the concept of a TCP session and an implant session  are \nthe same, whereas in the implant s custom http protocols, one implant session could span multi ple \n                                                \n26 MITRE ATT&CK IDs: [ T1132.002 ], [T1572 ] \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 22 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Transport Layer TCP sessions. Since the implants overall communications protocol is based on the \nidea of commands and responses, Snake depends on being able  to specify  the length of any given \ncommand and  response so the recipient Snake node knows when  a particular communication ends. \nSnake achieves this in the custom tcp protocol by prefacing each communication with its length \nencoded as a 32 -bit big -endian unsigned integer.27 \nImmediately following the TCP 3 -way handshake, the implant completes the usta rt authentication for \nthis session. Since Snake tcp sessions are mapped one -to-one with an underlying protocol TCP \nsession, the ustart authentication only occurs once per session, rather than with each client -to-server \ncommunication as in Snake http and ht tp2. The Snake tcp ustart mechanism is similar to the Snake \nhttp and http2 mechanisms, except that for certain ustart versions,  Snake tcp u ses a raw binary ustart \nwhich is not encoded in printable characters.  \nAfter the ustart authentication, the implant wi ll begin sending length -data pairs. These pairs can be \nsent in the same packet or in two (or theoretically more) separate packets, but the pattern of length -\ndata pairs will be present in each h alf of the stream  (i.e., each direction)  for the entirety of th e implant \ncommunications for the remainder of the TCP session. Specifically, a length -data pair will consist of \nthe length encoded as a big -endian 32 -bit unsigned integer followed by data of exactly that length.  \nFor example, consider the instance where the  implant is sending the following 4 arbitrary bytes:28 \n89 ab cd ef  \nThe on -wire communication from the implant would send the integer value 4 encoded as a big -endian \n32-bit integer, followed by the actual 4 bytes themselves, as shown below. This could be spl it across \ntwo (or theoretically more) packets.  \n00 00 00 04 89 ab cd ef  \nThe custom tcp protocol (as well as all custom http protocols) have been used in conjunction with the \nSnake enc protocol. Details of the Snake enc protocol are provided in the following  subsection. Due \nto the manner in which the Snake enc and Snake tcp protocols interact, the first six length -data pairs \nof each TCP half -stream (following the si ngle client -to-server announce or  authentication packet \ndescribed above) will have known length s. Specifically, each half -stream will begin with length -data \npairs of the following lengths: 0x8, 0x4, 0x10, 0x1, 0x10, 0x10. Note that these are the lengths of the \nraw data, so each communication will be preceded by a 4 -byte big -endian integer specifying  the \ncorrespondi ng length. Thus , one of the half -streams could  have the following TCP content:  \n00 00 00 08  12 34 56 78 9a bc de f0  \n00 00 00 04  89 ab cd ef  \n00 00 00 10  12 34 56 78 9a bc de f0 12 34 56 78 9a bc de f0  \n00 00 00 01 12  \n00 00 00 10 12 34 56 78 9a  bc de f0 12 34 56 78 9a bc de f0  \n00 00 00 10 12 34 56 78 9a bc de f0 12 34 56 78 9a bc de f0  \n                                                \n27 MITRE ATT&CK IDs: [ T1001.003 ], [T1071.001 ] \n28 MITRE ATT&CK IDs: [ T1132.002 ] \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 23 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Snake enc Layer  \nAs described above , Snake communications are all comprised of Snake sessions, irrespective of \nwhichever legitimate protocol Snake is operating  on top of. Snakes top layer of encryption, called the \nenc layer, utilizes a multi -step process to establish a unique session key. The session key is formed \nthrough the combination of a Diffie -Hellman key exchange mixed with a pre -shared key (PSK) known \nto both parties. This PSK is stored in one of the communication channels, stored within the Queue.29 \nThe overall establishment of the session key requires 12 communication steps, six in each direction, \nwhich involve sharing the pseudo -random values used in t he Diffie -Hellman exchange process as \nwell as custom aspects of the Snake session key derivation method. The session key is used to \nencrypt the command headers and (inner) encrypted payloads.  \nThis is the layer in which the critical error of providing a val ue of 128 bits instead of 128 bytes for the \ncall to DH_generate_parameters within the OpenSSL library occurred. Due to this insufficient key \nlength, breaking the Diffie -Hellman portion of the exchange is possible.  Note that in the following \nfigure, the var iables p, g, a, and b are used in  standard descriptions of Diffie -Hellman.  \n \n  \n                                                \n29 MITRE ATT&CK IDs: [ T1573 ], [T1573.002 ], [T1610 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 24 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    SNAKE APPLICATION LA YER \nSnake s Application L ayer is used to process Snake commands. The payload data for a Snake \nsession can contain one or more command exchanges, whic h include both the incoming data sent to \nthe implant as well as the response returned to the server. Each command is associated with a \nspecific ordinal, and due to Snake s modular design, operators are able to add new commands to \nextend Snake s capabilitie s by remotely loading a new module.  \nThe Snake implant differentiates between High and Low commands and handles them differently, \nbased on the ordinal number range. The majority of Snake commands are High commands that have \nan ordinal of 0x64 (100 decimal) or higher. There are far fewer Low c ommands, and these include the \nForwarding command (with ordinal 0x1), and the four Queue commands (with ordinals 0xa, 0xb, 0xc, \nand 0xd). While Low commands are mostly used for moving data across the network, the High \ncommands give the operator many option s for inter acting with an infected system.30 \nCommand 0x15 -byte Header  \nAll commands begin with a 0x15 -byte header , followed by optional command parameter data ; only \nsome commands require parameters for successful execution. For example, the command Get, whic h \nexfiltrates a file, requires the name of the file to exfiltrate, whereas the command Process List, which \nreturns a process listing, does not require any parameters.31 \nThe most important Command Header field contain s the integer ordinal of the command bein g sent. \nThe Item UID field represents a unique identifier for each individual command instance, and these \nvalues increase sequentially. The header has two fields used when a command is set to run at a \nspecified date and time; these commands will be written  to the 0x6 Container.  \nSome Low commands have another  header before the payload data, which will be detailed below. All \nother commands have only the Command Header followed by the encrypted parameter data.  \n \nCommand Encryption  \nUnderneath Snake http2 or tcp  encryption  at the session layer , each command exchange is further \nencrypted. In older versions of Snake, the exchanges were CAST -128 encrypted using a different key \nfor incoming and outgoing data. These keys w ere saved in the 0x2 Container in the  0x227 an d 0x228 \n                                                \n30 MITRE ATT&CK IDs: [ T1001 ], [T1104 ] \n31 MITRE ATT&CK IDs: [ T1074 ], [T1119 ], [T1560.003 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 25 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Items. The incoming payload data, if parameter data was present, could be decrypted with the 0x227 \nCAST key. Any response data was encrypted with the 0x228 CAST key.32 \nIn recent versions, the 0x227 and 0x228 Items hold two RSA -4096 public keys. For each side of a n \nexchange, a new 16 -byte CAST key is created with Microsoft s CryptoAPI CryptGenRandom function \nto obtain 16 random bytes. This key is used to CAST -128 encrypt the parameter or response data.  \nFor an incoming command, the CAST key is signed ( not encrypted) by the private key corresponding \nto the public key on the node to create a 512 -byte RSA data blob. The incoming payload has the RSA \nblob, followed by the optional parameter data, which is CAST -128 encrypted. Snake uses the 0x227 \nRSA public k ey to decrypt the RSA blob, recover the CAST key, then decrypt the parameter data.  \nFor an outgoing command, a new CAST key is obtained from CryptGenRandom, and any response \ndata is CAST -128 encrypted. The key is then encrypted using the 0x228 public key to  create a 512 -\nbyte data blob. The response payload data contains the 512 -byte RSA blob, followed by the \nencrypted response data, when present.  \nCommand Decoding  \nThe implant will expect data in a specific format for each command ordinal. Parameter and response \ndata contain several possible underlying data types, including wide -character plaintext strings, \nnumeric values, data tables, files, or a combination of multiple types.33 \nThe parameter data buffer itself will be formatted in a specific way, dependi ng on the command \nordinal. Some commands have required parameters, as well as optional parameters. Commands with \noptional parameters will include a metadata header with the data length and data type (e.g. , bool, \ninteger, text, or data buffer) before the op tional parameters data. Other commands will expect the \nparameters to be formatted with length -data pairs, consisting of the parameter data length encoded \nas a four -byte big -endian integer followed by data of exactly that length. Still other commands have a \ncustom header or will expect no length or metadata and will simply send the parameter data alone.  \nThe response data will similarly be formatted by the implant in a specific way according to the \ncommand ordinal. The response data typically does not have a  length or metadata preceding it, with \nthe exception of the data tables. Examples of commands that return a table are the Process List \ncommand and the List Dir command.  \nResponse data that includes a table will start with a table description header that ind icates the \nnumber of columns and rows in the table. In addition, the header will include a Column Descriptor \nstructure to indicate the type of data that column will contain, for example  a string, uint32 or uint64, \ntimestamp in epoch format, or the contents  of a whole file (included as a table entry).  \nAfter  the table description header, each field is added to the data payload buffer one at a time in a \nlength -data pair. The fields across the first row are added in order, then the fields across the second \nrow are added immediately after the first row with no metadata or separation, and so on. To parse this \ntable, the server will account for the number of columns to determine where the next row starts.  \n                                                \n32 MITRE ATT&CK IDs: [ T1573 ] \n33 MITRE ATT&CK IDs: [ T1132.002 ] \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 26 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    High Commands  \nHigh commands are those with an ordinal of 0x6 4 (decimal 100) or higher. High commands give the \noperator many options for interacting with an infected system, as well as implant components. This \nsubsection will describe some examples of the many High commands that can exist in the implant.  \nSome of the  most basic High commands will gather information about the machine and return the \nresults. For example, the FSB operators can use the PS command (0x65) to return a list of running \nprocesses, the List Dir command (0x840) to list the contents of a directory , or the Syst command \n(0x6b) to gather basic system information.  \nThere are several commands that interact with the infected machine using standard built -in OS tools. \nThe operator can use the Kill command (0x67) to kill a process, the Get command (0x68) to exfiltrate \na file, the Put command (0x69) to write a file, the Del command (0x6a) to delete a file, or the Run \ncommand (0x66) to execute a command in a terminal shell and receive the results. For example, \noperators have used the Run command to run PowerShe ll commands, ping other hosts, use the \nWindows net use command to map network drives, and to run executable files that had been \npreviously written to the node using the Put command.34 \n \n                                                \n34 MITRE ATT&CK IDs: [T1059.001 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 27 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    In addition to commands that use the built -in OS functionality, there  are several High commands that \ninteract with Snake components. An operator can use the Read Config command (0x70) to read the \n0x2 Container, which contains configuration data, or the Set Config Item command (0x71) to set a \nspecific Queue Item within the 0 x2 Container. For example, operators have used the Set Config Item \ncommand to add or update the IP  addresse s or domains and option parameters used to communicate \nwith other Snake nodes. The Read Agents Track and Clear Agents Track commands (0x79 and 0x7a) \ninteract with the 0x7 Container to read or delete logs which track which other Snake nodes have \nconnected to this node. Note that t he 0x7a command has been deprecated in some versions of \nSnake and returns the  error function unsuppo rted if called.  \nSnake  has the ability to add additional commands by loading new modules. New modules can be \nloaded using the Load Modules command (0x72) or directly into memory using the Load Modules \nMem command (0x7f). When compiling a module, the develo per will assign an ordinal to each \nconstituent command, which will then be used by the operator to call the newly added commands. \nThese loaded modules can be removed using the Module Unload command (0x73).  \nQueue Commands  \nThe Snake commands with ordinals 0x a, 0xb, 0xc, and 0xd are used to enumerate, read, write, and \ndelete items from the 0x0 or 0x1 Queue Containers, respectively. Note that these commands are not \nused to manipulate any other Containers.35 \nQueue Command Header  \nThe four Queue commands contain a 0x3d -byte Queue Header following the Command Header. In \nmore recent versions o f Snake, this header is encrypted using the same CAST key used to encrypt \nthe payload data. In this case, the Command Header is followed by the 512 -byte RSA encrypted \nCAST key bl ob, the encrypted Queue Header, and finally the encrypted payload data.36 \n \nEven though each of the four Queue commands only use a subset of the fields of the Queue Header \n(in different ways), the full header must be present for the command to be considered  valid by the \nimplant. Two fields in the header that all four Queue commands use are the Container Instance and \nContainer Type  fields , which indicate  the specific Container on a node the Queue command intends \nto interact with. In the Queue Read and Write commands, the Item Type field is used to track the \nspecific commands and their responses in the Containers.  \n                                                \n35 MITRE ATT&CK IDs: [ T1001 ], [T1104 ] \n36 MITRE ATT&CK IDs: [ T1573 ] \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 28 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Queue Enumerate Command  \nThe Queue Enumerate command, with ordinal 0xa, is used to enumerate the contents of the 0x0 or \n0x1 Containers to list all inc oming or outgoing commands, respectively. The enumeration returns the \n0x40 -byte structure described above for each Queue Item, concatenated into a single return buffer.  \nQueue Read Command  \nThe Queue Read command, with ordinal 0xb, is used to read an Item fr om the specified 0x0 or 0x1 \nContainer. Several relevant fields in the Queue Header determine ho w the data is sent and stored. \nFor example, the header determine s whether the data should be sent immediately back to the server \nor stored for later transport. The header indicates if the implant should send the Queue Items header \n(i.e., the same 0x40 -byte metadata structure returned by the 0xa command), the Items dat a, or both. \nThe header also indicates whether the Queue Item should be deleted after being read and can also \nindicate that Queue Items with a lower Item Type should be deleted. This allows FSB operator s to \nclear out all command Items previous to the one be ing read.  \nQueue Write Command  \nThe Queue Write command, with ordinal 0xc, is used to write a Queue Item to the specified 0x0 or \n0x1 Container. The Queue Header will indicate if a new Queue Item will be created, or an existing \nQueue Item will be modified.  \nIf a Queue Item is set to be modified, an Item with the specified Item Type must exist in the specified \nContainer. Several fields in the header must match specific attributes of the existing Queue Item. If \nthese checks are met, the parameter data is written to the Queue Item. Fields in the Queue Header \nwill indicate the length of data to be written, and the offset into the existing Queue Item where the \nwrite should begin.  \nIf a Queue Item is set to be created, Snake  will delete existing Queue Items of the spec ified Item \nType in the Container of interest , then create a new Item of the specified Item Type and write the \nparameter data to the Queue Item. A field in the Queue Header will indicate the length of data to be \nwritten.  \nQueue Delete Command  \nThe Queue Delet e command, with ordinal 0xd, is used to delete a Queue Item from the specified 0x0 \nor 0x1 Container. The Flags field will determine if the single Queue Item should be deleted, or if all \nQueue Items with a lower Item Type should be deleted as well.  \nForward Commands  \nForward commands, with command ordinal 0x1, are used to tell an implant to forward a Snake \ncommand to a second target node, where the command will be executed. The target node sends the \nresponse data back to the first implant, which will then pack age that response data as its own \nresponse back to the caller.  \nThe command is designed to tell an implant to forward one command to another implant, but in \npractice, Forward commands are often built on top of each other to create a chain of hop points that  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 29 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    will continue to forward a command to an end point, where it will be executed. The response data is \nthen sent back through the same chain of hop points until it reaches the operator.37 \nThe Forward command has a 0x199 -byte Forward Header, followed by the en crypted command \nparameter data that will be sent to the target node of the Forward command. The Forward Header \ncontains the information the implant will need to connect to the target node, including the ordinal of \nthe Snake command that is being forwarded to the target node for execution.  \nThe implant that receives the Forward command will construct a new Snake command of the ordinal \nindicated in the Forward Header. It will connect to the target node in a new session, construct the \nCommand Header, and send t he encrypted command parameter data on to the target node. The \nparameter data already will have been  encrypted using the key associated with the target node, so \nthat the target implant will be able to decrypt the parameter data and execute the command.   \nWhen the Forward command is constructed, the CAST key used to CAS T-128 encrypt the payload \ndatato include the 0x199 -byte header and the parameter data to be forwarded is encrypted with \nthe RSA key pair used by the first implant. The parameter data that co ntains the parameters for the \ncommand to be forwarded is also CAST -128 encrypted, but the key used to encrypt the parameter \ndata is encrypted with the RSA key pair used by the target node. The first implant knows through the \nheader what command ordinal it is forwarding, but it is unable to decrypt the parameter data.  \nIf the Forward Header sent to the first implant indicates that the command to be forwarded was \nanother Forward command, the first target node will decrypt the parameter data and find another \nForward Header. This first target node implant will then go through the same process to connect to \nthe next target node, constructing the new command with the ordinal indicated in the second Forward \nHeader to send the remaining encrypted parameter data to th e next target node. This will repeat until \nthe command to be forwarded is something other than another Forward command.  \nThe Command Header and pertinent parameters for each target node are encrypted specifically for \nthat node by the operator before the For ward command is sent into the Snake P2P network. To \nillustrate, the diagram below  shows how the buffer might look when several Forward commands are \nchained together to include two hop points and an end point. The first hop point (HP1) will recover the \nfirst CAST key and CAST -128 decrypt the rest of the buffer, which will uncover the first Forward \nHeader. HP1 will then forward the remainder of the decrypted buffer to the next hop p oint (HP2), \nstarting with the second CAST key blob. HP2 will recover the secon d CAST key and CAST -128 \ndecrypt the rest of the buffer, which will uncover the second Forward Header. HP2 will then forward \nthe remainder of the decrypted buffer to the end point, starting with the third CAST key blob. The end \npoint will recover the CAST k ey, decrypt the command parameter data, and execute the command.   \nWhen a target machine has executed a forwarded command, the return data is encrypted with that \nimplants RSA keys and returned directly to the previous hop point. As the data is returned  up the \nchain in the Snake P2P network , the intermediate hop points do not manipulate the encrypted data, \nas they do not have the RSA private key necessary to do so. In this manner, the return data is de -\nfacto end -to-end encrypted throughout the P2P network until it arrives back at the FSB operator.  \n                                                \n37 MITRE ATT&CK IDs: [ T1090.003 ], [T1573 ] \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 30 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR     \n  \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 31 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    SNAKE IMPLANT OPERAT ION \nSnake u ses two main methods for communication and command execution, namely Passive and \nActive. In general, Snake operators will employ Active operations to communicate with hop points \nwithin Snake s infrastructure ; however , hop points can and do sometimes operate using Snake s \nPassive method. Snake s end points tend to solely operate using the Passive method.38 \nActive Operations  \nDuring Active operations, Snake commands are issu ed by an FSB operator or a script to a target \nmachine, generally through Forward commands (described in the previous section ). The response to \nthe command is immediately returned to the point of origin following the same path that the command \ntook to reach  its end target, as shown in the previous figure on Forward command structure . \nPassive Operations  \nDuring Passive operations, Snake implants  operate on their own, without the synchronous interaction \nof FSB operators. The nodes with which an implant communic ates during Passive operations are \nstored within its 0x2 Container(s) as communication channels. Up to ten communication channels can \nbe present at any time ; an operator can change these channels via the Set Config Item command.  \nPassive Intake  \nDuring Passive operations, the implant will beacon by sending a Queue Read (0xb) command to one \nof its stored communication channels that it has chosen at random. These Queue Read commands \nlook for a Queue Item within a Container with an Instance Number eq ual to the implants UID. The \nmatching UID indicates the Queue Items in this Container are intended for the beaconing implant.  \nIf such a Queue Item is found, the beaconing implant will read in the Queue Item and delete it off of \nthe host from which it was read. There can be multiple Queue Items found within the specified Queue \nContainer that was beaconed to; each Queue Read command will read one of these items. This \nprocess is repeated until all items within the Container are read, which the infrastructure node will \nindicate by sending a specific error in response to the Queue Read.  This beaconing will continue to \nrandomly select hosts at nondeterministic time intervals for as long as the implant is set to perform \nPassive operations.  \nPassive Data Exfiltratio n \nSimilar to how Snake intakes commands passively, it can also  exfiltrate the resulting data passively. \nThis is done  using Queue Write (0xc) commands to write to one of the stored communication \nchannels chosen at random. Once the data is off the end point node, operators generally retrieve it \nmanually or using a script. The Item Type field, which is unique per executed Snake command, is \nneeded  to associate the exfiltrated data with the target node on which the command was run.  \nIn the context  of Passive Snak e communications, the term Item Type is defined as a UID for a given \nSnake command and its resulting data. The Item Type serves as a unique identifier to associate the \nresults of command execution with the original command written by the operator. When the  FSB \n                                                \n38 MITRE ATT&CK IDs: [ T1104 ] \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 32 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    collects the data, Snake knows exactly what infection the data came from, and therefore it can \ndetermine what key to use to successfully decrypt the data.  \n \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 33 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    To illustrate how Passive operations are conducted between the end points, the operator,  and t he hop \npoints in between, see the diagram above , which is explained further by the following steps:39 \n (1), (2): During Passive operations , the Node randomly chooses a host from amongst its \nstored communication channels and will beacon out to it with a Queue  Read command (Hop \nPoint 1 in this case). The Item Type for these beacons will be one greater than the Item Type \nof the last command received by the Node, indicating in this example that a command of Item \nType 0x08 was the last command that was read in by the Node during Passive operations. \nThis Node will continue to beacon with Item Type 0x09 until it receives a command, via \nPassive operations, with an  Item Type of 0x09 or greater. The lines are dotted for (1) and (2) \nas this activity will be repeated at random intervals until a successful Queue Read occurs.  \n \n (3), (4): In these steps, the operator uses a Queue Write command to write a command to Hop \nPoint 140 that is ultimately intended for the Node. The Item Type of the command being written \nto Hop Point 1 is assigned 0x20 (for this example). Note that the path of this command, its \nexecution, and its results making it back to the operator can be tracked via the red text.  \n \n (5), (6): The Node continues to beacon out looking for commands to read in (5). The return (6) \nis successful , and the command written by the operator to Hop Point 1 (3) is read in by the \nNode, then deleted from Hop Point 1.  \n \n (7), (8): Th e Node attempts another Queue Read to Hop Point 1, however now the Item Type \nis set to 0x21, one greater than the command that was just read in by the Node at (5) and (6). \nThis returns an error as Hop Point 1 has nothing else for the Node to read in, indic ating to the \nNode that everything at Hop Point 1 was read.  \n \n (9), (10): At this point , the Node has executed the command it read in at (5) and (6) and is \nattempting to send back the results. The Node randomly selects another host from its stored \ncommunication channels, Hop Point 2 in this case, and sends out a 0xb command to make \nsure that the Item Type 0x20, the Item Type of the command it executed, does not already \nexist within the Queue of Hop P oint 2. If it receives an error, there is no Item with Item Type \n0x20 on Hop Point 2, and the Node can proceed to send the command results.  \n \n (11), (12): Here the data from the executed command is written to Hop Point 2 with Item Type \n0x20 into its 0x1 Cont ainer  with a 0xc command , the Item Type the command was initially \ngiven at creation (3).  \n \n (13), (14): The Node continues its normal beaconing routine again as seen in (1) and (2), \nsearching for Item Type 0x21, one greater than the Item Type of the most rec ently executed \n                                                \n39 MITRE ATT&CK IDs: [ T1090.003 ], [T1104 ] \n40 The operator knows that Hop  Point 1 is stored in the communications channels of the Node, thus the operator knows \nthat the Node will beacon out to Hop Point 1 at some point and be able to retrieve the data.  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 34 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    command. As in (1) and (2) , the lines here are dotted to denote that this process w ill repeat \nuntil there was a successful beacon as in (5) and (6).  \n \n (15-22): These steps show how the operator  retrieves the resulting data that was written to  \nHop Point 2. The Queue Enumerate command (15) lists the contents of Hop Point 2 s 0x1 \nContainer, showing the data written by the Node (11). This data is identifiable by its Item Type, \nnamely 0x20. The Queue Read command (17) reads in the I tem that was found in Hop Point \n2s Container. The Queue Read command that follows (19) is asking if there is any data left. In \nthis case, the entirety of the data was read with the first Queue Read (17, 18). Therefore, the \nerror returned from second Queue Read command  (20) lets the operator  know all of the data \nfrom Item Type 0x20 was read and there is nothing further. A Queue Delete command (21) \nfollows and is sent to delete the item with Item Type 0x20 from Hop Point 2.  \n \n The subsequent Queue Read, Queue Read, and Que ue Delete commands (17 -21) are \ndenoted with dashed lines to indicate that this sequence of commands is repeated for all items \nreturned from the Queue Enumerate command (15).  \n  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 35 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    MITIGATIONS  \nA number of complementary detection techniques effectively identify some of the more recent \nvariants of Snake. However, as described above, Snake is purpose -built to avoid large -scale \ndetection. Below is a discussion of the advantages and disadvantages of various detection \nmethodologies available for Snake.  \nNote that some of the techniques identified in this section can affect the availability or stability \nof a system.  Defenders should follow organizational policies and incident response best practices to \nminimize the risk to operations while hunting for Snake.  \nNetwork -Base d Detection  \nNetwork Intrusion Detection Systems (NIDS) can feasibly identify some of the more recent variants of \nSnake and its custom network protocols as detailed above.  \nAdvantages : High -confidence, large -scale (network -wide) detection of custom Snake com munication \nprotocols . \nDisadvantages : Low visibility of Snake implant operations and encrypted data in transit. There is \nsome potential for false positives in the Snake http, http2 , and tcp  signatures.  Snake operators \ncan easily change network -based signatures.  \nSnake http  \nSnake client -to-server http and http2 traffic is contained with in an arbitrary HTTP header field.  The \nheader field value for http begins with 10 pure alphanumeric characters, followed by base64 encoding \nof 8 bytes, which yields exactly 11 valid base64 characters plus one base64 padding character.  \n^[0-9A-Za-z]{10}[0 -9A-Za-z/\\+]{11}= \nThe following two Suricata rules will detect the traffic described:  \nalert http any any -> any any (msg: \"http rule (Cookie)\"; \\ \n    pcre:\"/[0 -9A-Za-z]{10}[0 -9A-Za-z\\/\\+]{11}=/C\"; \\ \n    flow: established, to_server; \\ \n    sid: 7; rev: 1;)  \nalert http any any -> any any (msg: \"http rule (Other Header)\"; \\ \n    pcre:\"/[0 -9A-Za-z]{10}[0 -9A-Za-z\\/\\+]{11}=/H\"; \\ \n    flow: established, to_server; \\ \n    sid: 8; rev: 1;)  \nSnake http2  \nThe header field value for http2 begins with 22 pure alphanumeric characters (base62 with no n-\nextraneous characters), followed by the base62 encoding of at least 8 bytes, which must comprise at \nleast 11 base62 characters with the four extraneous characters allowed. The actual requirement is \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 36 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    stricter than this expression, since the total number of non -extraneous characters alone must equal or \nexceed 11; however, it is not possible to encode that asp ect into a regular language.  \n^[0-9A-Za-z]{22}[0 -9A-Za-z/;_=]{11}  \nThe following two Suricata rules will detect the traffic described:  \nalert http any any -> any any (msg: \"http2 rule (Cookie)\"; \\ \n    pcre:\"/[0 -9A-Za-z]{22}[0 -9A-Za-z\\/_=\\;]{11}/C\"; \\ \n    flow: established, to_server; \\ \n    sid: 9; rev: 1;)  \nalert http any any -> any any (msg: \"http2 rule (Other Header)\"; \\ \n    pcre:\"/[0 -9A-Za-z]{22}[0 -9A-Za-z\\/_=\\;]{11}/H\"; \\ \n    flow: established, to_server; \\ \n    sid: 10; rev: 1;)  \nSnake tcp  \nThe client -to-server com munication for tcp must begin with the ustart, which is not captured in this \nsignature set. Immediately following the ustart, the next client -to-server communication must be the \nbig-endian 32 -bit unsigned integer 8 followed by any 8 bytes of data. The next  communication must \nalso be client -to-server, and it must comprise the big -endian 32 -bit unsigned integer 4 followed by any \n4 bytes of data. The next two communications must be server -to-client, comprising the integer 8 \nfollowed by 8 bytes of data and the integer 4 followed by 4 bytes of data.  \nThe following six Suricata rules will, in conjunction, detect traffic of the form described:  \nalert tcp any any -> any any (msg: \"tcp rule\"; \\ \n    content: \"|00 00 00 08|\"; startswith; dsize: 12; \\ \n    flow: established, to_server; flowbits: set, a8; flowbits: noalert; \\ \n    sid: 1; rev: 1;)  \nalert tcp any any -> any any (msg: \"tcp rule\"; \\ \n    content: \"|00 00 00 04|\"; startswith; dsize:8; \\ \n    flow: established, to_server; flowbits: isset, a8; flowbit s: unset, a8; \\ \n    flowbits: set, a4; flowbits: noalert; \\ \n    sid: 2; rev: 1;)  \nalert tcp any any -> any any (msg: \"tcp rule\"; \\ \n    content: \"|00 00 00 08|\"; startswith; dsize: 4; \\ \n    flow: established, to_client; flowbits: isset, a4; flowbits: unset, a4; \\ \n    flowbits: set, b81; flowbits: noalert; \\ \n    sid: 3; rev: 1;)  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 37 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    alert tcp any any -> any any (msg: \"tcp rule\"; \\ \n    dsize: 8; flow: established, to_client; flowbits: isset, b81; \\ \n    flowbits: unset, b81; flowbits: set, b8; flowbits: noalert; \\ \n    sid: 4; rev: 1;)  \nalert tcp any any -> any any (msg: \"tcp rule\"; \\ \n    content: \"|00 00 00 04|\"; startswith; dsize: 4; \\ \n    flow: established, to_client; flowbits: isset, b8; flowbits: unset, b8; \\ \n    flowbits: set, b41; flowbits: noalert; \\ \n    sid: 5; rev: 1;)  \nalert tcp any any -> any any (msg: \"tcp rule\"; \\ \n    dsize: 4; flow: established, to_client; flowbits: isset, b41; \\ \n    flowbits: unset, b41; \\ \n    sid: 6; rev: 1;)  \nHost -Based Detection  \nAdvantages : High confidence based on totality of positive hits for host-based artifacts.  \nDisadvantages : Many of the artifacts on the host are easily shifted to exist in a different location or \nwith a different name. As the files are fully encrypted, accurately identifying these files is difficult . \nCovert Store Detection  \nThe Snake covert store comprises a file -backed NTFS (usually) or FAT -16 (rarely) filesystem. The \nfilesystem is encrypted with CAST -128 in CBC mode. The encryption key can be either statically \nhardcoded or dynamically stored in a specified Windows registry l ocation. The IV is 8 bytes, since \nCAST -128 has an 8 -byte block length. The first byte of the IV for any 512 -byte block of the covert \nstore is the 0 -indexed block number. The remaining bytes of the IV are the corresponding bytes of the \nkey, meaning that byt es at 0 -indexed indices 1 through 7 of the IV are the bytes at 0 -indexed indices \n1 through 7 of the key.  \nWhen statically hardcoded, the encryption key has the following constant value:  \nA1 D2 10 B7 60 5E DA 0F A1 65 AF EF 79 C3 66 FA  \nWhen stored in the Wind ows registry, the encryption key is the classname associated with the \nfollowing key:  \nSECURITY \\Policy\\Secrets\\n \nThe following initial 8 -byte sequences are known to be used by NTFS or FAT -16 filesystems as \nobserved : \nEB 52 90 4E 54 46 53 20  \nEB 5B 90 4E 54 46 53 20 \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 38 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    EB 3C 90 4D 53 44 4F 53  \nEB 00 00 00 00 00 00 00  \nFor tool development, the following test vector illustrates the encryption of the first given header \nabove (EB 52 90 ) using CAST -128 with the default key shown above and the IV constructed as \ndescribe d, given this header occurs at the beginning of the first 512 -byte block of the covert store.  \nPlaintext :  EB 52 90 4E 54 46 53 20  \nKey:   A1 D2 10 B7 60 5E DA 0F A1 65 AF EF 79 C3 66 FA  \nIV:   00 D2 10 B7 60 5E DA 0F  \nCiphertext :  C2 C7 F4 CA F7 DA 3A C8  \nBy encrypting each possible initial filesystem byte sequence with CAST -128 using the key obtained \nfrom the registry or the default encryption key if the registry entry does not exist and searching for \nany file with a size that is an even multiple of 220, it is  possible to efficiently detect Snake covert \nstores. Validation can be performed by decrypting the entire file using the outlined methodology and \nthen verifying that it comprises an NTFS or FAT -16 filesystem.  \nOther On -Disk Artifact Detection  \nRegistry Blob  \nThe registry blob is generally found at the location listed below. In case it is not present at its typical \nlocation, the registry blob can be found by searching the full registry for a value of at least 0x1000 \nbytes in size and entropy of at least 7.9.  \nTypical Name : Unknown (RegBlob)  \nTypical Path : HKLM \\SOFTWARE \\Classes \\.wav\\OpenWithProgIds  \nCharacteristics : High Entropy  \nQueue File  \nTypical Name : < RANDOM_GUID >.<RANDOM_GUID>.crmlog  \nTypical Path : %windows \\registration \\ \nUnique Characteristics : High Entropy, file attributes of hidden, system, and archive  \nRole : Snake Queue File  \nThe Snake Queue File generally has a predictable path and filename structure, in addition to being \nhigh entropy. The Snake Queue File can be located by scanning all files in the typical queue path with \nfilenames matching a regular expression that captures the typical naming convention. Files meeting \nthese criteria should be scanned for high entropy, which is performed by the Yara rule below:  \nrule HighEntropy  \n{ \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 39 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR        meta: \n        descriptio n = \"entropy rule\"  \n \n    condition:  \n        math.entropy(0, filesize) >= 7.0  \n} \nThe following UNIX find command will scan files with names matching the GUID -based convention \n(note that the HighEntropy yara rule is assumed to be contained in a file named 1.y ar): \nfind /PATH/TO/WINDOWS_DIR -type f -regextype posix -egrep -iregex \\ \n    '.*\\/registration/( \\{[0-9A-F]{8}\\-([0-9A-F]{4}\\-){3}[0-9A-F]{12}\\}\\.){2}crmlog' \\ \n     -exec yara 1.yar {} \\; \nThe following PowerShell command does the same:  \nGet-ChildItem -Recurse -File -Path %WINDOWS% | Where -Object {  \n  $_.FullName -match \n  '(?i)/registration/( \\{[0-9A-F]{8}\\-([0-9A-F]{4}\\-){3}[0-9A-F]{12}\\}\\.){2}crmlog$'  \n} | ForEach -Object {  \n  yara 1.yar $_.FullName  \n} \nComadmin  \nTypical Name : comadmin.dat  \nTypical Path : %windows% \\system32 \\Com  \nUnique Characteristics : High Entropy  \nRole : Houses Snakes kernel driver and the drivers loader  \nThe Snake Comadmin file can be found using analogous techniques to that presented above for \nlocating the Snake Queue File. The following UNIX find command will do so:  \nfind /PATH/TO/WINDOWS -type f -regextype posix -egrep -iregex \\ \n    '.*\\/system32/Com/comadmin \\.dat' \\ \n     -exec yara 1.yar {} \\; \nThe following PowerShell command does the same:  \nGet-ChildItem -Recurse -File -Path %WINDOWS% | Where-Object {  \n    $_.FullName -match '(?i)/system32/Com/comadmin \\.dat$' \n} | ForEach -Object {  \n    yara 1.yar $_.FullName  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 40 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    } \nWerfault  \nTypical Name : Werfault.exe  \nTypical Path : %windows% \\WinSxS \\x86_microsoft -windows -\nerrorreportingfaults_31bf3856ad364e35_4.0.96 00.16384_none_a13f7e283339a0502 \\ \nUnique Characteristics : Icon is different than that of a valid Windows Werfault.exe file  \nRole : Persistence mechanism  \nThe Snake Werfault.exe file has non -standard icon sizes, which form the basis of the Yara rule below. \nThis rule should be run on all files in the typical path, specifically the %Windows% \\WinSxS directory.  \nrule PeIconSizes  \n{ \n    meta: \n        description = \"werfault rule\"  \n \n    condition:  \n        pe.is_pe  \n        and  \n        for any rsrc in pe.resources:  \n            (rsrc.type == pe.RESOURCE_TYPE_ICON and rsrc.length == 3240)  \n        and \n        for any rsrc in pe.resources:  \n            (rsrc.type == pe.RESOURCE_TYPE_ICON and rsrc.length == 1384)  \n        and \n        for any rsrc in pe.resources:  \n            (rsrc.type == pe.RESOURCE_TYPE_ICON and rsrc.length == 7336)  \n} \nMemory Analysis  \nAdvantages : High confidence as memory provides the greatest level of visibility into Snakes \nbehaviors and artifacts.  \nDisadvantages : Potential impact on system stability,  difficult scalability.  \nCapturing and analyzing the memory of a system will be the most effective approach in detecting \nSnake because it bypasses many of the behaviors that Snake employs to hide itself. With a memory \nanalysis tool, such as Volatility, detection  of a Snake compromise may be possible.  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 41 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Snakes principal user mode component is injected into a chosen process via a single allocation of \nPAGE_EXECUTE_READWRITE memory. The starting offset is generally 0x20000000, however the \nmodule does allow for relocat ion if needed. Additionally, since the user mode component is not \nobfuscated in any way, a valid PE header can be located at the beginning of the allocated memory \nregion. Further validation can be performed by confirming the presence of strings known to ex ist in \nthe user mode component also within the memory region. A plugin compatible with Volatility3 which \ncan scan all processes on a system using this method is provided in the Appendix. A screenshot \nshowing the results of the plugin successfully detecting  Snake is displayed below.  \n \n  \n\n\n \n  International Partnership  TLP: CLEAR  \n \nPage 42 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    PREVENTION  \nNote that the mitigations that follow are not meant to protect against the initial access vector and are \nonly designed to prevent Snakes persistence and hiding techniques.  \nChange Credentials  and Apply Updates  \nSystem owners who are believed to be compromised by Snake are advised to change their \ncredentials immediately (from a non -compromised system) and to not use any type of passwords \nsimilar to those used before. Snake employs a keylogger functionality that ro utinely returns logs back \nto FSB operators. Changing passwords and usernames to values which cannot be brute forced or \nguessed based on old passwords is recommended.  \nSystem owners are advised to apply updates to their Operating Systems. Modern versions of \nWindows, Linux, and MacOS make it much harder for adversaries to operate in the kernel space. This \nwill make it much harder for FSB actors to load Snakes kernel driver on the target system.  \nExecute Organizational Incident Response Plan  \nIf system owners re ceive detection signatures of Snake implant activity or have other indicators of \ncompromise that are associated with FSB actors using Snake , the impacted organization should \nimmediately initiate their documented incident response plan.  \nWe recommend implementing the following Cross -Sector Cybersecur ity Performance Goals (CPGs) \nto help defend against FSB actors using Snake , or mitigate negative impacts post -compromise:  \nCPG 2.A: Changing Default Passwords  will prevent FSB actors from compromising defaul t \ncredentials to gain initial access or move laterally within a network.  \nCPG 2.B: Requiring Minimum Password Strength across an organization will prevent FSB actors \nfrom being able to successfully conduct password spraying or cracking operations.  \nCPG 2.C:  Requiring Unique Credentials  will prevent FSB actors from compromising valid accounts \nthrough password spraying or brute force.  \nCPG 2.E Separating User and Privileged Accounts  will make it harder for FSB actors to gain \naccess to administrator credentials . \nCPG 2.F. Network Segmentation  to deny all connections by default unless explicitly required fo r \nspecific system functionality, and  ensure all incoming communication is going through a properly \nconfigured firewall.  \nCPG 2.H Implementing Phishing Resistant MFA  adds an additional layer of security even when \naccount credentials are compromised and can mitigate a variety of attacks towards valid accounts, to \ninclude brute forcing passwords and exploiting external remote services software.  \nCPG 4.C. Deploy Securi ty.txt Files  to ensure  all public facing web domains have a security.txt file \nthat conforms to the recommendations in RFC 9118.   \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 43 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    APPENDIX  \nPartnership  \nThis advisory was developed as a joint effort by an international partnership of multiple agencies in \nfurtherance of the respective cybersecurity missions of each of the partner agencies, including our \nresponsibilities to develop and issue cybersecurity specifications and mitigations. This partnership \nincludes the following organizations:  \n Federal Bureau of Investigation  \n National Security Agency  \n Cybersecurity and Infrastructure  Security Agency  \n Cyber National Mission Force  \n The United Kingdoms  National Cyber Security Centre  \n Canadian Centre for Cyber Security  \n Communications Security Establishment  \n Australian Cyber Security Centre  \n New Zealand National Cyber Security Centre  \nCollectively, we use a variety of sources, methods, and partnerships to ac quire information about \nforeign cyber threats. This advisory contains the information we have concluded can be publicly \nreleased, consistent with the protection of sources and methods and the public interest.  \nDisclaimer  \nThe information in this report is be ing provided as is for informational purposes only. We do not \nendorse any commercial product or service, including any subjects of analysis. Any reference to \nspecific commercial products, processes, or services by service mark, trademark, manufacturer, o r \notherwise, does not constitute or imply endorsement, recommendation, or favoring by co -authors.   \nMITRE ATT&CK Techniques  \nThis advisory uses the MITRE ATT&CK for Enterprise framework, version 13. See MITRE ATT&CK \nfor Enterprise  for all referenced tactics and techniques. MITRE and ATT&CK are registered trademarks \nof The MITRE Corporation. This report references the following MITRE ATT&CK techniques . \nTechnique Title  ID Use \nNetwork Connection \nEnumeration  T0840  Adversaries may perform network connection enumeration to \ndiscover information about device communication patterns.  \nData Obfuscation  T1001  Adversaries may obfuscate command and control traffic to make \nit more difficult to detect.  \nProtocol Impersonation  T1001.003  Adversaries may impersonate legitimate protocols  or web service \ntraffic to disguise command and control activity and thwart \nanalysis efforts.  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 44 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    OS Credential Dumping  T1003  Adversaries may attempt to dump credentials to obtain account \nlogin and credential material, normally in the form of a hash or a \nclear text password, from the operating system and software.  \nRootkit  T1014  Adversaries may use rootkits to hide the presence of programs, \nfiles, network connections, services, drivers, and other system \ncomponents.  \nObfuscated Files or \nInformation  T1027  Adversarie s may attempt to make an executable or file difficult to \ndiscover or analyze by encrypting, encoding, or otherwise \nobfuscating its contents on the system or in transit.  \nSoftware Packing  T1027. 002 Adversaries may perform software packing or virtual machine \nsoftware protection to conceal their code.  \nMasquerading  T1036  Adversaries may attempt to manipulate features of their artifacts \nto make them appear legitimate or benign to users and/or \nsecurity tools.  \nNetwork Sniffing  T1040  Adversaries may sniff network traffic to capture information about \nan environment, including authentica tion material passed over \nthe network.  \nNetwork Service Discovery  T1046  Adversaries may attempt to get a listing of services running on \nremote hosts and local network infrastructure devices, includ ing \nthose that may be vulnerable to remote software exploitation.  \nDynamic -link Library \nInjection  T1055.001  Adversaries may inject dynamic -link libraries (DLLs) into \nprocesses in order to evade  process -based defenses as well as \npossibly elevate privileges.  \nKeylogging  T1056.001  Adversaries may log user keystrokes to intercept credentials as \nthe user types them.  \nPowerShell  T1059.001  Adversaries may abuse PowerShell comm ands and scripts for \nexecution.  \nApplication Layer Protocol  T1071  Adversaries may communicate using OSI application layer \nprotocols to avoid detection/network filtering by ble nding in with \nexisting traffic.  \nWeb Protocols  T1071.001  Adversaries may communicate using applicati on layer protocols \nassociated with web traffic to avoid detection/network filtering by \nblending in with existing traffic.  \nMail Protocols  T1071.003  Adversaries may communicate using application  layer protocols \nassociated with electronic mail delivery to avoid \ndetection/network filtering by ble nding in with existing traffic.  \nDNS  T1071.004  Adversaries may communicate using the Domain Name System \n(DNS) application layer protocol to avoid detection/network \nfiltering by ble nding in with existing traffic.  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 45 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Data Staged  T1074  Adversaries may stage collected data in a central location  or \ndirectory prior to Exfiltration.  \nValid Accounts  T1078  Adversaries may obtain and abuse credentials of existing \naccounts as a means of gaining Initial Access, Persistence, \nPrivilege Escalation,  or Defense Evasion.  \nFile and Directory \nDiscovery  T1083  Adversaries may enumerate files and directories or may search in \nspecific locations of a host or network share for certain \ninformation within a file system.  \nMulti -hop Proxy  T1090.003  To disguise the source of malicious traffic, adversaries may chain \ntogether multiple proxies.  \nNon-Application Layer \nProtocol  T1095  Adversaries may use an OSI non -application layer protocol for \ncommunication between host and C2 server or among i nfected \nhosts within a network.  \nMulti -Stage Channels  T1104  Adversaries may create multiple stages for command and control \nthat are employed under different conditions or for certain \nfunctions.  \nNative API  T1106  Advers aries may interact with the native OS application \nprogramming interf ace (API) to execute behaviors.  \nModify Registry  T1112  Adversaries may interact with the Windows Registry to hide \nconfiguration information within Registry keys, remove \ninformation as part of cleaning up, or as part of other techniques \nto aid in persistence and execution.  \nAutomated Collection  T1119  Once established within a system or network, an adversary may \nuse automated technique s for collecting internal data.  \nData Encoding  T1132  Adversaries may encode data to make the content of command \nand control tr affic more  difficult to detect.  \nNon-Standard Encoding  T1132.002  Adversaries may encode data with a non -standard data encoding \nsystem to make the content of command and control tr affic more \ndifficult to detect.  \nNetwork Share Discovery  T1135  Adversaries may look for folders and drives shared on remote \nsystems as a means of identifying sources of information to \ngather as a precursor for Collection and to identify potential \nsystems of  interest for Lateral Movement.  \nDeobfuscate/Decode Files \nor Information  T1140  Adversaries may use Obfuscated Files or Information to hide \nartifacts of an intrusion from analysis.  \nExploit Public -Facing \nApplication  T1190  Adversaries may attempt to exploit a weakness in an Internet -\nfacing host or system to initially access a network.  \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 46 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Domain Trust Dis covery  T1482  Adversaries may attempt to gather information on domain trust \nrelationships that may be used to identify lateral movement \nopportunities in Windows mu lti-domain/forest environments.  \nInstaller Packages  T1546.016  Adversaries may establish persistence and elevate privileges by \nusing an installer to trigger the execution of malicious content.  \nDynamic Linker Hijacking  T1547.006  Adversaries may execute their own malicious payloads by \nhijacking environment variables the dynamic linker uses to load \nshared libraries.  \nInter-Process \nCommunication  T1559  Adversaries may abuse inter -process communication (IPC) \nmechanisms for l ocal code or command execution.  \nArchive Collected Data  T1560.003  An adver sary may compress and/or encrypt data that is c ollected \nprior to exfiltration.  \nHide Artifacts  T1564  Adversaries may attempt to hide artifacts associated with the ir \nbehaviors to evade detection . \nService Execution  T1569.002  Adversaries may abuse the Windows service control manager to \nexecute malicious commands or payloads.  \nLateral Tool Transfer  T1570  Adversaries may transfer tools or other files between system s in \na compromised environment.  \nProtocol Tunneling  T1572  Adversaries may tunnel network communications to and from a \nvictim system within a separate protocol to avoid \ndetection/network filtering and/or enable access to  otherwise \nunreachable systems.  \nEncrypted Channel  T1573  Adversaries may employ a known encryption algorithm to conceal \ncommand and control traffic rather than relying on any inherent \nprotections provi ded by a communication protocol . \nSymmetric Cryptography  T1573.001  Adversaries may employ a known symmetric encryption algorithm \nto conceal command and control traffic rather than relying on any \ninherent protections provid ed by a communication protocol.  \nAsymmetric Cryptography  T1573.002  Adversaries may employ a known asymmetric encryption \nalgorithm to conceal command and control traffic rather than \nrelying on any inherent protections provid ed by a communication \nprotoco l. \nDLL Side -Loading  T1574.002  Adversaries may execute their own malicious payloads by si de-\nloading DLLs.  \nCompromise Infrastructure  T1584  Adversaries may compromise third -party infrastructure tha t can \nbe used during targeting.  \nMalware  T1587.001  Adversaries may develop malware and malware components th at \ncan be used during t argeting . \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 47 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR    Obtain Capabilities  T1588  Adversaries may buy and/or steal capabilities th at can be used \nduring targeting . \nStage Capabilities  T1608  Adversaries may upload, install, or otherwise set up capabilities \nthat can be used during targeting.  \nDeploy Container  T1610  Adversaries may deploy a container into an environment to \nfacilita te execution or evade defenses.  \nVolatility Plugin  \nThe following plugin for the Volatility memory analysis framework will scan all processes on the \nsystem until it finds the Snake user  mode component injected into a process. If found, the plugin will \nlist both the injected process and the virtual memory address at which the Snake user  mode \ncomponent is loaded.  \n# This plugin to identify the injected usermode component of Snake is based  \n# on the malfind plugin released with Volatility3  \n# \n# This file is Copyright 2019 Volatility Foundation and licensed under the  \n# Volatility Software License 1.0  \n# which is available at https://www.volatilityfoundation.org/license/vsl -v1.0 \nimport logging \nfrom typing import Iterable , Tuple \nfrom volatility3 .framework import interfaces , symbols, exceptions , renderers  \nfrom volatility3 .framework .configuration import requirements  \nfrom volatility3 .framework .objects import utility \nfrom volatility3 .framework .renderers import format_hints  \nfrom volatility3 .plugins.windows import pslist, vadinfo \nvollog = logging.getLogger (__name__ ) \nclass snake(interfaces .plugins.PluginInterface ): \n    _required_framework_version = (2, 4, 0) \n     \n    @classmethod  \n    def get_requirements (cls): \n        return [ \n            requirements .ModuleRequirement (name = 'kernel' ,  \n   description = 'Windows kernel' ,  \n   architectures = [\"Intel32\" , \"Intel64\" ]), \n            requirements .VersionRequirement (name = 'pslist' ,  \n   component = pslist.PsList, version = (2, 0, 0)), \n            requirements .VersionRequirement (name = 'vadinfo' ,  \n   component = vadinfo.VadInfo, version = (2, 0, 0))] \n \n    @classmethod  \n    def list_injections ( \n            cls, context: interfaces .context.ContextInterface ,  \n   kernel_layer_name : str, symbol_table : str, \n            proc: interfaces .objects.ObjectInterface ) -> Iterable [ \n   Tuple[interfaces .objects.ObjectInterface , bytes]]: \n        proc_id = \"Unknown\"  \n        try: \n\n \n  International Partnership  TLP: CLEAR  \n \nPage 48 of 48  |  Product ID : AA23 -129A  \nTLP:CLEAR                proc_id = proc.UniqueProcessId  \n            proc_layer_name = proc.add_process_layer () \n        except exceptions .InvalidAddressException as excp: \n            vollog.debug(\"Process {}: invalid address {} in layer {}\" . \n   format(proc_id, excp.invalid_address , excp.layer_name )) \n            return \n        proc_layer = context.layers[proc_layer_name ] \n        for vad in proc.get_vad_root ().traverse (): \n            protection_string = vad.get_protection (vadinfo.VadInfo. \n   protect_values (context, kernel_layer_name , symbol_table ),  \n   vadinfo.winnt_protections ) \n            if not \"PAGE_EXECUTE_READWRITE\"  in protection_string : \n                continue  \n \n            if (vad.get_private_memory () == 1 \n                    and vad.get_tag() == \"VadS\") or (vad.get_private_memory ()  \n     == 0 and protection_string !=  \n     \"PAGE_EXECUTE_WRITECOPY\" ): \n                data = proc_layer .read(vad.get_start (),  \n    vad.get_size (), pad = True) \n                if data.find(b'\\x4d\\x5a') != 0: \n                    continue  \n                yield vad, data \n \n    def _generator (self, procs): \n        kernel = self.context.modules[self.config['kernel' ]] \n        is_32bit_arch = not symbols.symbol_table_is_64bit (self.context,  \n  kernel.symbol_table_name ) \n        for proc in procs: \n            process_name = utility.array_to_string (proc.ImageFileName ) \n            for vad, data in self.list_injections (self.context,  \n   kernel.layer_name , kernel.symbol_table_name , proc): \n                strings_to_find = [b'\\x25\\x73\\x23\\x31',b'\\x25\\x73\\x23\\x32', \n    b'\\x25\\x73\\x23\\x33',b'\\x25\\x73\\x23\\x34',  \n    b'\\x2e\\x74\\x6d\\x70', b'\\x2e\\x73\\x61\\x76', \n    b'\\x2e\\x75\\x70\\x64'] \n                if not all(stringToFind in data for  \n    stringToFind in strings_to_find ): \n                    continue  \n                yield (0, (proc.UniqueProcessId , process_name ,  \n    format_hints .Hex(vad.get_start ()), \n                           format_hints .Hex(vad.get_size ()), \n                           vad.get_protection ( \n                               vadinfo.VadInfo.protect_values (self.context,  \n    kernel.layer_name , kernel.symbol_table_name ),  \n    vadinfo.winnt_protections ))) \n                return \n \n    def run(self): \n        kernel = self.context.modules[self.config['kernel' ]] \n        return renderers .TreeGrid ([(\"PID\", int), (\"Process\" , str),  \n  (\"Address\" , format_hints .Hex), (\"Length\" , format_hints .Hex),  \n  (\"Protection\" , str)], self._generator (pslist.PsList.list_processes ( \n  context = self.context, layer_name = kernel.layer_name ,   \n  symbol_table = kernel.symbol_table_name ))) \n\n",
  "cves": [],
  "techniques": [
    "T1106",
    "T1573.001",
    "T1090.003",
    "T1608",
    "T1055.001",
    "T1119",
    "T1190",
    "T1560.003",
    "T1132",
    "T1071.001",
    "T1482",
    "T1135",
    "T1559",
    "T1027",
    "T1059.001",
    "T1095",
    "T1078",
    "T1036",
    "T1074",
    "T1570",
    "T1014",
    "T1001",
    "T1546.016",
    "T1569.002",
    "T1071",
    "T1071.004",
    "T1572",
    "T1584",
    "T1564",
    "T1083",
    "T1027.002",
    "T1104",
    "T1071.003",
    "T1587.001",
    "T1547.006",
    "T0840",
    "T1574.002",
    "T1001.003",
    "T1573.002",
    "T1003",
    "T1056.001",
    "T1112",
    "T1573",
    "T1040",
    "T1140",
    "T1046",
    "T1588",
    "T1610",
    "T1132.002"
  ],
  "advisory": "cybersecurity-alerts",
  "title": "joint_csa_hunting_ru_intel_snake_malware_20230509",
  "source": "nsa",
  "id": "926dbd49b56d2d3766e33e99f061a65c2cae11dfbf4b8220fea78c610983f298"
}